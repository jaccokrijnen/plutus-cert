File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The extraction is currently set to bypass opacity, the following
opaque constant bodies have been accessed
: pre.gu_lam alpha_rename.alphaRename alpha.legalRenSwap_id
  SN_STLC_named_naive.L_var SN_STLC_named_naive.α_preserves_SN_R
  alpha_ctx_sub.αctx_trans SN_STLC_named_naive.L_sn SN_STLC_named_naive.L_nc
  SN_STLC_named_naive.L_cl SN_STLC_named_naive.sn_ty_fun
  SN_STLC_named_naive.step_naive_preserves_alpha2
  SN_STLC_named_naive.step_gu_na_appr_fold constructions.s_constr__gu
  SN_STLC_named_naive.step_gu_na_appl_fold constructions.sconstr2_nc_s_t
  SN_STLC_named_naive.L_reducible port_plut2.sn_step_plut pre.nc_app_r
  pre.nc_app_l alpha.alphaIdShadowsVacuous
  constructions.KindOfUniqueRhsFreshMultiple kind_checking_default_uni_sound
  SN_STLC_named_naive.step_gu_naive_preserves_alpha
  SN_STLC_named_naive.sn_ty_forall pre.gu_app_r pre.gu_app_l
  constructions.to_GU__GU SN_STLC_named2.step_nd_implies_step_gu_na
  pre.alpha_preserves_nc_ctx constructions.sconstr2_nc_s
  alpha.sym_alpha_ctx_left_is_sym SN_normalise constructions.to_GU__alpha_
  alpha.alphavar_extend_id_split SN_STLC_named_naive.id_subst__EL
  alpha.ctx_id_left_is_id SN_STLC_named2.SN_na_to_SN_nd
  pre.step_naive_preserves_nc_ctx constructions.alpha_extend_fresh_tv
  constructions.t_constr__a_t constructions.t_constr__a_s
  SN_STLC_named_naive.L_cl_star port_plut2.sn_preimage2
  SN_STLC_named_naive.sn_subst SN_STLC_named_naive.soundness
  SN_STLC_named_naive.red_gu_na_trans SN_STLC_named_naive.extend_EL
  alpha.alpha_trans SN_STLC_named_naive.SN_naive
  alpha_ctx_sub.alpha_ctx_right_ex constructions.R_constr__a_s
  constructions.to_GU_applam_unfold alpha.alphavar_refl_weaken_vacuouss
  constructions.to_GU_app_unfold SN_STLC_named_naive.step_gu_na_lam_fold
  constructions.to_GU__alpha_' alpha_rename.alpha_trans_rename_right step_dec
  pre.gu_applam_to_nc alpha.alpha_extend_id constructions.s_constr__a_s
  alpha.alpha_swap alpha.alpha_refl SN_STLC_named_naive.red_gu_na_lam_fold
  SN_STLC_named2.substituteTCA_preserves_alpha alpha.alpha_sym
  constructions.KindOfUniqueRhsFresh SN_STLC_named2.strong_normalization
  alpha.alpha_extend_id_split alpha.alphavar_weaken kind_checking_sound
  constructions.id_ctx_alphavar_refl SN_STLC_named2.subs_preserves_alpha'
  SN_STLC_named_naive.step_subst_single SN_STLC_named_naive.red_beta
  SN_STLC_named_naive.id_subst_is_IdSubst alpha_typing.alpha_preserves_typing
  SN_STLC_named2.alpha_capms_to_naive constructions.IdCtx__KindOfUniqueRhs
  alpha_typing.substituteTCA_vacuous port_plut2.f_preserves_step
  port_plut2.f_preserves_kind constructions.alpha_extend_fresh
  alpha.cons_split_helper SN_STLC_named_naive.red_gu_na_appr_fold
  constructions.to_GU__GU_ constructions.to_GU'__NC constructions.to_GU'__GU
  SN_STLC_named_naive.red_gu_na_appl_fold constructions.map_creates_IdCtx
  constructions.to_GU''__GU_lam
  SN_STLC_named_naive.red_gu_naive_preserves_alpha constructions.to_GU__alpha
  SN_STLC_named_naive.beta_expansion_subst SN_STLC_named_naive.reducible_sn
  SN_STLC_named_naive.subs_preserves_alpha_σ_R
  SN_STLC_named2.α_preserves_sn_nd SN_STLC_named_naive.gu_app_st__gu_app_ts
  alpha.alpha_extend_ids_right SN_STLC_named_naive.sn_preimage_α
  alpha.alphavar_swap alpha.alphavar_refl alpha.id_left_trans
  SN_STLC_named_naive.step_gu_naive_app_l alpha.shadow_helper_not_break
  constructions.sconstr2_alpha_t constructions.sconstr2_alpha_s
  constructions.sconstr2_alpha_p alpha.alpha_var_trans
  SN_STLC_named_naive.sn_preimage_α' SN_STLC_named_naive.type_L
  constructions.a_constr__t_alpha alpha.id_right_trans
  SN_STLC_named_naive.id_subst__ParSeq
  SN_STLC_named_naive.alpha_rename_binder_stronger
  SN_STLC_named_naive.reducible_var SN_STLC_named2.step_nd_preserves_alpha
  alpha.alpha_extend_ids alpha.alpha_extend_id'
  constructions.a_constr__s_alpha constructions.s_constr__nc_s
  alpha_ctx_sub.alpha_ctx_ren_nil
  constructions.alpha_ctx_ren_extend_fresh_ftv
  port_plut2.plutus_ty_strong_normalization constructions.to_GU'__alpha
  constructions.to_GU''__alpha step_preserves_kinding
  alpha.idCtxNotBreakShadowing alpha_rename.alpha_trans_rename_left
  SN_STLC_named_naive.red_gu_na_app_fold SN_STLC_named_naive.sn_closedL
  SN_STLC_named_naive.commute_sub_naive alpha.ctx_id_right_is_id
  alpha.sym_alpha_ctx_is_sym SN_STLC_named_naive.beta_expansion'
  SN_STLC_named_naive.α_preserves_L_R constructions.nc_helper
  SN_STLC_named2.GU_step_d_implies_step_na constructions.t_constr__nc_s
  pre.nc_lam.
 [extraction-opaque-accessed,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The following axioms must be realized in the extracted
code: constructions.t_constr__nc_subs alpha.alphavar_extend_ids
      constructions.sconstr2_nc_sub constructions.sconstr2_nc_t
      substituteTCA_preserves_kinding constructions.a_R_constr_UniqueRHS
      alpha.lrs_trans alpha.alpha_vacuous_R alpha.alpha_weaken_ids
      constructions.t_constr__a_sigma constructions.a_R_constr_alpha_s
      alpha.alpha_extend_id'' Ty_dec alpha.lrs_sym
      alpha.alpha_extend_vacuous_ftv step_preserves_kinding_SOP_axiom.
 [extraction-axiom-to-realize,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The identifier has_kind__ind contains __ which is reserved for the
extraction [extraction-reserved-identifier,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The identifier IdCtx__KindOfUniqueRhs contains __ which is reserved
for the extraction [extraction-reserved-identifier,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The identifier to_GU__alpha_' contains __ which is reserved for the
extraction [extraction-reserved-identifier,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The identifier to_GU__alpha_ contains __ which is reserved for the
extraction [extraction-reserved-identifier,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The identifier to_GU__alpha contains __ which is reserved for the
extraction [extraction-reserved-identifier,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The identifier to_GU__GU_ contains __ which is reserved for the
extraction [extraction-reserved-identifier,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The identifier to_GU__GU contains __ which is reserved for the
extraction [extraction-reserved-identifier,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The identifier to_GU'__alpha contains __ which is reserved for the
extraction [extraction-reserved-identifier,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The identifier to_GU'__GU contains __ which is reserved for the
extraction [extraction-reserved-identifier,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The identifier to_GU'__NC contains __ which is reserved for the
extraction [extraction-reserved-identifier,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The identifier to_GU''__alpha contains __ which is reserved for the
extraction [extraction-reserved-identifier,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The identifier to_GU''__GU_lam contains __ which is reserved for the
extraction [extraction-reserved-identifier,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The identifier a_constr__t_alpha contains __ which is reserved for
the extraction [extraction-reserved-identifier,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The identifier a_constr__s_alpha contains __ which is reserved for
the extraction [extraction-reserved-identifier,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The identifier t_constr__a_t contains __ which is reserved for the
extraction [extraction-reserved-identifier,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The identifier R_constr__a_s contains __ which is reserved for the
extraction [extraction-reserved-identifier,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The identifier t_constr__a_s contains __ which is reserved for the
extraction [extraction-reserved-identifier,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The identifier t_constr__a_sigma contains __ which is reserved for
the extraction [extraction-reserved-identifier,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The identifier t_constr__nc_s contains __ which is reserved for the
extraction [extraction-reserved-identifier,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The identifier t_constr__nc_subs contains __ which is reserved for
the extraction [extraction-reserved-identifier,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The identifier s_constr__a_s contains __ which is reserved for the
extraction [extraction-reserved-identifier,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The identifier s_constr__gu contains __ which is reserved for the
extraction [extraction-reserved-identifier,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The identifier s_constr__nc_s contains __ which is reserved for the
extraction [extraction-reserved-identifier,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The identifier gu_app_st__gu_app_ts contains __ which is reserved
for the extraction [extraction-reserved-identifier,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The identifier __top_assumption_ contains __ which is reserved for
the extraction [extraction-reserved-identifier,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The identifier id_subst__EL contains __ which is reserved for the
extraction [extraction-reserved-identifier,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The identifier id_subst__ParSeq contains __ which is reserved for
the extraction [extraction-reserved-identifier,extraction,default]
File "./src/PlutusIR/Semantics/Static/Typing_sound_complete.v", line 939, characters 0-57:
Warning: The identifier __top_assumption_ contains __ which is reserved for
the extraction [extraction-reserved-identifier,extraction,default]
{-# OPTIONS_GHC -cpp -XMagicHash #-}
{- For Hugs, use the option -F"cpp -P -traditional" -}

module Main where

import qualified Prelude

#ifdef __GLASGOW_HASKELL__
import qualified GHC.Base
#if __GLASGOW_HASKELL__ >= 900
import qualified GHC.Exts
#endif
#else
-- HUGS
import qualified IOExts
#endif

#ifdef __GLASGOW_HASKELL__
unsafeCoerce :: a -> b
#if __GLASGOW_HASKELL__ >= 900
unsafeCoerce = GHC.Exts.unsafeCoerce#
#else
unsafeCoerce = GHC.Base.unsafeCoerce#
#endif
#else
-- HUGS
unsafeCoerce :: a -> b
unsafeCoerce = IOExts.unsafeCoerce
#endif

#ifdef __GLASGOW_HASKELL__
type Any = GHC.Base.Any
#else
-- HUGS
type Any = ()
#endif

__ :: any
__ = Prelude.error "Logical or arity value used"

false_rec :: a1
false_rec =
  Prelude.error "absurd case"

eq_rec_r :: a1 -> a2 -> a1 -> a2
eq_rec_r _ h _ =
  h

data Bool =
   True
 | False

bool_rect :: a1 -> a1 -> Bool -> a1
bool_rect f0 f1 b =
  case b of {
   True -> f0;
   False -> f1}

bool_rec :: a1 -> a1 -> Bool -> a1
bool_rec =
  bool_rect

andb :: Bool -> Bool -> Bool
andb b1 b2 =
  case b1 of {
   True -> b2;
   False -> False}

orb :: Bool -> Bool -> Bool
orb b1 b2 =
  case b1 of {
   True -> True;
   False -> b2}

data Nat =
   O
 | S Nat

data Option a =
   Some a
 | None

data Sum a b =
   Inl a
 | Inr b

data Prod a b =
   Pair a b

fst :: (Prod a1 a2) -> a1
fst p =
  case p of {
   Pair x _ -> x}

snd :: (Prod a1 a2) -> a2
snd p =
  case p of {
   Pair _ y -> y}

data List a =
   Nil
 | Cons a (List a)

list_rect :: a2 -> (a1 -> (List a1) -> a2 -> a2) -> (List a1) -> a2
list_rect f0 f1 l =
  case l of {
   Nil -> f0;
   Cons y l0 -> f1 y l0 (list_rect f0 f1 l0)}

list_rec :: a2 -> (a1 -> (List a1) -> a2 -> a2) -> (List a1) -> a2
list_rec =
  list_rect

app :: (List a1) -> (List a1) -> List a1
app l m =
  case l of {
   Nil -> m;
   Cons a l1 -> Cons a (app l1 m)}

data SigT a p =
   ExistT a p

projT1 :: (SigT a1 a2) -> a1
projT1 x =
  case x of {
   ExistT a _ -> a}

data Sumbool =
   Left
 | Right

sumbool_rect :: (() -> a1) -> (() -> a1) -> Sumbool -> a1
sumbool_rect f0 f1 s =
  case s of {
   Left -> f0 __;
   Right -> f1 __}

sumbool_rec :: (() -> a1) -> (() -> a1) -> Sumbool -> a1
sumbool_rec =
  sumbool_rect

bool_dec :: Bool -> Bool -> Sumbool
bool_dec b1 b2 =
  bool_rec (\x -> case x of {
                   True -> Left;
                   False -> Right}) (\x ->
    case x of {
     True -> Right;
     False -> Left}) b1 b2

eqb :: Bool -> Bool -> Bool
eqb b1 b2 =
  case b1 of {
   True -> b2;
   False -> case b2 of {
             True -> False;
             False -> True}}

in_dec :: (a1 -> a1 -> Sumbool) -> a1 -> (List a1) -> Sumbool
in_dec h a l =
  list_rec Right (\a0 _ iHl ->
    let {s = h a0 a} in case s of {
                         Left -> Left;
                         Right -> iHl}) l

remove :: (a1 -> a1 -> Sumbool) -> a1 -> (List a1) -> List a1
remove eq_dec x l =
  case l of {
   Nil -> Nil;
   Cons y tl ->
    case eq_dec x y of {
     Left -> remove eq_dec x tl;
     Right -> Cons y (remove eq_dec x tl)}}

rev :: (List a1) -> List a1
rev l =
  case l of {
   Nil -> Nil;
   Cons x l' -> app (rev l') (Cons x Nil)}

concat :: (List (List a1)) -> List a1
concat l =
  case l of {
   Nil -> Nil;
   Cons x l0 -> app x (concat l0)}

map :: (a1 -> a2) -> (List a1) -> List a2
map f0 l =
  case l of {
   Nil -> Nil;
   Cons a t -> Cons (f0 a) (map f0 t)}

fold_left :: (a1 -> a2 -> a1) -> (List a2) -> a1 -> a1
fold_left f0 l a0 =
  case l of {
   Nil -> a0;
   Cons b t -> fold_left f0 t (f0 a0 b)}

fold_right :: (a2 -> a1 -> a1) -> a1 -> (List a2) -> a1
fold_right f0 a0 l =
  case l of {
   Nil -> a0;
   Cons b t -> f0 b (fold_right f0 a0 t)}

existsb :: (a1 -> Bool) -> (List a1) -> Bool
existsb f0 l =
  case l of {
   Nil -> False;
   Cons a l0 -> orb (f0 a) (existsb f0 l0)}

filter :: (a1 -> Bool) -> (List a1) -> List a1
filter f0 l =
  case l of {
   Nil -> Nil;
   Cons x l0 ->
    case f0 x of {
     True -> Cons x (filter f0 l0);
     False -> filter f0 l0}}

data Ascii0 =
   Ascii Bool Bool Bool Bool Bool Bool Bool Bool

ascii_rect :: (Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool
              -> a1) -> Ascii0 -> a1
ascii_rect f0 a =
  case a of {
   Ascii b b0 b1 b2 b3 b4 b5 b6 -> f0 b b0 b1 b2 b3 b4 b5 b6}

ascii_rec :: (Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool ->
             a1) -> Ascii0 -> a1
ascii_rec =
  ascii_rect

ascii_dec :: Ascii0 -> Ascii0 -> Sumbool
ascii_dec a b =
  ascii_rec (\b0 b1 b2 b3 b4 b5 b6 b7 x ->
    case x of {
     Ascii b8 b9 b10 b11 b12 b13 b14 b15 ->
      sumbool_rec (\_ ->
        sumbool_rec (\_ ->
          sumbool_rec (\_ ->
            sumbool_rec (\_ ->
              sumbool_rec (\_ ->
                sumbool_rec (\_ ->
                  sumbool_rec (\_ ->
                    sumbool_rec (\_ -> Left) (\_ -> Right) (bool_dec b7 b15))
                    (\_ -> Right) (bool_dec b6 b14)) (\_ -> Right)
                  (bool_dec b5 b13)) (\_ -> Right) (bool_dec b4 b12)) (\_ ->
              Right) (bool_dec b3 b11)) (\_ -> Right) (bool_dec b2 b10))
          (\_ -> Right) (bool_dec b1 b9)) (\_ -> Right) (bool_dec b0 b8)}) a
    b

eqb0 :: Ascii0 -> Ascii0 -> Bool
eqb0 a b =
  case a of {
   Ascii a0 a1 a2 a3 a4 a5 a6 a7 ->
    case b of {
     Ascii b0 b1 b2 b3 b4 b5 b6 b7 ->
      case case case case case case case eqb a0 b0 of {
                                     True -> eqb a1 b1;
                                     False -> False} of {
                                True -> eqb a2 b2;
                                False -> False} of {
                           True -> eqb a3 b3;
                           False -> False} of {
                      True -> eqb a4 b4;
                      False -> False} of {
                 True -> eqb a5 b5;
                 False -> False} of {
            True -> eqb a6 b6;
            False -> False} of {
       True -> eqb a7 b7;
       False -> False}}}

data String =
   EmptyString
 | String0 Ascii0 String

string_rect :: a1 -> (Ascii0 -> String -> a1 -> a1) -> String -> a1
string_rect f0 f1 s =
  case s of {
   EmptyString -> f0;
   String0 a s0 -> f1 a s0 (string_rect f0 f1 s0)}

string_rec :: a1 -> (Ascii0 -> String -> a1 -> a1) -> String -> a1
string_rec =
  string_rect

string_dec :: String -> String -> Sumbool
string_dec s1 s2 =
  string_rec (\x -> case x of {
                     EmptyString -> Left;
                     String0 _ _ -> Right}) (\a _ x x0 ->
    case x0 of {
     EmptyString -> Right;
     String0 a0 s ->
      sumbool_rec (\_ -> sumbool_rec (\_ -> Left) (\_ -> Right) (x s)) (\_ ->
        Right) (ascii_dec a a0)}) s1 s2

eqb1 :: String -> String -> Bool
eqb1 s1 s2 =
  case s1 of {
   EmptyString -> case s2 of {
                   EmptyString -> True;
                   String0 _ _ -> False};
   String0 c1 s1' ->
    case s2 of {
     EmptyString -> False;
     String0 c2 s2' ->
      case eqb0 c1 c2 of {
       True -> eqb1 s1' s2';
       False -> False}}}

append :: String -> String -> String
append s1 s2 =
  case s1 of {
   EmptyString -> s2;
   String0 c s1' -> String0 c (append s1' s2)}

concat0 :: String -> (List String) -> String
concat0 sep ls =
  case ls of {
   Nil -> EmptyString;
   Cons x xs ->
    case xs of {
     Nil -> x;
     Cons _ _ -> append x (append sep (concat0 sep xs))}}

is_left :: Sumbool -> Bool
is_left u =
  case u of {
   Left -> True;
   Right -> False}

map2 :: (a1 -> a2) -> (List (List a1)) -> List (List a2)
map2 f0 ll =
  map (map f0) ll

data ForallSet a p =
   ForallS_nil
 | ForallS_cons a (List a) p (ForallSet a p)

forallSet_rect :: a3 -> (a1 -> (List a1) -> a2 -> (ForallSet a1 a2) -> a3 ->
                  a3) -> (List a1) -> (ForallSet a1 a2) -> a3
forallSet_rect f0 f1 _ f2 =
  case f2 of {
   ForallS_nil -> f0;
   ForallS_cons x xs y f3 -> f1 x xs y f3 (forallSet_rect f0 f1 xs f3)}

forallSet_rec :: a3 -> (a1 -> (List a1) -> a2 -> (ForallSet a1 a2) -> a3 ->
                 a3) -> (List a1) -> (ForallSet a1 a2) -> a3
forallSet_rec =
  forallSet_rect

data ForallSet2 a p =
   ForallS2_nil
 | ForallS2_cons (List a) (List (List a)) (ForallSet a p) (ForallSet2 a p)

forallSet2_rect :: a3 -> ((List a1) -> (List (List a1)) -> (ForallSet 
                   a1 a2) -> (ForallSet2 a1 a2) -> a3 -> a3) -> (List
                   (List a1)) -> (ForallSet2 a1 a2) -> a3
forallSet2_rect f0 f1 _ f2 =
  case f2 of {
   ForallS2_nil -> f0;
   ForallS2_cons x xs f3 f4 -> f1 x xs f3 f4 (forallSet2_rect f0 f1 xs f4)}

forallSet2_rec :: a3 -> ((List a1) -> (List (List a1)) -> (ForallSet 
                  a1 a2) -> (ForallSet2 a1 a2) -> a3 -> a3) -> (List
                  (List a1)) -> (ForallSet2 a1 a2) -> a3
forallSet2_rec =
  forallSet2_rect

flatmap2 :: (a1 -> List a2) -> (List (List a1)) -> List a2
flatmap2 f0 l =
  fold_right (\ts acc ->
    app (fold_right (\t acc2 -> app (f0 t) acc2) Nil ts) acc) Nil l

data Recursivity =
   NonRec
 | Rec

data Strictness =
   NonStrict
 | Strict

data DefaultUni =
   DefaultUniInteger
 | DefaultUniByteString
 | DefaultUniString
 | DefaultUniUnit
 | DefaultUniBool
 | DefaultUniProtoList
 | DefaultUniProtoPair
 | DefaultUniData
 | DefaultUniBLS12_381_G1_Element
 | DefaultUniBLS12_381_G2_Element
 | DefaultUniBLS12_381_MlResult
 | DefaultUniApply DefaultUni DefaultUni

defaultUni_rect :: a1 -> a1 -> a1 -> a1 -> a1 -> a1 -> a1 -> a1 -> a1 -> a1
                   -> a1 -> (DefaultUni -> a1 -> DefaultUni -> a1 -> a1) ->
                   DefaultUni -> a1
defaultUni_rect f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 d =
  case d of {
   DefaultUniInteger -> f0;
   DefaultUniByteString -> f1;
   DefaultUniString -> f2;
   DefaultUniUnit -> f3;
   DefaultUniBool -> f4;
   DefaultUniProtoList -> f5;
   DefaultUniProtoPair -> f6;
   DefaultUniData -> f7;
   DefaultUniBLS12_381_G1_Element -> f8;
   DefaultUniBLS12_381_G2_Element -> f9;
   DefaultUniBLS12_381_MlResult -> f10;
   DefaultUniApply d0 d1 ->
    f11 d0 (defaultUni_rect f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 d0) d1
      (defaultUni_rect f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 d1)}

defaultUni_rec :: a1 -> a1 -> a1 -> a1 -> a1 -> a1 -> a1 -> a1 -> a1 -> a1 ->
                  a1 -> (DefaultUni -> a1 -> DefaultUni -> a1 -> a1) ->
                  DefaultUni -> a1
defaultUni_rec =
  defaultUni_rect

type UniType = Any

data Constant =
   ValueOf DefaultUni UniType

data DefaultFun =
   AddInteger
 | SubtractInteger
 | MultiplyInteger
 | DivideInteger
 | QuotientInteger
 | RemainderInteger
 | ModInteger
 | EqualsInteger
 | LessThanInteger
 | LessThanEqualsInteger
 | AppendByteString
 | ConsByteString
 | SliceByteString
 | LengthOfByteString
 | IndexByteString
 | EqualsByteString
 | LessThanByteString
 | LessThanEqualsByteString
 | Sha2_256
 | Sha3_256
 | Blake2b_256
 | VerifyEd25519Signature
 | VerifyEcdsaSecp256k1Signature
 | VerifySchnorrSecp256k1Signature
 | AppendString
 | EqualsString
 | EncodeUtf8
 | DecodeUtf8
 | IfThenElse
 | ChooseUnit
 | Trace
 | FstPair
 | SndPair
 | ChooseList
 | MkCons
 | HeadList
 | TailList
 | NullList
 | ChooseData
 | ConstrData
 | MapData
 | ListData
 | IData
 | BData
 | UnConstrData
 | UnMapData
 | UnListData
 | UnIData
 | UnBData
 | EqualsData
 | SerialiseData
 | MkPairData
 | MkNilData
 | MkNilPairData
 | Bls12_381_G1_add
 | Bls12_381_G1_neg
 | Bls12_381_G1_scalarMul
 | Bls12_381_G1_equal
 | Bls12_381_G1_hashToGroup
 | Bls12_381_G1_compress
 | Bls12_381_G1_uncompress
 | Bls12_381_G2_add
 | Bls12_381_G2_neg
 | Bls12_381_G2_scalarMul
 | Bls12_381_G2_equal
 | Bls12_381_G2_hashToGroup
 | Bls12_381_G2_compress
 | Bls12_381_G2_uncompress
 | Bls12_381_millerLoop
 | Bls12_381_mulMlResult
 | Bls12_381_finalVerify
 | Keccak_256
 | Blake2b_224
 | IntegerToByteString
 | ByteStringToInteger

type Name = String

type Tyname = String

type BinderName = String

type BinderTyname = String

data Kind =
   Kind_Base
 | Kind_Arrow Kind Kind

kind_rect :: a1 -> (Kind -> a1 -> Kind -> a1 -> a1) -> Kind -> a1
kind_rect f0 f1 k =
  case k of {
   Kind_Base -> f0;
   Kind_Arrow k0 k1 -> f1 k0 (kind_rect f0 f1 k0) k1 (kind_rect f0 f1 k1)}

kind_rec :: a1 -> (Kind -> a1 -> Kind -> a1 -> a1) -> Kind -> a1
kind_rec =
  kind_rect

data Ty =
   Ty_Var Tyname
 | Ty_Fun Ty Ty
 | Ty_IFix Ty Ty
 | Ty_Forall BinderTyname Kind Ty
 | Ty_Builtin DefaultUni
 | Ty_Lam BinderTyname Kind Ty
 | Ty_App Ty Ty
 | Ty_SOP (List (List Ty))

ty_rect :: (Tyname -> a1) -> (Ty -> a1 -> Ty -> a1 -> a1) -> (Ty -> a1 -> Ty
           -> a1 -> a1) -> (BinderTyname -> Kind -> Ty -> a1 -> a1) ->
           (DefaultUni -> a1) -> (BinderTyname -> Kind -> Ty -> a1 -> a1) ->
           (Ty -> a1 -> Ty -> a1 -> a1) -> ((List (List Ty)) -> a1) -> Ty ->
           a1
ty_rect f0 f1 f2 f3 f4 f5 f6 f7 t =
  case t of {
   Ty_Var t0 -> f0 t0;
   Ty_Fun t0 t1 ->
    f1 t0 (ty_rect f0 f1 f2 f3 f4 f5 f6 f7 t0) t1
      (ty_rect f0 f1 f2 f3 f4 f5 f6 f7 t1);
   Ty_IFix t0 t1 ->
    f2 t0 (ty_rect f0 f1 f2 f3 f4 f5 f6 f7 t0) t1
      (ty_rect f0 f1 f2 f3 f4 f5 f6 f7 t1);
   Ty_Forall b k t0 -> f3 b k t0 (ty_rect f0 f1 f2 f3 f4 f5 f6 f7 t0);
   Ty_Builtin d -> f4 d;
   Ty_Lam b k t0 -> f5 b k t0 (ty_rect f0 f1 f2 f3 f4 f5 f6 f7 t0);
   Ty_App t0 t1 ->
    f6 t0 (ty_rect f0 f1 f2 f3 f4 f5 f6 f7 t0) t1
      (ty_rect f0 f1 f2 f3 f4 f5 f6 f7 t1);
   Ty_SOP l -> f7 l}

ty_rec :: (Tyname -> a1) -> (Ty -> a1 -> Ty -> a1 -> a1) -> (Ty -> a1 -> Ty
          -> a1 -> a1) -> (BinderTyname -> Kind -> Ty -> a1 -> a1) ->
          (DefaultUni -> a1) -> (BinderTyname -> Kind -> Ty -> a1 -> a1) ->
          (Ty -> a1 -> Ty -> a1 -> a1) -> ((List (List Ty)) -> a1) -> Ty ->
          a1
ty_rec =
  ty_rect

data Vdecl =
   VarDecl BinderName Ty

data Tvdecl =
   TyVarDecl BinderTyname Kind

data Dtdecl =
   Datatype Tvdecl (List Tvdecl) BinderName (List Vdecl)

data Term =
   Let Recursivity (List Binding) Term
 | Var Name
 | TyAbs BinderTyname Kind Term
 | LamAbs BinderName Ty Term
 | Apply Term Term
 | Constant0 Constant
 | Builtin DefaultFun
 | TyInst Term Ty
 | Error Ty
 | IWrap Ty Ty Term
 | Unwrap Term
 | Constr Ty Nat (List Term)
 | Case Ty Term (List Term)
data Binding =
   TermBind Strictness Vdecl Term
 | TypeBind Tvdecl Ty
 | DatatypeBind Dtdecl

vdecl_name :: Vdecl -> BinderName
vdecl_name c =
  case c of {
   VarDecl n _ -> n}

vdecl_ty :: Vdecl -> Ty
vdecl_ty c =
  case c of {
   VarDecl _ ty -> ty}

tvdecl_name :: Tvdecl -> BinderTyname
tvdecl_name tvd =
  case tvd of {
   TyVarDecl v _ -> v}

splitTy :: Ty -> Prod (List Ty) Ty
splitTy t =
  case t of {
   Ty_Fun targ t' -> Pair (Cons targ (fst (splitTy t'))) (snd (splitTy t'));
   _ -> Pair Nil t}

lookup :: String -> (List (Prod String a1)) -> Option a1
lookup k l =
  case l of {
   Nil -> None;
   Cons p l' ->
    case p of {
     Pair j x -> case eqb1 j k of {
                  True -> Some x;
                  False -> lookup k l'}}}

drop :: String -> (List (Prod String a1)) -> List (Prod String a1)
drop n nxs =
  case nxs of {
   Nil -> Nil;
   Cons p nxs' ->
    case p of {
     Pair n' x ->
      case eqb1 n' n of {
       True -> drop n nxs';
       False -> Cons (Pair n' x) (drop n nxs')}}}

data Has_kind_uni =
   K_DefaultUniInteger
 | K_DefaultUniByteString
 | K_DefaultUniString
 | K_DefaultUniUnit
 | K_DefaultUniBool
 | K_DefaultUniData
 | K_DefaultUniBLS12_381_G1_Element
 | K_DefaultUniBLS12_381_G2_Element
 | K_DefaultUniBLS12_381_MlResult
 | K_DefaultUniApply Kind Kind DefaultUni DefaultUni Has_kind_uni Has_kind_uni
 | K_DefaultUniProtoPair
 | K_DefaultUniProtoList

data Has_kind =
   K_Var (List (Prod String Kind)) String Kind
 | K_Fun (List (Prod BinderName Kind)) Ty Ty Has_kind Has_kind
 | K_IFix (List (Prod BinderName Kind)) Ty Ty Kind Has_kind Has_kind
 | K_Forall (List (Prod BinderName Kind)) BinderName Kind Ty Has_kind
 | K_Builtin (List (Prod BinderName Kind)) DefaultUni Has_kind_uni
 | K_Lam (List (Prod BinderName Kind)) BinderName Kind Ty Kind Has_kind
 | K_App (List (Prod BinderName Kind)) Ty Ty Kind Kind Has_kind Has_kind
 | K_SOP (List (Prod BinderName Kind)) (List (List Ty)) ForallSet2_has_kind
data ForallSet2_has_kind =
   ForallSet2_nil (List (Prod BinderName Kind))
 | ForallSet2_cons (List (Prod BinderName Kind)) (List Ty) (List (List Ty)) 
 ForallSet_has_kind ForallSet2_has_kind
data ForallSet_has_kind =
   ForallSet_nil (List (Prod BinderName Kind))
 | ForallSet_cons (List (Prod BinderName Kind)) Ty (List Ty) Has_kind 
 ForallSet_has_kind

has_kind__ind :: ((List (Prod String Kind)) -> String -> Kind -> () -> a1) ->
                 ((List (Prod BinderName Kind)) -> Ty -> Ty -> Has_kind -> a1
                 -> Has_kind -> a1 -> a1) -> ((List (Prod BinderName Kind))
                 -> Ty -> Ty -> Kind -> Has_kind -> a1 -> Has_kind -> a1 ->
                 a1) -> ((List (Prod BinderName Kind)) -> BinderName -> Kind
                 -> Ty -> Has_kind -> a1 -> a1) -> ((List
                 (Prod BinderName Kind)) -> DefaultUni -> Has_kind_uni -> a1)
                 -> ((List (Prod BinderName Kind)) -> BinderName -> Kind ->
                 Ty -> Kind -> Has_kind -> a1 -> a1) -> ((List
                 (Prod BinderName Kind)) -> Ty -> Ty -> Kind -> Kind ->
                 Has_kind -> a1 -> Has_kind -> a1 -> a1) -> ((List
                 (Prod BinderName Kind)) -> (List (List Ty)) ->
                 ForallSet2_has_kind -> a2 -> a1) -> ((List
                 (Prod BinderName Kind)) -> a2) -> ((List
                 (Prod BinderName Kind)) -> (List Ty) -> (List (List Ty)) ->
                 ForallSet_has_kind -> a3 -> ForallSet2_has_kind -> a2 -> a2)
                 -> ((List (Prod BinderName Kind)) -> a3) -> ((List
                 (Prod BinderName Kind)) -> Ty -> (List Ty) -> Has_kind -> a1
                 -> ForallSet_has_kind -> a3 -> a3) -> (List
                 (Prod BinderName Kind)) -> Ty -> Kind -> Has_kind -> a1
has_kind__ind f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 =
  let {
   f12 _ _ _ h =
     case h of {
      K_Var _UU0394_ x k -> f0 _UU0394_ x k __;
      K_Fun _UU0394_ t1 t2 h0 h1 ->
       f1 _UU0394_ t1 t2 h0 (f12 _UU0394_ t1 Kind_Base h0) h1
         (f12 _UU0394_ t2 Kind_Base h1);
      K_IFix _UU0394_ f15 t k h0 h1 ->
       f2 _UU0394_ f15 t k h0 (f12 _UU0394_ t k h0) h1
         (f12 _UU0394_ f15 (Kind_Arrow (Kind_Arrow k Kind_Base) (Kind_Arrow k
           Kind_Base)) h1);
      K_Forall _UU0394_ x k t h0 ->
       f3 _UU0394_ x k t h0 (f12 (Cons (Pair x k) _UU0394_) t Kind_Base h0);
      K_Builtin _UU0394_ t h0 -> f4 _UU0394_ t h0;
      K_Lam _UU0394_ x k1 t k2 h0 ->
       f5 _UU0394_ x k1 t k2 h0 (f12 (Cons (Pair x k1) _UU0394_) t k2 h0);
      K_App _UU0394_ t1 t2 k1 k2 h0 h1 ->
       f6 _UU0394_ t1 t2 k1 k2 h0 (f12 _UU0394_ t1 (Kind_Arrow k1 k2) h0) h1
         (f12 _UU0394_ t2 k1 h1);
      K_SOP _UU0394_ tss f15 -> f7 _UU0394_ tss f15 (f13 _UU0394_ tss f15)};
   f13 _ _ f15 =
     case f15 of {
      ForallSet2_nil _UU0394_ -> f8 _UU0394_;
      ForallSet2_cons _UU0394_ ts tss f16 f17 ->
       f9 _UU0394_ ts tss f16 (f14 _UU0394_ ts f16) f17
         (f13 _UU0394_ tss f17)};
   f14 _ _ f15 =
     case f15 of {
      ForallSet_nil _UU0394_ -> f10 _UU0394_;
      ForallSet_cons _UU0394_ t ts h f16 ->
       f11 _UU0394_ t ts h (f12 _UU0394_ t Kind_Base h) f16
         (f14 _UU0394_ ts f16)}}
  in f12

data USort =
   Lam
 | ForAll

data BSort =
   App
 | IFix
 | Fun

data Term0 =
   Tmvar String
 | Tmlam USort String Kind Term0
 | Tmapp BSort Term0 Term0
 | Tmbuiltin DefaultUni

term_rect :: (String -> a1) -> (USort -> String -> Kind -> Term0 -> a1 -> a1)
             -> (BSort -> Term0 -> a1 -> Term0 -> a1 -> a1) -> (DefaultUni ->
             a1) -> Term0 -> a1
term_rect f0 f1 f2 f3 t =
  case t of {
   Tmvar s -> f0 s;
   Tmlam uSort s k t0 -> f1 uSort s k t0 (term_rect f0 f1 f2 f3 t0);
   Tmapp bSort t0 t1 ->
    f2 bSort t0 (term_rect f0 f1 f2 f3 t0) t1 (term_rect f0 f1 f2 f3 t1);
   Tmbuiltin d -> f3 d}

term_rec :: (String -> a1) -> (USort -> String -> Kind -> Term0 -> a1 -> a1)
            -> (BSort -> Term0 -> a1 -> Term0 -> a1 -> a1) -> (DefaultUni ->
            a1) -> Term0 -> a1
term_rec =
  term_rect

ftv :: Term0 -> List String
ftv t =
  case t of {
   Tmvar x -> Cons x Nil;
   Tmlam _ x _ t' -> remove string_dec x (ftv t');
   Tmapp _ t1 t2 -> app (ftv t1) (ftv t2);
   Tmbuiltin _ -> Nil}

btv :: Term0 -> List String
btv t =
  case t of {
   Tmlam _ x _ t' -> Cons x (btv t');
   Tmapp _ t1 t2 -> app (btv t1) (btv t2);
   _ -> Nil}

tv :: Term0 -> List String
tv s =
  case s of {
   Tmvar x -> Cons x Nil;
   Tmlam _ x _ s0 -> Cons x (tv s0);
   Tmapp _ s0 t -> app (tv s0) (tv t);
   Tmbuiltin _ -> Nil}

tv_keys_env :: (List (Prod String Term0)) -> List String
tv_keys_env sigma =
  case sigma of {
   Nil -> Nil;
   Cons p sigma' ->
    case p of {
     Pair x t -> Cons x (app (tv t) (tv_keys_env sigma'))}}

fresh2 :: (List (Prod String Term0)) -> Term0 -> String
fresh2 sigma t =
  append (String0 (Ascii True False False False False True True False)
    EmptyString) (concat0 EmptyString (app (tv_keys_env sigma) (tv t)))

mren :: (List (Prod String String)) -> Term0 -> Term0
mren rho t =
  case t of {
   Tmvar y -> case lookup y rho of {
               Some z -> Tmvar z;
               None -> Tmvar y};
   Tmlam b y k1 t_body ->
    let {rho' = drop y rho} in Tmlam b y k1 (mren rho' t_body);
   Tmapp b t1 t2 -> Tmapp b (mren rho t1) (mren rho t2);
   Tmbuiltin d -> Tmbuiltin d}

rename :: String -> String -> Term0 -> Term0
rename x y t =
  mren (Cons (Pair x y) Nil) t

substituteTCA :: String -> Term0 -> Term0 -> Term0
substituteTCA a a0 b =
  let {
   fix_F x =
     let {x0 = case x of {
                (,) pr1 _ -> pr1}} in
     let {u = case case x of {
                    (,) _ pr2 -> pr2} of {
               (,) pr1 _ -> pr1}} in
     let {
      substituteTCA1 = \a1 a2 b0 ->
       let {y = (,) a1 ((,) a2 b0)} in (\_ -> fix_F y)}
     in
     case case case x of {
                (,) _ pr2 -> pr2} of {
           (,) _ pr2 -> pr2} of {
      Tmvar s -> case eqb1 x0 s of {
                  True -> u;
                  False -> Tmvar s};
      Tmlam uSort s k t ->
       case eqb1 x0 s of {
        True -> Tmlam uSort s k t;
        False ->
         case existsb (eqb1 s) (ftv u) of {
          True ->
           let {y' = fresh2 (Cons (Pair x0 u) Nil) t} in
           let {t' = rename s y' t} in
           Tmlam uSort y' k (substituteTCA1 x0 u t' __);
          False -> Tmlam uSort s k (substituteTCA1 x0 u t __)}};
      Tmapp bSort t t0 -> Tmapp bSort (substituteTCA1 x0 u t __)
       (substituteTCA1 x0 u t0 __);
      Tmbuiltin d -> Tmbuiltin d}}
  in fix_F ((,) a ((,) a0 b))

substituteT :: String -> Ty -> Ty -> Ty
substituteT x u t =
  case t of {
   Ty_Var y -> case eqb1 x y of {
                True -> u;
                False -> Ty_Var y};
   Ty_Fun t1 t2 -> Ty_Fun (substituteT x u t1) (substituteT x u t2);
   Ty_IFix f0 t0 -> Ty_IFix (substituteT x u f0) (substituteT x u t0);
   Ty_Forall y k t' ->
    case eqb1 x y of {
     True -> Ty_Forall y k t';
     False -> Ty_Forall y k (substituteT x u t')};
   Ty_Builtin u0 -> Ty_Builtin u0;
   Ty_Lam y k1 t' ->
    case eqb1 x y of {
     True -> Ty_Lam y k1 t';
     False -> Ty_Lam y k1 (substituteT x u t')};
   Ty_App t1 t2 -> Ty_App (substituteT x u t1) (substituteT x u t2);
   Ty_SOP tss -> Ty_SOP (map2 (substituteT x u) tss)}

ftv0 :: Ty -> List String
ftv0 t =
  case t of {
   Ty_Var x -> Cons x Nil;
   Ty_Fun t1 t2 -> app (ftv0 t1) (ftv0 t2);
   Ty_IFix f0 t0 -> app (ftv0 f0) (ftv0 t0);
   Ty_Forall x _ t' -> remove string_dec x (ftv0 t');
   Ty_Builtin _ -> Nil;
   Ty_Lam x _ t' -> remove string_dec x (ftv0 t');
   Ty_App t1 t2 -> app (ftv0 t1) (ftv0 t2);
   Ty_SOP tss -> flatmap2 ftv0 tss}

plutusTv :: Ty -> List String
plutusTv t =
  case t of {
   Ty_Var x -> Cons x Nil;
   Ty_Fun t1 t2 -> app (plutusTv t1) (plutusTv t2);
   Ty_IFix f1 t1 -> app (plutusTv f1) (plutusTv t1);
   Ty_Forall x _ t0 -> Cons x (plutusTv t0);
   Ty_Builtin _ -> Nil;
   Ty_Lam x _ t0 -> Cons x (plutusTv t0);
   Ty_App t1 t2 -> app (plutusTv t1) (plutusTv t2);
   Ty_SOP tss -> flatmap2 plutusTv tss}

fresh :: String -> Ty -> Ty -> String
fresh x u t =
  append (String0 (Ascii True False False False False True True False)
    EmptyString)
    (append x
      (append (concat0 EmptyString (plutusTv u))
        (concat0 EmptyString (plutusTv t))))

rename0 :: String -> String -> Ty -> Ty
rename0 x y t =
  substituteT x (Ty_Var y) t

map' :: (List a1) -> (a1 -> () -> a2) -> List a2
map' xs x =
  case xs of {
   Nil -> Nil;
   Cons x0 xs0 -> Cons (x x0 __) (map' xs0 (\y _ -> x y __))}

substituteTCA0 :: String -> Ty -> Ty -> Ty
substituteTCA0 a a0 b =
  let {
   fix_F x =
     let {x0 = case x of {
                (,) pr1 _ -> pr1}} in
     let {u = case case x of {
                    (,) _ pr2 -> pr2} of {
               (,) pr1 _ -> pr1}} in
     let {
      substituteTCA1 = \a1 a2 b0 ->
       let {y = (,) a1 ((,) a2 b0)} in (\_ -> fix_F y)}
     in
     case case case x of {
                (,) _ pr2 -> pr2} of {
           (,) _ pr2 -> pr2} of {
      Ty_Var t -> case eqb1 x0 t of {
                   True -> u;
                   False -> Ty_Var t};
      Ty_Fun t t0 -> Ty_Fun (substituteTCA1 x0 u t __)
       (substituteTCA1 x0 u t0 __);
      Ty_IFix t t0 -> Ty_IFix (substituteTCA1 x0 u t __)
       (substituteTCA1 x0 u t0 __);
      Ty_Forall b0 k t ->
       case eqb1 x0 b0 of {
        True -> Ty_Forall b0 k t;
        False ->
         case existsb (eqb1 b0) (ftv0 u) of {
          True ->
           let {y' = fresh x0 u t} in
           let {t' = rename0 b0 y' t} in
           Ty_Forall y' k (substituteTCA1 x0 u t' __);
          False -> Ty_Forall b0 k (substituteTCA1 x0 u t __)}};
      Ty_Builtin d -> Ty_Builtin d;
      Ty_Lam b0 k t ->
       case eqb1 x0 b0 of {
        True -> Ty_Lam b0 k t;
        False ->
         case existsb (eqb1 b0) (ftv0 u) of {
          True ->
           let {y' = fresh x0 u t} in
           let {t' = rename0 b0 y' t} in
           Ty_Lam y' k (substituteTCA1 x0 u t' __);
          False -> Ty_Lam b0 k (substituteTCA1 x0 u t __)}};
      Ty_App t t0 -> Ty_App (substituteTCA1 x0 u t __)
       (substituteTCA1 x0 u t0 __);
      Ty_SOP l -> Ty_SOP
       (map' l (\ts _ -> map' ts (\t _ -> substituteTCA1 x0 u t __)))}}
  in fix_F ((,) a ((,) a0 b))

type EqDec a = a -> a -> Sumbool

kind_dec :: EqDec Kind
kind_dec x y =
  kind_rec (\x0 -> case x0 of {
                    Kind_Base -> Left;
                    Kind_Arrow _ _ -> Right}) (\_ x0 _ x1 x2 ->
    case x2 of {
     Kind_Base -> Right;
     Kind_Arrow k k0 ->
      sumbool_rec (\_ -> sumbool_rec (\_ -> Left) (\_ -> Right) (x1 k0))
        (\_ -> Right) (x0 k)}) x y

ty_dec :: EqDec Ty
ty_dec =
  Prelude.error "AXIOM TO BE REALIZED"

type Eqb x = x -> x -> Bool

eq_dec_to_eqb :: (EqDec a1) -> Eqb a1
eq_dec_to_eqb dec_eq x y =
  case dec_eq x y of {
   Left -> True;
   Right -> False}

kind_eqb :: Eqb Kind
kind_eqb =
  eq_dec_to_eqb kind_dec

ty_eqb :: Eqb Ty
ty_eqb =
  eq_dec_to_eqb ty_dec

kind_check_default_uni :: DefaultUni -> Option Kind
kind_check_default_uni d =
  case d of {
   DefaultUniProtoList -> Some (Kind_Arrow Kind_Base Kind_Base);
   DefaultUniProtoPair -> Some (Kind_Arrow Kind_Base (Kind_Arrow Kind_Base
    Kind_Base));
   DefaultUniApply t t' ->
    let {o = kind_check_default_uni t} in
    let {o0 = kind_check_default_uni t'} in
    case o of {
     Some k0 ->
      case k0 of {
       Kind_Base -> None;
       Kind_Arrow k k' ->
        case o0 of {
         Some k'' -> case kind_eqb k'' k of {
                      True -> Some k';
                      False -> None};
         None -> None}};
     None -> None};
   _ -> Some Kind_Base}

kind_checking_default_uni_sound :: DefaultUni -> Kind -> Has_kind_uni
kind_checking_default_uni_sound d k =
  defaultUni_rec (\_ _ -> K_DefaultUniInteger) (\_ _ ->
    K_DefaultUniByteString) (\_ _ -> K_DefaultUniString) (\_ _ ->
    K_DefaultUniUnit) (\_ _ -> K_DefaultUniBool) (\_ _ ->
    K_DefaultUniProtoList) (\_ _ -> K_DefaultUniProtoPair) (\_ _ ->
    K_DefaultUniData) (\_ _ -> K_DefaultUniBLS12_381_G1_Element) (\_ _ ->
    K_DefaultUniBLS12_381_G2_Element) (\_ _ ->
    K_DefaultUniBLS12_381_MlResult) (\d1 iHd1 d2 iHd2 k0 _ ->
    let {o = kind_check_default_uni d1} in
    case o of {
     Some k1 ->
      case k1 of {
       Kind_Base -> false_rec;
       Kind_Arrow k2 _ ->
        let {o0 = kind_check_default_uni d2} in
        case o0 of {
         Some k3 ->
          let {b = kind_eqb k3 k2} in
          case b of {
           True ->
            eq_rec_r k2 (\_ iHd3 -> K_DefaultUniApply k2 k0 d1 d2
              (iHd1 (Kind_Arrow k2 k0) __) (iHd3 k2 __)) k3 __ iHd2;
           False -> false_rec};
         None -> false_rec}};
     None -> false_rec}) d k __

kind_check :: (List (Prod BinderTyname Kind)) -> Ty -> Option Kind
kind_check delta ty =
  case ty of {
   Ty_Var x -> lookup x delta;
   Ty_Fun t1 t2 ->
    let {o = kind_check delta t1} in
    let {o0 = kind_check delta t2} in
    case o of {
     Some k ->
      case k of {
       Kind_Base ->
        case o0 of {
         Some k0 ->
          case k0 of {
           Kind_Base -> Some Kind_Base;
           Kind_Arrow _ _ -> None};
         None -> None};
       Kind_Arrow _ _ -> None};
     None -> None};
   Ty_IFix f0 t ->
    case kind_check delta t of {
     Some k ->
      case kind_check delta f0 of {
       Some k0 ->
        case k0 of {
         Kind_Base -> None;
         Kind_Arrow k1 k2 ->
          case k1 of {
           Kind_Base -> None;
           Kind_Arrow k3 k4 ->
            case k4 of {
             Kind_Base ->
              case k2 of {
               Kind_Base -> None;
               Kind_Arrow k5 k6 ->
                case k6 of {
                 Kind_Base ->
                  case andb (kind_eqb k k3) (kind_eqb k k5) of {
                   True -> Some Kind_Base;
                   False -> None};
                 Kind_Arrow _ _ -> None}};
             Kind_Arrow _ _ -> None}}};
       None -> None};
     None -> None};
   Ty_Forall x k t ->
    case kind_check (Cons (Pair x k) delta) t of {
     Some k0 ->
      case k0 of {
       Kind_Base -> Some Kind_Base;
       Kind_Arrow _ _ -> None};
     None -> None};
   Ty_Builtin d ->
    case kind_check_default_uni d of {
     Some k ->
      case k of {
       Kind_Base -> Some Kind_Base;
       Kind_Arrow _ _ -> None};
     None -> None};
   Ty_Lam x k1 t ->
    case kind_check (Cons (Pair x k1) delta) t of {
     Some k2 -> Some (Kind_Arrow k1 k2);
     None -> None};
   Ty_App t1 t2 ->
    let {o = kind_check delta t1} in
    let {o0 = kind_check delta t2} in
    case o of {
     Some k ->
      case k of {
       Kind_Base -> None;
       Kind_Arrow k11 k2 ->
        case o0 of {
         Some k12 ->
          case kind_eqb k11 k12 of {
           True -> Some k2;
           False -> None};
         None -> None}};
     None -> None};
   Ty_SOP _ -> None}

kind_checking_sound :: (List (Prod BinderTyname Kind)) -> Ty -> Kind ->
                       Has_kind
kind_checking_sound delta ty kind =
  ty_rec (\t delta0 kind0 _ -> K_Var delta0 t kind0)
    (\ty1 iHty1 ty2 iHty2 delta0 _ _ ->
    let {o = kind_check delta0 ty1} in
    case o of {
     Some k ->
      case k of {
       Kind_Base ->
        let {o0 = kind_check delta0 ty2} in
        case o0 of {
         Some k0 ->
          case k0 of {
           Kind_Base -> K_Fun delta0 ty1 ty2 (iHty1 delta0 Kind_Base __)
            (iHty2 delta0 Kind_Base __);
           Kind_Arrow _ _ -> false_rec};
         None -> false_rec};
       Kind_Arrow _ _ -> false_rec};
     None -> false_rec}) (\ty1 iHty1 ty2 iHty2 delta0 _ _ ->
    let {o = kind_check delta0 ty2} in
    case o of {
     Some k ->
      let {o0 = kind_check delta0 ty1} in
      case o0 of {
       Some k0 ->
        case k0 of {
         Kind_Base -> false_rec;
         Kind_Arrow k1 k2 ->
          case k1 of {
           Kind_Base -> false_rec;
           Kind_Arrow k3 k4 ->
            case k4 of {
             Kind_Base ->
              case k2 of {
               Kind_Base -> false_rec;
               Kind_Arrow k5 k6 ->
                case k6 of {
                 Kind_Base ->
                  let {b = andb (kind_eqb k k3) (kind_eqb k k5)} in
                  case b of {
                   True -> K_IFix delta0 ty1 ty2 k (iHty2 delta0 k __)
                    (iHty1 delta0 (Kind_Arrow (Kind_Arrow k Kind_Base)
                      (Kind_Arrow k Kind_Base)) __);
                   False -> false_rec};
                 Kind_Arrow _ _ -> false_rec}};
             Kind_Arrow _ _ -> false_rec}}};
       None -> false_rec};
     None -> false_rec}) (\b k ty0 iHty delta0 _ _ ->
    let {o = kind_check (Cons (Pair b k) delta0) ty0} in
    case o of {
     Some k0 ->
      case k0 of {
       Kind_Base -> K_Forall delta0 b k ty0
        (iHty (Cons (Pair b k) delta0) Kind_Base __);
       Kind_Arrow _ _ -> false_rec};
     None -> false_rec}) (\d delta0 _ _ ->
    let {o = kind_check_default_uni d} in
    case o of {
     Some k ->
      case k of {
       Kind_Base ->
        let {heqo = kind_checking_default_uni_sound d Kind_Base} in
        K_Builtin delta0 d heqo;
       Kind_Arrow _ _ -> false_rec};
     None -> false_rec}) (\b k ty0 iHty delta0 _ _ ->
    let {o = kind_check (Cons (Pair b k) delta0) ty0} in
    case o of {
     Some k0 -> K_Lam delta0 b k ty0 k0 (iHty (Cons (Pair b k) delta0) k0 __);
     None -> false_rec}) (\ty1 iHty1 ty2 iHty2 delta0 kind0 _ ->
    let {k1 = kind_check delta0 ty2} in
    case k1 of {
     Some k ->
      let {o = kind_check delta0 ty1} in
      case o of {
       Some k0 ->
        case k0 of {
         Kind_Base -> false_rec;
         Kind_Arrow k2 _ ->
          let {b = kind_eqb k2 k} in
          case b of {
           True -> K_App delta0 ty1 ty2 k kind0
            (iHty1 delta0 (Kind_Arrow k kind0) __) (iHty2 delta0 k __);
           False -> false_rec}};
       None -> false_rec};
     None -> false_rec}) (\_ _ _ _ -> false_rec) ty delta kind __

data Step =
   Step_beta String Kind Ty Ty
 | Step_appL Ty Ty Ty Step
 | Step_appR Ty Ty Ty Step
 | Step_funL Ty Ty Ty Step
 | Step_funR Ty Ty Ty Step
 | Step_forall BinderTyname Kind Ty Ty Step
 | Step_abs BinderTyname Kind Ty Ty Step
 | Step_ifixL Ty Ty Ty Step
 | Step_ifixR Ty Ty Ty Step
 | Step_SOP (List (List Ty)) (List Ty) Ty Ty (List Ty) (List (List Ty)) 
 (ForallSet2 Ty ()) (ForallSet Ty ()) Step

step_rect :: (String -> Kind -> Ty -> Ty -> () -> () -> a1) -> (Ty -> Ty ->
             Ty -> Step -> a1 -> a1) -> (Ty -> Ty -> Ty -> () -> Step -> a1
             -> a1) -> (Ty -> Ty -> Ty -> Step -> a1 -> a1) -> (Ty -> Ty ->
             Ty -> () -> Step -> a1 -> a1) -> (BinderTyname -> Kind -> Ty ->
             Ty -> Step -> a1 -> a1) -> (BinderTyname -> Kind -> Ty -> Ty ->
             Step -> a1 -> a1) -> (Ty -> Ty -> Ty -> Step -> a1 -> a1) -> (Ty
             -> Ty -> Ty -> () -> Step -> a1 -> a1) -> ((List (List Ty)) ->
             (List Ty) -> Ty -> Ty -> (List Ty) -> (List (List Ty)) ->
             (ForallSet2 Ty ()) -> (ForallSet Ty ()) -> Step -> a1 -> a1) ->
             Ty -> Ty -> Step -> a1
step_rect f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 _ _ s =
  case s of {
   Step_beta x k s0 t -> f0 x k s0 t __ __;
   Step_appL s1 s2 t s0 ->
    f1 s1 s2 t s0 (step_rect f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 s1 s2 s0);
   Step_appR s0 t1 t2 s1 ->
    f2 s0 t1 t2 __ s1 (step_rect f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 t1 t2 s1);
   Step_funL s1 s2 t s0 ->
    f3 s1 s2 t s0 (step_rect f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 s1 s2 s0);
   Step_funR s0 t1 t2 s1 ->
    f4 s0 t1 t2 __ s1 (step_rect f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 t1 t2 s1);
   Step_forall bX k s1 s2 s0 ->
    f5 bX k s1 s2 s0 (step_rect f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 s1 s2 s0);
   Step_abs bX k t1 t2 s0 ->
    f6 bX k t1 t2 s0 (step_rect f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 t1 t2 s0);
   Step_ifixL f10 f11 t s0 ->
    f7 f10 f11 t s0 (step_rect f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 s0);
   Step_ifixR f10 t1 t2 s0 ->
    f8 f10 t1 t2 __ s0 (step_rect f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 t1 t2 s0);
   Step_SOP tss_normal tss_sub_normal tss_sub1 tss_sub2 tss_sub_remainder
    tss_remainder f10 f11 s0 ->
    f9 tss_normal tss_sub_normal tss_sub1 tss_sub2 tss_sub_remainder
      tss_remainder f10 f11 s0
      (step_rect f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 tss_sub1 tss_sub2 s0)}

step_rec :: (String -> Kind -> Ty -> Ty -> () -> () -> a1) -> (Ty -> Ty -> Ty
            -> Step -> a1 -> a1) -> (Ty -> Ty -> Ty -> () -> Step -> a1 ->
            a1) -> (Ty -> Ty -> Ty -> Step -> a1 -> a1) -> (Ty -> Ty -> Ty ->
            () -> Step -> a1 -> a1) -> (BinderTyname -> Kind -> Ty -> Ty ->
            Step -> a1 -> a1) -> (BinderTyname -> Kind -> Ty -> Ty -> Step ->
            a1 -> a1) -> (Ty -> Ty -> Ty -> Step -> a1 -> a1) -> (Ty -> Ty ->
            Ty -> () -> Step -> a1 -> a1) -> ((List (List Ty)) -> (List 
            Ty) -> Ty -> Ty -> (List Ty) -> (List (List Ty)) -> (ForallSet2
            Ty ()) -> (ForallSet Ty ()) -> Step -> a1 -> a1) -> Ty -> Ty ->
            Step -> a1
step_rec =
  step_rect

bind :: (Option a1) -> (a1 -> Option a2) -> Option a2
bind xx f0 =
  case xx of {
   Some a -> f0 a;
   None -> None}

solution_left :: a1 -> a2 -> a1 -> a2
solution_left _ x _ =
  x

solution_right :: a1 -> a2 -> a1 -> a2
solution_right _ x _ =
  x

substituteTCA_preserves_kinding :: Ty -> (List (Prod BinderName Kind)) ->
                                   BinderName -> Kind -> Ty -> Kind ->
                                   Has_kind -> Has_kind -> Has_kind
substituteTCA_preserves_kinding =
  Prelude.error "AXIOM TO BE REALIZED"

data AlphaVar =
   Alpha_var_refl String
 | Alpha_var_cons String String (List (Prod String String))
 | Alpha_var_diff String String String String (List (Prod String String)) 
 AlphaVar

alphaVar_rect :: (String -> a1) -> (String -> String -> (List
                 (Prod String String)) -> a1) -> (String -> String -> String
                 -> String -> (List (Prod String String)) -> () -> () ->
                 AlphaVar -> a1 -> a1) -> (List (Prod String String)) ->
                 String -> String -> AlphaVar -> a1
alphaVar_rect f0 f1 f2 _ _ _ a =
  case a of {
   Alpha_var_refl x -> f0 x;
   Alpha_var_cons z w sigma -> f1 z w sigma;
   Alpha_var_diff x y z w sigma a0 ->
    f2 x y z w sigma __ __ a0 (alphaVar_rect f0 f1 f2 sigma z w a0)}

alphaVar_rec :: (String -> a1) -> (String -> String -> (List
                (Prod String String)) -> a1) -> (String -> String -> String
                -> String -> (List (Prod String String)) -> () -> () ->
                AlphaVar -> a1 -> a1) -> (List (Prod String String)) ->
                String -> String -> AlphaVar -> a1
alphaVar_rec =
  alphaVar_rect

data Alpha =
   Alpha_var String String (List (Prod String String)) AlphaVar
 | Alpha_lam USort String String Kind Term0 Term0 (List (Prod String String)) 
 Alpha
 | Alpha_app BSort Term0 Term0 Term0 Term0 (List (Prod String String)) 
 Alpha Alpha
 | Alpha_builtin (List (Prod String String)) DefaultUni

alpha_rect :: (String -> String -> (List (Prod String String)) -> AlphaVar ->
              a1) -> (USort -> String -> String -> Kind -> Term0 -> Term0 ->
              (List (Prod String String)) -> Alpha -> a1 -> a1) -> (BSort ->
              Term0 -> Term0 -> Term0 -> Term0 -> (List (Prod String String))
              -> Alpha -> a1 -> Alpha -> a1 -> a1) -> ((List
              (Prod String String)) -> DefaultUni -> a1) -> (List
              (Prod String String)) -> Term0 -> Term0 -> Alpha -> a1
alpha_rect f0 f1 f2 f3 _ _ _ a =
  case a of {
   Alpha_var x y sigma a0 -> f0 x y sigma a0;
   Alpha_lam b x y a0 s1 s2 sigma a1 ->
    f1 b x y a0 s1 s2 sigma a1
      (alpha_rect f0 f1 f2 f3 (Cons (Pair x y) sigma) s1 s2 a1);
   Alpha_app b s1 s2 t1 t2 sigma a0 a1 ->
    f2 b s1 s2 t1 t2 sigma a0 (alpha_rect f0 f1 f2 f3 sigma s1 s2 a0) a1
      (alpha_rect f0 f1 f2 f3 sigma t1 t2 a1);
   Alpha_builtin r d -> f3 r d}

alpha_rec :: (String -> String -> (List (Prod String String)) -> AlphaVar ->
             a1) -> (USort -> String -> String -> Kind -> Term0 -> Term0 ->
             (List (Prod String String)) -> Alpha -> a1 -> a1) -> (BSort ->
             Term0 -> Term0 -> Term0 -> Term0 -> (List (Prod String String))
             -> Alpha -> a1 -> Alpha -> a1 -> a1) -> ((List
             (Prod String String)) -> DefaultUni -> a1) -> (List
             (Prod String String)) -> Term0 -> Term0 -> Alpha -> a1
alpha_rec =
  alpha_rect

data AlphaCtxRefl =
   Alpha_refl_nil
 | Alpha_refl_cons String (List (Prod String String)) AlphaCtxRefl

alphaCtxRefl_rect :: a1 -> (String -> (List (Prod String String)) ->
                     AlphaCtxRefl -> a1 -> a1) -> (List (Prod String String))
                     -> AlphaCtxRefl -> a1
alphaCtxRefl_rect f0 f1 _ a =
  case a of {
   Alpha_refl_nil -> f0;
   Alpha_refl_cons x ren a0 -> f1 x ren a0 (alphaCtxRefl_rect f0 f1 ren a0)}

alphaCtxRefl_rec :: a1 -> (String -> (List (Prod String String)) ->
                    AlphaCtxRefl -> a1 -> a1) -> (List (Prod String String))
                    -> AlphaCtxRefl -> a1
alphaCtxRefl_rec =
  alphaCtxRefl_rect

alphavar_refl :: String -> (List (Prod String String)) -> AlphaCtxRefl ->
                 AlphaVar
alphavar_refl s ren halphactx =
  alphaCtxRefl_rec (Alpha_var_refl s) (\x ren0 _ iHHalphactx ->
    let {b = eqb1 x s} in
    case b of {
     True -> eq_rec_r s (Alpha_var_cons s s ren0) x;
     False -> Alpha_var_diff x x s s ren0 iHHalphactx}) ren halphactx

alpha_refl :: Term0 -> (List (Prod String String)) -> AlphaCtxRefl -> Alpha
alpha_refl s ren =
  term_rec (\s0 ren0 hid -> Alpha_var s0 s0 ren0 (alphavar_refl s0 ren0 hid))
    (\uSort s0 k s1 iHs ren0 hid -> Alpha_lam uSort s0 s0 k s1 s1 ren0
    (iHs (Cons (Pair s0 s0) ren0) (Alpha_refl_cons s0 ren0 hid)))
    (\bSort s1 iHs1 s2 iHs2 ren0 hid -> Alpha_app bSort s1 s1 s2 s2 ren0
    (iHs1 ren0 hid) (iHs2 ren0 hid)) (\d ren0 _ -> Alpha_builtin ren0 d) s
    ren

data AlphaCtxSym =
   Alpha_sym_nil
 | Alpha_sym_cons String String (List (Prod String String)) (List
                                                            (Prod String
                                                            String)) 
 AlphaCtxSym

alphaCtxSym_rect :: a1 -> (String -> String -> (List (Prod String String)) ->
                    (List (Prod String String)) -> AlphaCtxSym -> a1 -> a1)
                    -> (List (Prod String String)) -> (List
                    (Prod String String)) -> AlphaCtxSym -> a1
alphaCtxSym_rect f0 f1 _ _ a =
  case a of {
   Alpha_sym_nil -> f0;
   Alpha_sym_cons x y ren ren' a0 ->
    f1 x y ren ren' a0 (alphaCtxSym_rect f0 f1 ren ren' a0)}

alphaCtxSym_rec :: a1 -> (String -> String -> (List (Prod String String)) ->
                   (List (Prod String String)) -> AlphaCtxSym -> a1 -> a1) ->
                   (List (Prod String String)) -> (List (Prod String String))
                   -> AlphaCtxSym -> a1
alphaCtxSym_rec =
  alphaCtxSym_rect

alpha_sym :: Term0 -> Term0 -> (List (Prod String String)) -> (List
             (Prod String String)) -> AlphaCtxSym -> Alpha -> Alpha
alpha_sym s t ren ren' hsym halpha =
  alpha_rec (\x y sigma a ren'0 hsym0 -> Alpha_var y x ren'0
    (alphaCtxSym_rec (\y0 x0 a0 ->
      case a0 of {
       Alpha_var_refl x1 ->
        eq_rec_r x0 (\_ -> eq_rec_r y0 (Alpha_var_refl y0) x0) x1 __;
       Alpha_var_cons _ _ _ -> false_rec __ __;
       Alpha_var_diff _ _ _ _ _ x1 -> false_rec __ __ __ __ x1})
      (\x0 y0 ren0 ren'1 _ iHHsym y1 x1 a0 ->
      case a0 of {
       Alpha_var_refl _ -> false_rec __ __;
       Alpha_var_cons z w sigma0 ->
        eq_rec_r x0 (\_ ->
          eq_rec_r y0 (\_ ->
            eq_rec_r ren0 (\_ ->
              eq_rec_r x1 (\_ ->
                eq_rec_r y1
                  (eq_rec_r x1 (\a1 ->
                    eq_rec_r y1 (\_ -> Alpha_var_cons y1 x1 ren'1) y0 a1) x0
                    a0) y0) x0) sigma0) w) z __ __ __ __;
       Alpha_var_diff x2 y2 z w sigma0 x3 ->
        eq_rec_r x0 (\_ ->
          eq_rec_r y0 (\_ ->
            eq_rec_r ren0 (\_ ->
              eq_rec_r x1 (\_ ->
                eq_rec_r y1 (\_ _ h6 -> Alpha_var_diff y0 x0 y1 x1 ren'1
                  (iHHsym y1 x1 h6)) w) z) sigma0) y2) x2 __ __ __ __ __ __
          x3}) sigma ren'0 hsym0 y x a))
    (\b x y a s1 s2 sigma _ iHHalpha ren'0 hsym0 -> Alpha_lam b y x a s2 s1
    ren'0
    (iHHalpha (Cons (Pair y x) ren'0) (Alpha_sym_cons x y sigma ren'0 hsym0)))
    (\b s1 s2 t1 t2 _ _ iHHalpha1 _ iHHalpha2 ren'0 hsym0 -> Alpha_app b s2
    s1 t2 t1 ren'0 (iHHalpha1 ren'0 hsym0) (iHHalpha2 ren'0 hsym0))
    (\_ d ren'0 _ -> Alpha_builtin ren'0 d) ren s t halpha ren' hsym

data Coq__UU03b1_CtxTrans =
   Alpha_trans_nil
 | Alpha_trans_cons String String String (List (Prod String String)) 
 (List (Prod String String)) (List (Prod String String)) Coq__UU03b1_CtxTrans

_UU03b1_CtxTrans_rect :: a1 -> (String -> String -> String -> (List
                         (Prod String String)) -> (List (Prod String String))
                         -> (List (Prod String String)) ->
                         Coq__UU03b1_CtxTrans -> a1 -> a1) -> (List
                         (Prod String String)) -> (List (Prod String String))
                         -> (List (Prod String String)) ->
                         Coq__UU03b1_CtxTrans -> a1
_UU03b1_CtxTrans_rect f0 f1 _ _ _ _UU03b1_ =
  case _UU03b1_ of {
   Alpha_trans_nil -> f0;
   Alpha_trans_cons x y z ren ren' ren'' _UU03b1_0 ->
    f1 x y z ren ren' ren'' _UU03b1_0
      (_UU03b1_CtxTrans_rect f0 f1 ren ren' ren'' _UU03b1_0)}

_UU03b1_CtxTrans_rec :: a1 -> (String -> String -> String -> (List
                        (Prod String String)) -> (List (Prod String String))
                        -> (List (Prod String String)) ->
                        Coq__UU03b1_CtxTrans -> a1 -> a1) -> (List
                        (Prod String String)) -> (List (Prod String String))
                        -> (List (Prod String String)) ->
                        Coq__UU03b1_CtxTrans -> a1
_UU03b1_CtxTrans_rec =
  _UU03b1_CtxTrans_rect

alpha_trans :: Term0 -> Term0 -> Term0 -> (List (Prod String String)) ->
               (List (Prod String String)) -> (List (Prod String String)) ->
               Coq__UU03b1_CtxTrans -> Alpha -> Alpha -> Alpha
alpha_trans s t u ren ren' ren'' htrans halpha1 halpha2 =
  alpha_rec (\x y sigma a _ ren''0 ren'0 htrans0 halpha3 ->
    case halpha3 of {
     Alpha_var x0 y0 sigma0 x1 ->
      eq_rec_r ren'0 (\_ ->
        eq_rec_r y (\_ h1 -> Alpha_var x y0 ren''0
          (_UU03b1_CtxTrans_rec (\a0 halpha4 h2 ->
            case h2 of {
             Alpha_var_refl x2 ->
              eq_rec_r y (\_ ->
                eq_rec_r y0 (eq_rec_r y0 (\a1 _ _ -> a1) y a0 halpha4 h2) y)
                x2 __;
             Alpha_var_cons _ _ _ -> false_rec __ __;
             Alpha_var_diff _ _ _ _ _ x2 -> false_rec __ __ __ __ x2})
            (\x2 y1 z ren0 ren'1 ren''1 _ iHHtrans a0 halpha4 h2 ->
            case h2 of {
             Alpha_var_refl _ -> false_rec __ __;
             Alpha_var_cons z0 w sigma1 ->
              eq_rec_r y1 (\_ ->
                eq_rec_r z (\_ ->
                  eq_rec_r ren'1 (\_ ->
                    eq_rec_r y (\_ ->
                      eq_rec_r y0
                        (eq_rec_r y (\a1 halpha5 h3 ->
                          eq_rec_r y0 (\_ _ ->
                            case a1 of {
                             Alpha_var_refl _ -> false_rec __ __;
                             Alpha_var_cons z1 w0 sigma2 ->
                              eq_rec_r x2 (\_ ->
                                eq_rec_r y (\_ ->
                                  eq_rec_r ren0 (\_ ->
                                    eq_rec_r x (\_ ->
                                      eq_rec_r y
                                        (eq_rec_r x (\_ -> Alpha_var_cons x
                                          y0 ren''1) x2 a1) y) x2) sigma2) w0)
                                z1 __ __ __ __;
                             Alpha_var_diff x3 y2 z1 w0 sigma2 x4 ->
                              eq_rec_r x2 (\_ ->
                                eq_rec_r y (\_ ->
                                  eq_rec_r ren0 (\_ ->
                                    eq_rec_r x (\_ ->
                                      eq_rec_r y (\_ _ _ -> false_rec) w0) z1)
                                    sigma2) y2) x3 __ __ __ __ __ __ x4}) z
                            h3 halpha5) y1 a0 halpha4 h2) z) y1) sigma1) w)
                z0 __ __ __ __;
             Alpha_var_diff x3 y2 z0 w sigma1 x4 ->
              eq_rec_r y1 (\_ ->
                eq_rec_r z (\_ ->
                  eq_rec_r ren'1 (\_ ->
                    eq_rec_r y (\_ ->
                      eq_rec_r y0 (\_ _ h7 -> Alpha_var_diff x2 z x y0 ren''1
                        (iHHtrans
                          (case a0 of {
                            Alpha_var_refl _ -> false_rec __ __;
                            Alpha_var_cons z1 w0 sigma2 ->
                             eq_rec_r x2 (\_ ->
                               eq_rec_r y1 (\_ ->
                                 eq_rec_r ren0 (\_ ->
                                   eq_rec_r x (\_ -> eq_rec_r y false_rec y1)
                                     x2) sigma2) w0) z1 __ __ __ __;
                            Alpha_var_diff x5 y3 z1 w0 sigma2 x6 ->
                             eq_rec_r x2 (\_ ->
                               eq_rec_r y1 (\_ ->
                                 eq_rec_r ren0 (\_ ->
                                   eq_rec_r x (\_ ->
                                     eq_rec_r y (\_ _ h10 -> h10) w0) z1)
                                   sigma2) y3) x5 __ __ __ __ __ __ x6})
                          (Alpha_var y y0 ren'1 h7) h7)) w) z0) sigma1) y2)
                x3 __ __ __ __ __ __ x4}) sigma ren'0 ren''0 htrans0 a
            halpha3 h1)) x0) sigma0 __ __ x1;
     Alpha_lam _ _ _ _ _ _ sigma0 x0 ->
      eq_rec_r ren'0 (\_ -> false_rec) sigma0 __ __ x0;
     Alpha_app _ _ _ _ _ sigma0 x0 x1 ->
      eq_rec_r ren'0 (\_ -> false_rec) sigma0 __ __ x0 x1;
     Alpha_builtin r _ -> eq_rec_r ren'0 (\_ -> false_rec) r __ __})
    (\b x y a s1 s2 sigma _ iHHalpha1 _ ren''0 ren'0 htrans0 halpha3 ->
    case halpha3 of {
     Alpha_var _ _ sigma0 x0 ->
      eq_rec_r ren'0 (\_ -> false_rec) sigma0 __ __ x0;
     Alpha_lam b0 x0 y0 a0 s3 s4 sigma0 x1 ->
      eq_rec_r ren'0 (\_ ->
        eq_rec_r b (\_ ->
          eq_rec_r y (\_ ->
            eq_rec_r a (\_ ->
              eq_rec_r s2 (\_ _ -> Alpha_lam b x y0 a s1 s4 ren''0
                (iHHalpha1 s4 (Cons (Pair x y0) ren''0) (Cons (Pair y y0)
                  ren'0) (Alpha_trans_cons x y y0 sigma ren'0 ren''0 htrans0)
                  (case halpha3 of {
                    Alpha_var _ _ sigma1 x2 ->
                     eq_rec_r ren'0 (\_ -> false_rec) sigma1 __ __ x2;
                    Alpha_lam b1 x2 y1 a1 s5 s6 sigma1 x3 ->
                     eq_rec_r ren'0 (\_ ->
                       eq_rec_r b (\_ ->
                         eq_rec_r y (\_ ->
                           eq_rec_r a (\_ ->
                             eq_rec_r s2 (\_ ->
                               eq_rec_r y0 (\_ -> eq_rec_r s4 (\h1 -> h1) s6)
                                 y1 __) s5) a1) x2) b1 __ __ __) sigma1 __ __
                       x3;
                    Alpha_app _ _ _ _ _ sigma1 x2 x3 ->
                     eq_rec_r ren'0 (\_ -> false_rec) sigma1 __ __ x2 x3;
                    Alpha_builtin r _ ->
                     eq_rec_r ren'0 (\_ -> false_rec) r __ __}))) s3) a0) x0)
          b0 __ __ __) sigma0 __ __ x1;
     Alpha_app _ _ _ _ _ sigma0 x0 x1 ->
      eq_rec_r ren'0 (\_ -> false_rec) sigma0 __ __ x0 x1;
     Alpha_builtin r _ -> eq_rec_r ren'0 (\_ -> false_rec) r __ __})
    (\b s1 s2 t1 t2 _ _ iHHalpha1_1 _ iHHalpha1_2 _ ren''0 ren'0 htrans0 halpha3 ->
    case halpha3 of {
     Alpha_var _ _ sigma x -> eq_rec_r ren'0 (\_ -> false_rec) sigma __ __ x;
     Alpha_lam _ _ _ _ _ _ sigma x ->
      eq_rec_r ren'0 (\_ -> false_rec) sigma __ __ x;
     Alpha_app b0 s3 s4 t3 t4 sigma x x0 ->
      eq_rec_r ren'0 (\_ ->
        eq_rec_r b (\_ ->
          eq_rec_r s2 (\_ ->
            eq_rec_r t2 (\_ h4 h5 -> Alpha_app b s1 s4 t1 t4 ren''0
              (iHHalpha1_1 s4 ren''0 ren'0 htrans0 h4)
              (iHHalpha1_2 t4 ren''0 ren'0 htrans0 h5)) t3) s3) b0 __ __)
        sigma __ __ x x0;
     Alpha_builtin r _ -> eq_rec_r ren'0 (\_ -> false_rec) r __ __})
    (\_ d _ ren''0 ren'0 _ halpha3 ->
    case halpha3 of {
     Alpha_var _ _ sigma x -> eq_rec_r ren'0 (\_ -> false_rec) sigma __ __ x;
     Alpha_lam _ _ _ _ _ _ sigma x ->
      eq_rec_r ren'0 (\_ -> false_rec) sigma __ __ x;
     Alpha_app _ _ _ _ _ sigma x x0 ->
      eq_rec_r ren'0 (\_ -> false_rec) sigma __ __ x x0;
     Alpha_builtin r d0 ->
      eq_rec_r ren'0 (\_ -> eq_rec_r d (\_ -> Alpha_builtin ren''0 d) d0) r
        __ __}) ren s t halpha1 u ren'' ren' htrans halpha2

alpha_var_trans :: String -> String -> String -> (List (Prod String String))
                   -> (List (Prod String String)) -> (List
                   (Prod String String)) -> Coq__UU03b1_CtxTrans -> AlphaVar
                   -> AlphaVar -> AlphaVar
alpha_var_trans s t u ren ren' ren'' htrans halpha1 halpha2 =
  let {
   h = alpha_trans (Tmvar s) (Tmvar t) (Tmvar u) ren ren' ren'' htrans
         (Alpha_var s t ren halpha1) (Alpha_var t u ren' halpha2)}
  in
  case h of {
   Alpha_var x y sigma x0 ->
    eq_rec_r ren'' (\_ -> eq_rec_r s (\_ -> eq_rec_r u (\h3 -> h3) y) x)
      sigma __ __ x0;
   Alpha_lam _ _ _ _ _ _ sigma x ->
    eq_rec_r ren'' (\_ -> false_rec) sigma __ __ x;
   Alpha_app _ _ _ _ _ sigma x x0 ->
    eq_rec_r ren'' (\_ -> false_rec) sigma __ __ x x0;
   Alpha_builtin r _ -> eq_rec_r ren'' (\_ -> false_rec) r __ __}

sym_alpha_ctx :: (List (Prod String String)) -> List (Prod String String)
sym_alpha_ctx ren =
  case ren of {
   Nil -> Nil;
   Cons p ren' ->
    case p of {
     Pair x y -> Cons (Pair y x) (sym_alpha_ctx ren')}}

sym_alpha_ctx_is_sym :: (List (Prod String String)) -> AlphaCtxSym
sym_alpha_ctx_is_sym ren =
  list_rec Alpha_sym_nil (\a ren0 iHren ->
    case a of {
     Pair s s0 -> Alpha_sym_cons s s0 ren0 (sym_alpha_ctx ren0) iHren}) ren

sym_alpha_ctx_left_is_sym :: (List (Prod String String)) -> AlphaCtxSym
sym_alpha_ctx_left_is_sym ren =
  list_rec Alpha_sym_nil (\a ren0 iHren ->
    case a of {
     Pair s s0 -> Alpha_sym_cons s0 s (sym_alpha_ctx ren0) ren0 iHren}) ren

data IdCtx =
   Id_ctx_nil
 | Id_ctx_cons String (List (Prod String String)) IdCtx

idCtx_rect :: a1 -> (String -> (List (Prod String String)) -> IdCtx -> a1 ->
              a1) -> (List (Prod String String)) -> IdCtx -> a1
idCtx_rect f0 f1 _ i =
  case i of {
   Id_ctx_nil -> f0;
   Id_ctx_cons x ren i0 -> f1 x ren i0 (idCtx_rect f0 f1 ren i0)}

idCtx_rec :: a1 -> (String -> (List (Prod String String)) -> IdCtx -> a1 ->
             a1) -> (List (Prod String String)) -> IdCtx -> a1
idCtx_rec =
  idCtx_rect

data NotBreakShadowing =
   Not_break_shadow_nil String
 | Not_break_shadow_cons String String String (List (Prod String String)) 
 NotBreakShadowing
 | Not_break_shadow_id String (List (Prod String String))

idCtxNotBreakShadowing :: String -> (List (Prod String String)) -> IdCtx ->
                          NotBreakShadowing
idCtxNotBreakShadowing x ren hid =
  list_rec (\_ -> Not_break_shadow_nil x) (\a ren0 iHren hid0 ->
    case a of {
     Pair s s0 ->
      eq_rec_r s0 (\hid1 ->
        let {b = eqb1 x s0} in
        case b of {
         True -> eq_rec_r s0 (\_ -> Not_break_shadow_id s0 ren0) x iHren;
         False -> Not_break_shadow_cons x s0 s0 ren0
          (case hid1 of {
            Id_ctx_nil -> false_rec;
            Id_ctx_cons x0 ren1 x1 ->
             eq_rec_r s0 (\_ ->
               eq_rec_r s0 (\_ -> eq_rec_r ren0 iHren ren1) s0) x0 __ __ x1})})
        s hid0}) ren hid

data LegalRenSwap =
   Lrs_nil
 | Lrs_cons String String (List (Prod String String)) (List
                                                      (Prod String String)) 
 LegalRenSwap
 | Lrs_start String String String String (List (Prod String String)) 
 (List (Prod String String)) LegalRenSwap

legalRenSwap_rect :: a1 -> (String -> String -> (List (Prod String String))
                     -> (List (Prod String String)) -> LegalRenSwap -> a1 ->
                     a1) -> (String -> String -> String -> String -> (List
                     (Prod String String)) -> (List (Prod String String)) ->
                     () -> () -> LegalRenSwap -> a1 -> a1) -> (List
                     (Prod String String)) -> (List (Prod String String)) ->
                     LegalRenSwap -> a1
legalRenSwap_rect f0 f1 f2 _ _ l1 =
  case l1 of {
   Lrs_nil -> f0;
   Lrs_cons x y ren1 ren1' l ->
    f1 x y ren1 ren1' l (legalRenSwap_rect f0 f1 f2 ren1 ren1' l);
   Lrs_start x y v w ren1 ren1' l ->
    f2 x y v w ren1 ren1' __ __ l (legalRenSwap_rect f0 f1 f2 ren1 ren1' l)}

legalRenSwap_rec :: a1 -> (String -> String -> (List (Prod String String)) ->
                    (List (Prod String String)) -> LegalRenSwap -> a1 -> a1)
                    -> (String -> String -> String -> String -> (List
                    (Prod String String)) -> (List (Prod String String)) ->
                    () -> () -> LegalRenSwap -> a1 -> a1) -> (List
                    (Prod String String)) -> (List (Prod String String)) ->
                    LegalRenSwap -> a1
legalRenSwap_rec =
  legalRenSwap_rect

legalRenSwap_id :: (List (Prod String String)) -> LegalRenSwap
legalRenSwap_id ren =
  list_rec Lrs_nil (\a ren0 iHren ->
    case a of {
     Pair s s0 -> Lrs_cons s s0 ren0 ren0 iHren}) ren

lrs_trans :: (List (Prod String String)) -> (List (Prod String String)) ->
             (List (Prod String String)) -> LegalRenSwap -> LegalRenSwap ->
             LegalRenSwap
lrs_trans =
  Prelude.error "AXIOM TO BE REALIZED"

lrs_sym :: (List (Prod String String)) -> (List (Prod String String)) ->
           LegalRenSwap -> LegalRenSwap
lrs_sym =
  Prelude.error "AXIOM TO BE REALIZED"

alphavar_weaken :: String -> String -> (List (Prod String String)) -> String
                   -> String -> AlphaVar -> AlphaVar
alphavar_weaken v w ren s t halpha =
  case halpha of {
   Alpha_var_refl _ -> false_rec __ __;
   Alpha_var_cons z w0 sigma ->
    eq_rec_r v (\_ ->
      eq_rec_r w (\_ ->
        eq_rec_r ren (\_ ->
          eq_rec_r s (\_ ->
            eq_rec_r t
              (eq_rec_r s (\_ halpha0 ->
                eq_rec_r t (\_ _ -> false_rec) w __ halpha0) v __ halpha) w)
            v) sigma) w0) z __ __ __ __;
   Alpha_var_diff x y z w0 sigma x0 ->
    eq_rec_r v (\_ ->
      eq_rec_r w (\_ ->
        eq_rec_r ren (\_ ->
          eq_rec_r s (\_ -> eq_rec_r t (\_ _ h6 -> h6) w0) z) sigma) y) x __
      __ __ __ __ __ x0}

alphavar_swap :: String -> String -> (List (Prod String String)) -> (List
                 (Prod String String)) -> LegalRenSwap -> AlphaVar ->
                 AlphaVar
alphavar_swap s t ren ren' hswap halpha =
  alphaVar_rec (\x _ hswap0 ->
    case hswap0 of {
     Lrs_nil -> Alpha_var_refl x;
     Lrs_cons _ _ _ _ x0 -> false_rec __ x0;
     Lrs_start _ _ _ _ _ _ x0 -> false_rec __ __ __ x0})
    (\z w sigma _ hswap0 ->
    case hswap0 of {
     Lrs_nil -> false_rec __;
     Lrs_cons x y ren1 ren1' x0 ->
      eq_rec_r z (\_ ->
        eq_rec_r w (\_ ->
          eq_rec_r sigma (\_ _ -> Alpha_var_cons z w ren1') ren1) y) x __ __
        __ x0;
     Lrs_start x y v w0 _ ren1' x0 ->
      eq_rec_r z (\_ ->
        eq_rec_r w (\_ _ _ _ _ -> Alpha_var_diff v w0 z w (Cons (Pair z w)
          ren1') (Alpha_var_cons z w ren1')) y) x __ __ __ __ __ x0})
    (\x y z w sigma _ _ halpha0 iHHalpha ren'0 hswap0 ->
    let {gen_x = Cons (Pair x y) sigma} in
    legalRenSwap_rec (\_ _ _ _ _ _ _ _ -> false_rec)
      (\x0 y0 ren1 ren1' hswap1 iHHswap x1 y1 sigma0 _ _ halpha1 iHHalpha0 _ ->
      solution_left sigma0
        (\ren1'0 hswap2 iHHswap0 x2 y2 _ _ halpha2 iHHalpha1 _ ->
        solution_left y2
          (\sigma1 ren1'1 hswap3 iHHswap1 x3 _ _ halpha3 iHHalpha2 _ ->
          solution_left x3 (\y3 _ ren1'2 hswap4 _ _ _ _ iHHalpha3 ->
            Alpha_var_diff x3 y3 z w ren1'2 (iHHalpha3 ren1'2 hswap4)) x0 y2
            sigma1 ren1'1 hswap3 iHHswap1 __ __ halpha3 iHHalpha2) y0 sigma0
          ren1'0 hswap2 iHHswap0 x2 __ __ halpha2 iHHalpha1) ren1 ren1'
        hswap1 iHHswap x1 y1 __ __ halpha1 iHHalpha0 __ __)
      (\x0 y0 v w0 ren1 ren1' _ _ hswap1 iHHswap x1 y1 sigma0 _ _ halpha1 iHHalpha0 _ ->
      solution_right (Cons (Pair v w0) ren1) (\_ _ halpha2 iHHalpha1 _ ->
        solution_left y1
          (\v0 w1 ren2 ren1'0 _ _ hswap2 iHHswap0 x2 _ _ halpha3 iHHalpha2 _ ->
          solution_left x2
            (\y2 v1 w2 ren3 ren1'1 _ _ hswap3 _ _ _ halpha4 iHHalpha3 ->
            let {b = eqb1 v1 z} in
            case b of {
             True ->
              eq_rec_r z (\_ halpha5 iHHalpha4 _ ->
                eq_rec_r w (\_ _ _ -> Alpha_var_cons z w (Cons (Pair x2 y2)
                  ren1'1)) w2 __ iHHalpha4 halpha5) v1 __ halpha4 iHHalpha3
                __;
             False -> Alpha_var_diff v1 w2 z w (Cons (Pair x2 y2) ren1'1)
              (Alpha_var_diff x2 y2 z w ren1'1
              (let {
                iHHalpha4 = iHHalpha3 (Cons (Pair v1 w2) ren1'1) (Lrs_cons v1
                              w2 ren3 ren1'1 hswap3)}
               in
               alphavar_weaken v1 w2 ren1'1 z w iHHalpha4))}) x0 y1 v0 w1
            ren2 ren1'0 __ __ hswap2 iHHswap0 __ __ halpha3 iHHalpha2) y0 v
          w0 ren1 ren1' __ __ hswap1 iHHswap x1 __ __ halpha2 iHHalpha1)
        sigma0 __ __ halpha1 iHHalpha0 __ __) gen_x ren'0 hswap0 x y sigma __
      __ halpha0 iHHalpha __) ren s t halpha ren' hswap

alpha_swap :: Term0 -> Term0 -> (List (Prod String String)) -> (List
              (Prod String String)) -> LegalRenSwap -> Alpha -> Alpha
alpha_swap s t ren' ren hswap halpha =
  alpha_rec (\x y sigma a ren'0 lrs -> Alpha_var x y ren'0
    (alphavar_swap x y sigma ren'0 lrs a))
    (\b x y a s1 s2 sigma _ iHHalpha ren'0 lrs -> Alpha_lam b x y a s1 s2
    ren'0
    (let {hlrs_xy = Lrs_cons x y sigma ren'0 lrs} in
     iHHalpha (Cons (Pair x y) ren'0) hlrs_xy))
    (\b s1 s2 t1 t2 _ _ iHHalpha1 _ iHHalpha2 ren'0 lrs -> Alpha_app b s1 s2
    t1 t2 ren'0 (iHHalpha1 ren'0 lrs) (iHHalpha2 ren'0 lrs)) (\_ d ren'0 _ ->
    Alpha_builtin ren'0 d) ren s t halpha ren' hswap

ctx_id_left :: (List (Prod String String)) -> List (Prod String String)
ctx_id_left ren =
  case ren of {
   Nil -> Nil;
   Cons p ren' -> case p of {
                   Pair x _ -> Cons (Pair x x) (ctx_id_left ren')}}

ctx_id_right :: (List (Prod String String)) -> List (Prod String String)
ctx_id_right ren =
  case ren of {
   Nil -> Nil;
   Cons p ren' ->
    case p of {
     Pair _ y -> Cons (Pair y y) (ctx_id_right ren')}}

ctx_id_left_is_id :: (List (Prod String String)) -> IdCtx
ctx_id_left_is_id ren =
  list_rec Id_ctx_nil (\a ren0 iHren ->
    case a of {
     Pair s _ -> Id_ctx_cons s (ctx_id_left ren0) iHren}) ren

ctx_id_right_is_id :: (List (Prod String String)) -> IdCtx
ctx_id_right_is_id ren =
  list_rec Id_ctx_nil (\a ren0 iHren ->
    case a of {
     Pair _ s -> Id_ctx_cons s (ctx_id_right ren0) iHren}) ren

id_left_trans :: (List (Prod String String)) -> Coq__UU03b1_CtxTrans
id_left_trans ren =
  list_rec Alpha_trans_nil (\a ren0 iHren ->
    case a of {
     Pair s s0 -> Alpha_trans_cons s s s0 (ctx_id_left ren0) ren0 ren0 iHren})
    ren

id_right_trans :: (List (Prod String String)) -> Coq__UU03b1_CtxTrans
id_right_trans ren =
  list_rec Alpha_trans_nil (\a ren0 iHren ->
    case a of {
     Pair s s0 -> Alpha_trans_cons s s0 s0 ren0 (ctx_id_right ren0) ren0
      iHren}) ren

cons_split_helper :: String -> String -> (List (Prod String String)) -> (List
                     (Prod String String)) -> (List (Prod String String)) ->
                     Sum (SigT (List (Prod String String)) ()) ()
cons_split_helper _ _ ren1 ren2 sigma =
  case ren1 of {
   Nil -> Inr __;
   Cons _ l ->
    eq_rec_r (app l ren2)
      (eq_rec_r (app l ren2) (\_ -> Inl (ExistT l __)) sigma __) sigma}

shadow_helper_not_break :: String -> String -> String -> (List
                           (Prod String String)) -> NotBreakShadowing -> Sum
                           () ()
shadow_helper_not_break z x y ren hshadow =
  case hshadow of {
   Not_break_shadow_nil x0 -> eq_rec_r z (\_ -> false_rec) x0 __;
   Not_break_shadow_cons z0 x0 x' ren0 x1 ->
    eq_rec_r z (\_ ->
      eq_rec_r x (\_ ->
        eq_rec_r y (\_ -> eq_rec_r ren (\_ _ _ -> Inr __) ren0) x') x0 __ __)
      z0 __ __ __ x1;
   Not_break_shadow_id z0 ren0 ->
    eq_rec_r z (\_ ->
      eq_rec_r x (\_ ->
        eq_rec_r y (\_ ->
          eq_rec_r ren
            (eq_rec_r x (\hshadow0 -> eq_rec_r y (\_ -> Inl __) x hshadow0) z
              hshadow) ren0) x) z __ __) z0 __}

alphavar_extend_id_split :: String -> String -> String -> (List
                            (Prod String String)) -> AlphaVar -> (List
                            (Prod String String)) -> (List
                            (Prod String String)) -> NotBreakShadowing ->
                            AlphaVar
alphavar_extend_id_split x y z ren halpha ren1 ren2 x0 =
  alphaVar_rec (\x1 ren3 ren4 _ hshadow ->
    eq_rec_r Nil (\_ ->
      eq_rec_r Nil (\_ _ ->
        let {
         _evar_0_ = let {
                     _evar_0_ = let {b = eqb1 x1 z} in
                                case b of {
                                 True ->
                                  eq_rec_r z (Alpha_var_cons z z Nil) x1;
                                 False -> Alpha_var_diff z z x1 x1 Nil
                                  (Alpha_var_refl x1)}}
                    in
                    eq_rec_r (Cons (Pair z z) Nil) _evar_0_
                      (app (Cons (Pair z z) Nil) Nil)}
        in
        eq_rec_r (app (Cons (Pair z z) Nil) Nil) _evar_0_
          (app Nil (app (Cons (Pair z z) Nil) Nil))) ren4 __ hshadow) ren3 __)
    (\z0 w sigma ren3 ren4 _ hshadow ->
    let {hrenAdd = cons_split_helper z0 w ren3 ren4 sigma} in
    case hrenAdd of {
     Inl s ->
      case s of {
       ExistT x1 _ ->
        eq_rec_r (Cons (Pair z0 w) x1) (\_ -> Alpha_var_cons z0 w
          (let {
            app0 l m =
              case l of {
               Nil -> m;
               Cons a l1 -> Cons a (app0 l1 m)}}
           in app0 x1 (app (Cons (Pair z z) Nil) ren4))) ren3 __};
     Inr _ ->
      eq_rec_r Nil (\_ ->
        eq_rec_r (Cons (Pair z0 w) sigma) (\hshadow0 _ ->
          let {
           _evar_0_ = let {
                       hshadow1 = shadow_helper_not_break z z0 w sigma
                                    hshadow0}
                      in
                      case hshadow1 of {
                       Inl _ ->
                        eq_rec_r z0 (\_ ->
                          eq_rec_r w (\_ -> Alpha_var_cons w w (Cons (Pair w
                            w) sigma)) z0 __) z __;
                       Inr _ -> Alpha_var_diff z z z0 w (Cons (Pair z0 w)
                        sigma) (Alpha_var_cons z0 w sigma)}}
          in
          eq_rec_r (app (Cons (Pair z z) Nil) (Cons (Pair z0 w) sigma))
            _evar_0_
            (app Nil (app (Cons (Pair z z) Nil) (Cons (Pair z0 w) sigma))))
          ren4 hshadow __) ren3 __})
    (\x1 y0 z0 w sigma _ _ halpha0 iHHalpha ren3 ren4 _ hshadow ->
    let {hrenAdd = cons_split_helper x1 y0 ren3 ren4 sigma} in
    case hrenAdd of {
     Inl s ->
      case s of {
       ExistT x2 _ ->
        eq_rec_r (Cons (Pair x1 y0) x2) (\_ -> Alpha_var_diff x1 y0 z0 w
          (let {
            app0 l m =
              case l of {
               Nil -> m;
               Cons a l1 -> Cons a (app0 l1 m)}}
           in app0 x2 (app (Cons (Pair z z) Nil) ren4))
          (iHHalpha x2 ren4 __ hshadow)) ren3 __};
     Inr _ ->
      eq_rec_r Nil (\_ ->
        eq_rec_r (Cons (Pair x1 y0) sigma) (\hshadow0 _ ->
          let {
           _evar_0_ = let {b = eqb1 z z0} in
                      case b of {
                       True ->
                        let {b0 = eqb1 z w} in
                        case b0 of {
                         True ->
                          eq_rec_r z0 (\iHHalpha0 hshadow1 _ ->
                            eq_rec_r w (\_ _ _ _ -> Alpha_var_cons w w (Cons
                              (Pair x1 y0) sigma)) z0 __ halpha0 iHHalpha0
                              hshadow1) z iHHalpha hshadow0 __;
                         False ->
                          eq_rec_r z0 (\_ _ _ -> false_rec) z iHHalpha
                            hshadow0 __};
                       False ->
                        let {b0 = eqb1 z w} in
                        case b0 of {
                         True -> false_rec;
                         False -> Alpha_var_diff z z z0 w (Cons (Pair x1 y0)
                          sigma) (Alpha_var_diff x1 y0 z0 w sigma halpha0)}}}
          in
          eq_rec_r (app (Cons (Pair z z) Nil) (Cons (Pair x1 y0) sigma))
            _evar_0_
            (app Nil (app (Cons (Pair z z) Nil) (Cons (Pair x1 y0) sigma))))
          ren4 hshadow __) ren3 __}) ren x y halpha ren1 ren2 __ x0

alpha_extend_id_split :: Term0 -> Term0 -> String -> (List
                         (Prod String String)) -> Alpha -> (List
                         (Prod String String)) -> (List (Prod String String))
                         -> NotBreakShadowing -> Alpha
alpha_extend_id_split s t z ren halpha ren1 ren2 x =
  alpha_rec (\x0 y sigma a ren3 ren4 _ hshadow -> Alpha_var x0 y
    (app ren3 (app (Cons (Pair z z) Nil) ren4))
    (alphavar_extend_id_split x0 y z sigma a ren3 ren4 hshadow))
    (\b x0 y a s1 s2 _ _ iHHalpha ren3 ren4 _ hshadow -> Alpha_lam b x0 y a
    s1 s2 (app ren3 (app (Cons (Pair z z) Nil) ren4))
    (iHHalpha (Cons (Pair x0 y) ren3) ren4 __ hshadow))
    (\b s1 s2 t1 t2 _ _ iHHalpha1 _ iHHalpha2 ren3 ren4 _ hshadow ->
    Alpha_app b s1 s2 t1 t2 (app ren3 (app (Cons (Pair z z) Nil) ren4))
    (iHHalpha1 ren3 ren4 __ hshadow) (iHHalpha2 ren3 ren4 __ hshadow))
    (\_ d ren3 ren4 _ _ -> Alpha_builtin
    (app ren3 (app (Cons (Pair z z) Nil) ren4)) d) ren s t halpha ren1 ren2
    __ x

alpha_extend_ids_right :: Term0 -> Term0 -> (List (Prod String String)) ->
                          (List (Prod String String)) -> IdCtx -> Alpha ->
                          Alpha
alpha_extend_ids_right s t ren idCtx hid halpha =
  idCtx_rec (eq_rec_r ren halpha (app ren Nil)) (\x ren0 hid0 iHHid ->
    let {
     _evar_0_ = alpha_extend_id_split s t x (app ren ren0) iHHid ren ren0
                  (idCtxNotBreakShadowing x ren0 hid0)}
    in
    eq_rec_r (app ren (app (Cons (Pair x x) Nil) ren0)) _evar_0_
      (app ren (Cons (Pair x x) ren0))) idCtx hid

alphavar_extend_ids :: (List (Prod String String)) -> String -> String ->
                       IdCtx -> AlphaVar -> AlphaVar
alphavar_extend_ids =
  Prelude.error "AXIOM TO BE REALIZED"

alpha_extend_ids :: (List (Prod String String)) -> Term0 -> Term0 -> IdCtx ->
                    Alpha -> Alpha
alpha_extend_ids idCtx s t =
  alpha_extend_ids_right s t Nil idCtx

alpha_weaken_ids :: (List (Prod String String)) -> Term0 -> Term0 -> IdCtx ->
                    Alpha -> Alpha
alpha_weaken_ids =
  Prelude.error "AXIOM TO BE REALIZED"

alpha_extend_id' :: Term0 -> Term0 -> String -> (List (Prod String String))
                    -> Alpha -> NotBreakShadowing -> Alpha
alpha_extend_id' s t z ren halpha hren =
  alpha_extend_id_split s t z ren halpha Nil ren hren

alpha_extend_id'' :: Term0 -> String -> (List (Prod String String)) -> Alpha
                     -> Alpha
alpha_extend_id'' =
  Prelude.error "AXIOM TO BE REALIZED"

alpha_extend_id :: Term0 -> String -> (List (Prod String String)) ->
                   NotBreakShadowing -> Alpha -> Alpha
alpha_extend_id s z ren hren halpha =
  alpha_extend_id' s s z ren halpha hren

alphaIdShadowsVacuous :: String -> String -> Term0 -> Alpha
alphaIdShadowsVacuous x x' s =
  term_rec (\s0 _ -> Alpha_var s0 s0 (Cons (Pair x x) (Cons (Pair x x') Nil))
    (let {b = eqb1 x s0} in
     case b of {
      True -> eq_rec_r s0 (Alpha_var_cons s0 s0 (Cons (Pair s0 x') Nil)) x;
      False -> Alpha_var_diff x x s0 s0 (Cons (Pair x x') Nil)
       (Alpha_var_diff x x' s0 s0 Nil (Alpha_var_refl s0))}))
    (\uSort s0 k s1 iHs _ -> Alpha_lam uSort s0 s0 k s1 s1 (Cons (Pair x x)
    (Cons (Pair x x') Nil))
    (let {b = eqb1 x' x} in
     case b of {
      True ->
       eq_rec_r x (\_ _ iHs0 ->
         let {b0 = eqb1 x s0} in
         case b0 of {
          True ->
           eq_rec_r s0 (\iHs1 _ _ ->
             alpha_extend_id s1 s0 (Cons (Pair s0 s0) (Cons (Pair s0 s0)
               Nil)) (Not_break_shadow_cons s0 s0 s0 (Cons (Pair s0 s0) Nil)
               (Not_break_shadow_cons s0 s0 s0 Nil (Not_break_shadow_nil
               s0))) (iHs1 __)) x iHs0 __ __;
          False ->
           alpha_extend_id s1 s0 (Cons (Pair x x) (Cons (Pair x x) Nil))
             (Not_break_shadow_cons s0 x x (Cons (Pair x x) Nil)
             (Not_break_shadow_cons s0 x x Nil (Not_break_shadow_nil s0)))
             (iHs0 __)}) x' __ __ iHs;
      False ->
       let {b0 = eqb1 x s0} in
       case b0 of {
        True ->
         eq_rec_r s0 (\iHs0 _ ->
           alpha_extend_id s1 s0 (Cons (Pair s0 s0) (Cons (Pair s0 x') Nil))
             (Not_break_shadow_id s0 (Cons (Pair s0 x') Nil)) (iHs0 __)) x
           iHs __;
        False ->
         alpha_extend_id s1 s0 (Cons (Pair x x) (Cons (Pair x x') Nil))
           (Not_break_shadow_cons s0 x x (Cons (Pair x x') Nil)
           (Not_break_shadow_cons s0 x x' Nil (Not_break_shadow_nil s0)))
           (iHs __)}})) (\bSort s1 iHs1 s2 iHs2 _ -> Alpha_app bSort s1 s1 s2
    s2 (Cons (Pair x x) (Cons (Pair x x') Nil)) (iHs1 __) (iHs2 __)) (\d _ ->
    Alpha_builtin (Cons (Pair x x) (Cons (Pair x x') Nil)) d) s __

alpha_extend_vacuous_ftv :: String -> String -> Term0 -> Term0 -> (List
                            (Prod String String)) -> Alpha -> Alpha
alpha_extend_vacuous_ftv =
  Prelude.error "AXIOM TO BE REALIZED"

alpha_vacuous_R :: Term0 -> Term0 -> (List (Prod String String)) -> (List
                   (Prod String String)) -> Alpha -> Alpha
alpha_vacuous_R =
  Prelude.error "AXIOM TO BE REALIZED"

alphavar_refl_weaken_vacuouss :: String -> (List (Prod String String)) ->
                                 AlphaVar
alphavar_refl_weaken_vacuouss x r =
  list_rec (\_ _ -> Alpha_var_refl x) (\a r0 iHR _ _ ->
    case a of {
     Pair s s0 -> Alpha_var_diff s s0 x x r0 (iHR __ __)}) r __ __

data Has_kind0 =
   K_Var0 (List (Prod String Kind)) String Kind
 | K_Fun0 (List (Prod BinderTyname Kind)) Term0 Term0 Has_kind0 Has_kind0
 | K_IFix0 (List (Prod BinderTyname Kind)) Term0 Term0 Kind Has_kind0 
 Has_kind0
 | K_Forall0 (List (Prod BinderTyname Kind)) BinderTyname Kind Term0 
 Has_kind0
 | K_Builtin0 (List (Prod BinderTyname Kind)) DefaultUni Has_kind_uni
 | K_Lam0 (List (Prod BinderTyname Kind)) BinderTyname Kind Term0 Kind 
 Has_kind0
 | K_App0 (List (Prod BinderTyname Kind)) Term0 Term0 Kind Kind Has_kind0 
 Has_kind0

has_kind_rect :: ((List (Prod String Kind)) -> String -> Kind -> () -> a1) ->
                 ((List (Prod BinderTyname Kind)) -> Term0 -> Term0 ->
                 Has_kind0 -> a1 -> Has_kind0 -> a1 -> a1) -> ((List
                 (Prod BinderTyname Kind)) -> Term0 -> Term0 -> Kind ->
                 Has_kind0 -> a1 -> Has_kind0 -> a1 -> a1) -> ((List
                 (Prod BinderTyname Kind)) -> BinderTyname -> Kind -> Term0
                 -> Has_kind0 -> a1 -> a1) -> ((List
                 (Prod BinderTyname Kind)) -> DefaultUni -> Has_kind_uni ->
                 a1) -> ((List (Prod BinderTyname Kind)) -> BinderTyname ->
                 Kind -> Term0 -> Kind -> Has_kind0 -> a1 -> a1) -> ((List
                 (Prod BinderTyname Kind)) -> Term0 -> Term0 -> Kind -> Kind
                 -> Has_kind0 -> a1 -> Has_kind0 -> a1 -> a1) -> (List
                 (Prod BinderTyname Kind)) -> Term0 -> Kind -> Has_kind0 ->
                 a1
has_kind_rect f0 f1 f2 f3 f4 f5 f6 _ _ _ h =
  case h of {
   K_Var0 _UU0394_ x k -> f0 _UU0394_ x k __;
   K_Fun0 _UU0394_ t1 t2 h0 h1 ->
    f1 _UU0394_ t1 t2 h0
      (has_kind_rect f0 f1 f2 f3 f4 f5 f6 _UU0394_ t1 Kind_Base h0) h1
      (has_kind_rect f0 f1 f2 f3 f4 f5 f6 _UU0394_ t2 Kind_Base h1);
   K_IFix0 _UU0394_ f7 t k h0 h1 ->
    f2 _UU0394_ f7 t k h0
      (has_kind_rect f0 f1 f2 f3 f4 f5 f6 _UU0394_ t k h0) h1
      (has_kind_rect f0 f1 f2 f3 f4 f5 f6 _UU0394_ f7 (Kind_Arrow (Kind_Arrow
        k Kind_Base) (Kind_Arrow k Kind_Base)) h1);
   K_Forall0 _UU0394_ x k t h0 ->
    f3 _UU0394_ x k t h0
      (has_kind_rect f0 f1 f2 f3 f4 f5 f6 (Cons (Pair x k) _UU0394_) t
        Kind_Base h0);
   K_Builtin0 _UU0394_ t h0 -> f4 _UU0394_ t h0;
   K_Lam0 _UU0394_ x k1 t k2 h0 ->
    f5 _UU0394_ x k1 t k2 h0
      (has_kind_rect f0 f1 f2 f3 f4 f5 f6 (Cons (Pair x k1) _UU0394_) t k2
        h0);
   K_App0 _UU0394_ t1 t2 k1 k2 h0 h1 ->
    f6 _UU0394_ t1 t2 k1 k2 h0
      (has_kind_rect f0 f1 f2 f3 f4 f5 f6 _UU0394_ t1 (Kind_Arrow k1 k2) h0)
      h1 (has_kind_rect f0 f1 f2 f3 f4 f5 f6 _UU0394_ t2 k1 h1)}

data Coq__UU03b1_CtxSub =
   Alpha_ctx_nil (List (Prod String String))
 | Alpha_ctx_cons (List (Prod String String)) (List (Prod String Term0)) 
 (List (Prod String Term0)) String String Term0 Term0 Coq__UU03b1_CtxSub 
 AlphaVar Alpha

_UU03b1_CtxSub_rect :: ((List (Prod String String)) -> a1) -> ((List
                       (Prod String String)) -> (List (Prod String Term0)) ->
                       (List (Prod String Term0)) -> String -> String ->
                       Term0 -> Term0 -> Coq__UU03b1_CtxSub -> a1 -> AlphaVar
                       -> Alpha -> a1) -> (List (Prod String String)) ->
                       (List (Prod String Term0)) -> (List
                       (Prod String Term0)) -> Coq__UU03b1_CtxSub -> a1
_UU03b1_CtxSub_rect f0 f1 _ _ _ _UU03b1_ =
  case _UU03b1_ of {
   Alpha_ctx_nil r -> f0 r;
   Alpha_ctx_cons r _UU03c3_ _UU03c3_' x y t t' _UU03b1_0 a a0 ->
    f1 r _UU03c3_ _UU03c3_' x y t t' _UU03b1_0
      (_UU03b1_CtxSub_rect f0 f1 r _UU03c3_ _UU03c3_' _UU03b1_0) a a0}

_UU03b1_CtxSub_rec :: ((List (Prod String String)) -> a1) -> ((List
                      (Prod String String)) -> (List (Prod String Term0)) ->
                      (List (Prod String Term0)) -> String -> String -> Term0
                      -> Term0 -> Coq__UU03b1_CtxSub -> a1 -> AlphaVar ->
                      Alpha -> a1) -> (List (Prod String String)) -> (List
                      (Prod String Term0)) -> (List (Prod String Term0)) ->
                      Coq__UU03b1_CtxSub -> a1
_UU03b1_CtxSub_rec =
  _UU03b1_CtxSub_rect

alpha_ctx_right_ex :: (List (Prod String String)) -> (List
                      (Prod String Term0)) -> (List (Prod String Term0)) ->
                      String -> String -> Term0 -> Coq__UU03b1_CtxSub ->
                      AlphaVar -> SigT Term0 (Prod () Alpha)
alpha_ctx_right_ex ren sigma sigma' x x' t x0 x1 =
  _UU03b1_CtxSub_rec (\_ _ _ -> false_rec)
    (\_ _ _ x2 y t0 t' _ iH_UU03b1_CtxSub a a0 h0 _ ->
    let {b = eqb1 x2 x} in
    case b of {
     True ->
      eq_rec_r x (\a1 _ ->
        eq_rec_r t
          (eq_rec_r t (\a2 _ _ ->
            eq_rec_r x' (\_ -> ExistT t' (Pair __ a2)) y a1) t0 a0 __ __) t0)
        x2 a __;
     False ->
      let {h4 = iH_UU03b1_CtxSub h0 __} in
      case h4 of {
       ExistT x3 p -> case p of {
                       Pair _ a1 -> ExistT x3 (Pair __ a1)}}}) ren sigma
    sigma' x0 x1 __

alpha_ctx_ren_nil :: (List (Prod String Term0)) -> Coq__UU03b1_CtxSub
alpha_ctx_ren_nil sigma =
  list_rec (Alpha_ctx_nil Nil) (\a sigma0 iHsigma ->
    case a of {
     Pair s t -> Alpha_ctx_cons Nil sigma0 sigma0 s s t t iHsigma
      (Alpha_var_refl s) (alpha_refl t Nil Alpha_refl_nil)}) sigma

_UU03b1_ctx_trans :: (List (Prod String String)) -> (List
                     (Prod String String)) -> (List (Prod String String)) ->
                     (List (Prod String Term0)) -> (List (Prod String Term0))
                     -> (List (Prod String Term0)) -> Coq__UU03b1_CtxTrans ->
                     Coq__UU03b1_CtxSub -> Coq__UU03b1_CtxSub ->
                     Coq__UU03b1_CtxSub
_UU03b1_ctx_trans r1 r2 r _UU03c3_ _UU03c3_' _UU03c3_'' x x0 x1 =
  list_rec (\_ _ _ h0 h1 ->
    case h0 of {
     Alpha_ctx_nil r0 ->
      eq_rec_r r1 (\_ _ ->
        case h1 of {
         Alpha_ctx_nil r3 -> eq_rec_r r2 (\_ _ -> Alpha_ctx_nil r) r3 __ __;
         Alpha_ctx_cons r3 _ _ _ _ _ _ x2 x3 x4 ->
          eq_rec_r r2 (\_ -> false_rec) r3 __ __ x2 x3 x4}) r0 __ __;
     Alpha_ctx_cons r0 _ _ _ _ _ _ x2 x3 x4 ->
      eq_rec_r r1 (\_ -> false_rec) r0 __ __ x2 x3 x4})
    (\_ _UU03c3_0 iH_UU03c3_ _ _ h h0 h1 ->
    case h0 of {
     Alpha_ctx_nil r0 -> eq_rec_r r1 (\_ -> false_rec) r0 __ __;
     Alpha_ctx_cons r0 _UU03c3_1 _UU03c3_'0 x2 y t t' x3 x4 x5 ->
      eq_rec_r r1 (\_ ->
        eq_rec_r _UU03c3_0 (\_ h4 h6 h8 ->
          case h1 of {
           Alpha_ctx_nil r3 -> eq_rec_r r2 (\_ -> false_rec) r3 __ __;
           Alpha_ctx_cons r3 _UU03c3_2 _UU03c3_'1 x6 y0 t0 t'0 x7 x8 x9 ->
            eq_rec_r r2 (\_ ->
              eq_rec_r y (\_ ->
                eq_rec_r t' (\_ ->
                  eq_rec_r _UU03c3_'0 (\_ h9 h11 h12 -> Alpha_ctx_cons r
                    _UU03c3_0 _UU03c3_'1 x2 y0 t t'0
                    (iH_UU03c3_ _UU03c3_'0 _UU03c3_'1 h h4 h9)
                    (alpha_var_trans x2 y y0 r1 r2 r h h6 h11)
                    (alpha_trans t t' t'0 r1 r2 r h h8 h12)) _UU03c3_2) t0)
                x6 __ __) r3 __ __ x7 x8 x9}) _UU03c3_1) r0 __ __ x3 x4 x5})
    _UU03c3_ _UU03c3_' _UU03c3_'' x x0 x1

alphaRename :: String -> String -> Term0 -> Alpha
alphaRename x x' s =
  term_rec (\s0 _ ->
    let {b = eqb1 x s0} in
    case b of {
     True ->
      eq_rec_r s0 (Alpha_var s0 x' (Cons (Pair s0 x') Nil) (Alpha_var_cons s0
        x' Nil)) x;
     False -> Alpha_var s0 s0 (Cons (Pair x x') Nil) (Alpha_var_diff x x' s0
      s0 Nil (Alpha_var_refl s0))}) (\uSort s0 k s1 iHs _ ->
    let {b = eqb1 x s0} in
    case b of {
     True ->
      eq_rec_r (Tmlam uSort s0 k s1) (Alpha_lam uSort s0 s0 k s1 s1 (Cons
        (Pair x x') Nil) (eq_rec_r x (alphaIdShadowsVacuous x x' s1) s0))
        (rename x x' (Tmlam uSort s0 k s1));
     False ->
      eq_rec_r (Tmlam uSort s0 k (rename x x' s1)) (Alpha_lam uSort s0 s0 k
        s1 (rename x x' s1) (Cons (Pair x x') Nil)
        (alpha_extend_id' s1 (rename x x' s1) s0 (Cons (Pair x x') Nil)
          (iHs __) (Not_break_shadow_cons s0 x x' Nil (Not_break_shadow_nil
          s0)))) (rename x x' (Tmlam uSort s0 k s1))})
    (\bSort s1 iHs1 s2 iHs2 _ -> Alpha_app bSort s1
    (let {
      mren0 rho t =
        case t of {
         Tmvar y ->
          case lookup y rho of {
           Some z -> Tmvar z;
           None -> Tmvar y};
         Tmlam b y k1 t_body -> Tmlam b y k1 (mren0 (drop y rho) t_body);
         Tmapp b t1 t2 -> Tmapp b (mren0 rho t1) (mren0 rho t2);
         Tmbuiltin d -> Tmbuiltin d}}
     in mren0 (Cons (Pair x x') Nil) s1) s2
    (let {
      mren0 rho t =
        case t of {
         Tmvar y ->
          case lookup y rho of {
           Some z -> Tmvar z;
           None -> Tmvar y};
         Tmlam b y k1 t_body -> Tmlam b y k1 (mren0 (drop y rho) t_body);
         Tmapp b t1 t2 -> Tmapp b (mren0 rho t1) (mren0 rho t2);
         Tmbuiltin d -> Tmbuiltin d}}
     in mren0 (Cons (Pair x x') Nil) s2) (Cons (Pair x x') Nil) (iHs1 __)
    (iHs2 __)) (\d _ -> Alpha_builtin (Cons (Pair x x') Nil) d) s __

alpha_trans_rename_right :: Term0 -> Term0 -> String -> String -> String ->
                            (List (Prod String String)) -> (List
                            (Prod String Term0)) -> Alpha -> Alpha
alpha_trans_rename_right u v b'' s'' s ren _ x =
  alpha_trans u v (rename s'' b'' v) (Cons (Pair s s'') ren)
    (app (Cons (Pair s'' b'') Nil) (ctx_id_right ren)) (Cons (Pair s b'')
    ren) (Alpha_trans_cons s s'' b'' ren (ctx_id_right ren) ren
    (id_right_trans ren)) x
    (alpha_extend_ids_right v (rename s'' b'' v) (Cons (Pair s'' b'') Nil)
      (ctx_id_right ren) (ctx_id_right_is_id ren) (alphaRename s'' b'' v))

alpha_trans_rename_left :: Term0 -> Term0 -> String -> String -> String ->
                           (List (Prod String String)) -> (List
                           (Prod String Term0)) -> Alpha -> Alpha
alpha_trans_rename_left u v b' s' s ren _ x =
  alpha_trans (rename s' b' u) u v
    (app (Cons (Pair b' s') Nil) (ctx_id_left ren)) (Cons (Pair s' s) ren)
    (Cons (Pair b' s) ren) (Alpha_trans_cons b' s' s (ctx_id_left ren) ren
    ren (id_left_trans ren))
    (alpha_extend_ids_right (rename s' b' u) u (Cons (Pair b' s') Nil)
      (ctx_id_left ren) (ctx_id_left_is_id ren)
      (alpha_sym u (rename s' b' u) (Cons (Pair s' b') Nil) (Cons (Pair b'
        s') Nil) (Alpha_sym_cons s' b' Nil Nil Alpha_sym_nil)
        (alphaRename s' b' u))) x

alpha_preserves_typing :: (List (Prod String String)) -> Term0 -> Term0 ->
                          Kind -> (List (Prod String Kind)) -> (List
                          (Prod String Kind)) -> Alpha -> Has_kind0 ->
                          Has_kind0
alpha_preserves_typing sigma s t a gamma gamma' hAlpha =
  alpha_rec (\x y _ _ gamma'0 gamma0 _ a0 hType ->
    case hType of {
     K_Var0 _UU0394_ x0 k ->
      eq_rec_r gamma0 (\_ ->
        eq_rec_r x (\_ -> eq_rec_r a0 (\_ -> K_Var0 gamma'0 y a0) k) x0)
        _UU0394_ __ __ __;
     K_Fun0 _UU0394_ _ _ x0 x1 ->
      eq_rec_r gamma0 (\_ -> false_rec) _UU0394_ __ __ x0 x1;
     K_IFix0 _UU0394_ _ _ _ x0 x1 ->
      eq_rec_r gamma0 (\_ -> false_rec) _UU0394_ __ __ x0 x1;
     K_Forall0 _UU0394_ _ _ _ x0 ->
      eq_rec_r gamma0 (\_ -> false_rec) _UU0394_ __ __ x0;
     K_Builtin0 _UU0394_ _ x0 ->
      eq_rec_r gamma0 (\_ -> false_rec) _UU0394_ __ __ x0;
     K_Lam0 _UU0394_ _ _ _ _ x0 ->
      eq_rec_r gamma0 (\_ -> false_rec) _UU0394_ __ __ x0;
     K_App0 _UU0394_ _ _ _ _ x0 x1 ->
      eq_rec_r gamma0 (\_ -> false_rec) _UU0394_ __ __ x0 x1})
    (\_ x y a0 s1 s2 _ _ iHHAlpha gamma'0 gamma0 _ _ hType ->
    case hType of {
     K_Var0 _UU0394_ _ _ ->
      eq_rec_r gamma0 (\_ -> false_rec) _UU0394_ __ __ __;
     K_Fun0 _UU0394_ _ _ x0 x1 ->
      eq_rec_r gamma0 (\_ -> false_rec) _UU0394_ __ __ x0 x1;
     K_IFix0 _UU0394_ _ _ _ x0 x1 ->
      eq_rec_r gamma0 (\_ -> false_rec) _UU0394_ __ __ x0 x1;
     K_Forall0 _UU0394_ x0 k t0 x1 ->
      eq_rec_r gamma0 (\_ ->
        eq_rec_r x (\_ ->
          eq_rec_r a0 (\_ ->
            eq_rec_r s1 (\_ h5 ->
              let {
               iHHAlpha0 = iHHAlpha (Cons (Pair y a0) gamma'0) (Cons (Pair x
                             a0) gamma0) __ Kind_Base h5}
              in
              K_Forall0 gamma'0 y a0 s2 iHHAlpha0) t0) k) x0 __ __) _UU0394_
        __ __ x1;
     K_Builtin0 _UU0394_ _ x0 ->
      eq_rec_r gamma0 (\_ -> false_rec) _UU0394_ __ __ x0;
     K_Lam0 _UU0394_ x0 k1 t0 k2 x1 ->
      eq_rec_r gamma0 (\_ ->
        eq_rec_r x (\_ ->
          eq_rec_r a0 (\_ ->
            eq_rec_r s1 (\_ h5 ->
              let {
               iHHAlpha0 = iHHAlpha (Cons (Pair y a0) gamma'0) (Cons (Pair x
                             a0) gamma0) __ k2 h5}
              in
              K_Lam0 gamma'0 y a0 s2 k2 iHHAlpha0) t0) k1) x0 __ __) _UU0394_
        __ __ x1;
     K_App0 _UU0394_ _ _ _ _ x0 x1 ->
      eq_rec_r gamma0 (\_ -> false_rec) _UU0394_ __ __ x0 x1})
    (\_ s1 s2 t1 t2 _ _ iHHAlpha1 _ iHHAlpha2 gamma'0 gamma0 _ a0 hType ->
    case hType of {
     K_Var0 _UU0394_ _ _ ->
      eq_rec_r gamma0 (\_ -> false_rec) _UU0394_ __ __ __;
     K_Fun0 _UU0394_ t3 t4 x x0 ->
      eq_rec_r gamma0 (\_ ->
        eq_rec_r s1 (\_ ->
          eq_rec_r t1 (\_ h4 h5 -> K_Fun0 gamma'0 s2 t2
            (iHHAlpha1 gamma'0 gamma0 __ Kind_Base h4)
            (iHHAlpha2 gamma'0 gamma0 __ Kind_Base h5)) t4) t3 __) _UU0394_
        __ __ x x0;
     K_IFix0 _UU0394_ f0 t0 k x x0 ->
      eq_rec_r gamma0 (\_ ->
        eq_rec_r s1 (\_ ->
          eq_rec_r t1 (\_ h4 h5 -> K_IFix0 gamma'0 s2 t2 k
            (iHHAlpha2 gamma'0 gamma0 __ k h4)
            (iHHAlpha1 gamma'0 gamma0 __ (Kind_Arrow (Kind_Arrow k Kind_Base)
              (Kind_Arrow k Kind_Base)) h5)) t0) f0 __) _UU0394_ __ __ x x0;
     K_Forall0 _UU0394_ _ _ _ x ->
      eq_rec_r gamma0 (\_ -> false_rec) _UU0394_ __ __ x;
     K_Builtin0 _UU0394_ _ x ->
      eq_rec_r gamma0 (\_ -> false_rec) _UU0394_ __ __ x;
     K_Lam0 _UU0394_ _ _ _ _ x ->
      eq_rec_r gamma0 (\_ -> false_rec) _UU0394_ __ __ x;
     K_App0 _UU0394_ t3 t4 k1 k2 x x0 ->
      eq_rec_r gamma0 (\_ ->
        eq_rec_r s1 (\_ ->
          eq_rec_r t1 (\_ ->
            eq_rec_r a0 (\h4 h5 -> K_App0 gamma'0 s2 t2 k1 a0
              (iHHAlpha1 gamma'0 gamma0 __ (Kind_Arrow k1 a0) h4)
              (iHHAlpha2 gamma'0 gamma0 __ k1 h5)) k2) t4) t3 __) _UU0394_ __
        __ x x0}) (\_ d gamma'0 gamma0 _ _ x ->
    case x of {
     K_Var0 _UU0394_ _ _ ->
      eq_rec_r gamma0 (\_ -> false_rec) _UU0394_ __ __ __;
     K_Fun0 _UU0394_ _ _ x0 x1 ->
      eq_rec_r gamma0 (\_ -> false_rec) _UU0394_ __ __ x0 x1;
     K_IFix0 _UU0394_ _ _ _ x0 x1 ->
      eq_rec_r gamma0 (\_ -> false_rec) _UU0394_ __ __ x0 x1;
     K_Forall0 _UU0394_ _ _ _ x0 ->
      eq_rec_r gamma0 (\_ -> false_rec) _UU0394_ __ __ x0;
     K_Builtin0 _UU0394_ t0 x0 ->
      eq_rec_r gamma0 (\_ ->
        eq_rec_r d (\_ h2 -> K_Builtin0 gamma'0 d h2) t0) _UU0394_ __ __ x0;
     K_Lam0 _UU0394_ _ _ _ _ x0 ->
      eq_rec_r gamma0 (\_ -> false_rec) _UU0394_ __ __ x0;
     K_App0 _UU0394_ _ _ _ _ x0 x1 ->
      eq_rec_r gamma0 (\_ -> false_rec) _UU0394_ __ __ x0 x1}) sigma s t
    hAlpha gamma' gamma __ a

substituteTCA_vacuous :: (List (Prod String String)) -> String -> Term0 ->
                         Term0 -> Term0 -> Alpha -> Alpha
substituteTCA_vacuous r x u t t' x0 =
  term_rec (\s r0 _ h _ ->
    case h of {
     Alpha_var x1 y sigma x2 ->
      eq_rec_r r0 (\_ _ ->
        eq_rec_r s (\_ ->
          eq_rec_r (case eqb1 x x1 of {
                     True -> u;
                     False -> Tmvar x1}) (eq_rec_r False h (eqb1 x x1))
            (substituteTCA x u (Tmvar x1))) y) sigma __ __ x2;
     Alpha_lam _ _ _ _ _ _ sigma x1 ->
      eq_rec_r r0 (\_ _ -> false_rec) sigma __ __ x1;
     Alpha_app _ _ _ _ _ sigma x1 x2 ->
      eq_rec_r r0 (\_ _ -> false_rec) sigma __ __ x1 x2;
     Alpha_builtin r1 _ -> eq_rec_r r0 (\_ _ -> false_rec) r1 __ __})
    (\uSort s k t'0 iHT' r0 _ h _ ->
    case h of {
     Alpha_var _ _ sigma x1 -> eq_rec_r r0 (\_ _ -> false_rec) sigma __ __ x1;
     Alpha_lam b x1 y a s1 s2 sigma x2 ->
      eq_rec_r r0 (\_ _ ->
        eq_rec_r uSort (\_ ->
          eq_rec_r s (\_ ->
            eq_rec_r k (\_ ->
              eq_rec_r t'0 (\h4 ->
                eq_rec_r uSort (\_ h0 ->
                  eq_rec_r k (\_ _ ->
                    eq_rec_r
                      (case eqb1 x x1 of {
                        True -> Tmlam uSort x1 k s1;
                        False ->
                         case existsb (eqb1 x1) (ftv u) of {
                          True ->
                           let {y' = fresh2 (Cons (Pair x u) Nil) s1} in
                           let {t'1 = rename x1 y' s1} in
                           Tmlam uSort y' k (substituteTCA x u t'1);
                          False -> Tmlam uSort x1 k (substituteTCA x u s1)}})
                      (let {b0 = eqb1 x x1} in
                       case b0 of {
                        True ->
                         eq_rec_r x1 (\_ _ -> Alpha_lam uSort x1 s k s1 t'0
                           r0 h4) x iHT' __;
                        False ->
                         let {b1 = existsb (eqb1 x1) (ftv u)} in
                         case b1 of {
                          True ->
                           let {y0 = fresh2 (Cons (Pair x u) Nil) s1} in
                           Alpha_lam uSort y0 s k
                           (substituteTCA x u (rename x1 y0 s1)) t'0 r0
                           (iHT' (Cons (Pair y0 s) r0) (rename x1 y0 s1)
                             (alpha_trans_rename_left s1 t'0 y0 x1 s r0 (Cons
                               (Pair x u) Nil) h4) __);
                          False -> Alpha_lam uSort x1 s k
                           (substituteTCA x u s1) t'0 r0
                           (iHT' (Cons (Pair x1 s) r0) s1 h4 __)}})
                      (substituteTCA x u (Tmlam uSort x1 k s1))) a h0 __) b
                  __ h) s2) a) y) b __ __ __) sigma __ __ x2;
     Alpha_app _ _ _ _ _ sigma x1 x2 ->
      eq_rec_r r0 (\_ _ -> false_rec) sigma __ __ x1 x2;
     Alpha_builtin r1 _ -> eq_rec_r r0 (\_ _ -> false_rec) r1 __ __})
    (\bSort t'1 iHT'1 t'2 iHT'2 r0 _ h _ ->
    case h of {
     Alpha_var _ _ sigma x1 -> eq_rec_r r0 (\_ _ -> false_rec) sigma __ __ x1;
     Alpha_lam _ _ _ _ _ _ sigma x1 ->
      eq_rec_r r0 (\_ _ -> false_rec) sigma __ __ x1;
     Alpha_app b s1 s2 t1 t2 sigma x1 x2 ->
      eq_rec_r r0 (\_ _ ->
        eq_rec_r bSort (\_ ->
          eq_rec_r t'1 (\_ ->
            eq_rec_r t'2 (\h5 h7 ->
              eq_rec_r bSort (\_ _ ->
                eq_rec_r (Tmapp bSort (substituteTCA x u s1)
                  (substituteTCA x u t1)) (Alpha_app bSort
                  (substituteTCA x u s1) t'1 (substituteTCA x u t1) t'2 r0
                  (iHT'1 r0 s1 h5 __) (iHT'2 r0 t1 h7 __))
                  (substituteTCA x u (Tmapp bSort s1 t1))) b __ h) t2) s2) b
          __ __) sigma __ __ x1 x2;
     Alpha_builtin r1 _ -> eq_rec_r r0 (\_ _ -> false_rec) r1 __ __})
    (\d r0 _ h _ ->
    case h of {
     Alpha_var _ _ sigma x1 -> eq_rec_r r0 (\_ _ -> false_rec) sigma __ __ x1;
     Alpha_lam _ _ _ _ _ _ sigma x1 ->
      eq_rec_r r0 (\_ _ -> false_rec) sigma __ __ x1;
     Alpha_app _ _ _ _ _ sigma x1 x2 ->
      eq_rec_r r0 (\_ _ -> false_rec) sigma __ __ x1 x2;
     Alpha_builtin r1 d0 ->
      eq_rec_r r0 (\_ _ ->
        eq_rec_r d
          (eq_rec_r d (\_ h0 ->
            eq_rec_r (Tmbuiltin d) h0 (substituteTCA x u (Tmbuiltin d))) d0
            __ h) d0) r1 __ __}) t' r t x0 __

sub :: String -> Term0 -> Term0 -> Term0
sub x u t =
  case t of {
   Tmvar y -> case eqb1 x y of {
               True -> u;
               False -> Tmvar y};
   Tmlam b y k1 t' -> Tmlam b y k1 (sub x u t');
   Tmapp b t1 t2 -> Tmapp b (sub x u t1) (sub x u t2);
   Tmbuiltin d -> Tmbuiltin d}

data Step_naive =
   Step_beta0 String Kind Term0 Term0
 | Step_appL0 BSort Term0 Term0 Term0 Step_naive
 | Step_appR0 BSort Term0 Term0 Term0 Step_naive
 | Step_abs0 USort String Kind Term0 Term0 Step_naive

step_naive_rect :: (String -> Kind -> Term0 -> Term0 -> a1) -> (BSort ->
                   Term0 -> Term0 -> Term0 -> Step_naive -> a1 -> a1) ->
                   (BSort -> Term0 -> Term0 -> Term0 -> Step_naive -> a1 ->
                   a1) -> (USort -> String -> Kind -> Term0 -> Term0 ->
                   Step_naive -> a1 -> a1) -> Term0 -> Term0 -> Step_naive ->
                   a1
step_naive_rect f0 f1 f2 f3 _ _ s =
  case s of {
   Step_beta0 x a s0 t -> f0 x a s0 t;
   Step_appL0 b s1 s2 t s0 ->
    f1 b s1 s2 t s0 (step_naive_rect f0 f1 f2 f3 s1 s2 s0);
   Step_appR0 b s0 t1 t2 s1 ->
    f2 b s0 t1 t2 s1 (step_naive_rect f0 f1 f2 f3 t1 t2 s1);
   Step_abs0 b x a s1 s2 s0 ->
    f3 b x a s1 s2 s0 (step_naive_rect f0 f1 f2 f3 s1 s2 s0)}

step_naive_rec :: (String -> Kind -> Term0 -> Term0 -> a1) -> (BSort -> Term0
                  -> Term0 -> Term0 -> Step_naive -> a1 -> a1) -> (BSort ->
                  Term0 -> Term0 -> Term0 -> Step_naive -> a1 -> a1) ->
                  (USort -> String -> Kind -> Term0 -> Term0 -> Step_naive ->
                  a1 -> a1) -> Term0 -> Term0 -> Step_naive -> a1
step_naive_rec =
  step_naive_rect

subs :: (List (Prod String Term0)) -> Term0 -> Term0
subs sigma t =
  case sigma of {
   Nil -> t;
   Cons p sigma' -> case p of {
                     Pair x t0 -> sub x t0 (subs sigma' t)}}

psubs :: (List (Prod String Term0)) -> Term0 -> Term0
psubs sigma t =
  case t of {
   Tmvar x -> case lookup x sigma of {
               Some t0 -> t0;
               None -> Tmvar x};
   Tmlam b x a s -> Tmlam b x a (psubs sigma s);
   Tmapp b s t0 -> Tmapp b (psubs sigma s) (psubs sigma t0);
   Tmbuiltin d -> Tmbuiltin d}

btv_env :: (List (Prod String Term0)) -> List String
btv_env sigma =
  case sigma of {
   Nil -> Nil;
   Cons p sigma' -> case p of {
                     Pair _ t -> app (btv t) (btv_env sigma')}}

data GU =
   GU_var String
 | GU_app BSort Term0 Term0 GU GU
 | GU_lam USort String Kind Term0 GU
 | GU_builtin DefaultUni

data NC =
   Nc_nil Term0
 | Nc_cons Term0 String Term0 (List (Prod String Term0)) NC

nc_lam :: USort -> String -> Term0 -> Kind -> (List (Prod String Term0)) ->
          NC -> NC
nc_lam b x s a sigma =
  list_rec (\_ -> Nc_nil s) (\_ sigma0 iHsigma hnc ->
    case hnc of {
     Nc_nil s0 -> eq_rec_r (Tmlam b x a s) (\_ -> false_rec) s0 __;
     Nc_cons s0 x0 t sigma1 x1 ->
      eq_rec_r (Tmlam b x a s) (\_ ->
        eq_rec_r sigma0 (\h2 _ -> Nc_cons s x0 t sigma0 (iHsigma h2)) sigma1)
        s0 __ x1 __}) sigma

nc_app_l :: BSort -> Term0 -> Term0 -> (List (Prod String Term0)) -> NC -> NC
nc_app_l b s t sigma =
  list_rec (\_ -> Nc_nil s) (\_ sigma0 iHsigma hnc ->
    case hnc of {
     Nc_nil s0 -> eq_rec_r (Tmapp b s t) (\_ -> false_rec) s0 __;
     Nc_cons s0 x t0 sigma1 x0 ->
      eq_rec_r (Tmapp b s t) (\_ ->
        eq_rec_r sigma0 (\h2 _ -> Nc_cons s x t0 sigma0 (iHsigma h2)) sigma1)
        s0 __ x0 __}) sigma

nc_app_r :: BSort -> Term0 -> Term0 -> (List (Prod String Term0)) -> NC -> NC
nc_app_r b s t sigma =
  list_rec (\_ -> Nc_nil t) (\_ sigma0 iHsigma hnc ->
    case hnc of {
     Nc_nil s0 -> eq_rec_r (Tmapp b s t) (\_ -> false_rec) s0 __;
     Nc_cons s0 x t0 sigma1 x0 ->
      eq_rec_r (Tmapp b s t) (\_ ->
        eq_rec_r sigma0 (\h2 _ -> Nc_cons t x t0 sigma0 (iHsigma h2)) sigma1)
        s0 __ x0 __}) sigma

alpha_preserves_nc_ctx :: Term0 -> String -> Term0 -> Term0 -> Alpha -> NC ->
                          NC
alpha_preserves_nc_ctx s x t t' _ hnc_t =
  case hnc_t of {
   Nc_nil s0 -> eq_rec_r s (\_ -> false_rec) s0 __;
   Nc_cons s0 x0 t0 sigma x1 ->
    eq_rec_r s (\_ ->
      eq_rec_r x (\_ ->
        eq_rec_r t (\_ ->
          eq_rec_r Nil (\h2 _ -> Nc_cons s x t' Nil h2) sigma) t0) x0 __ __)
      s0 __ x1 __}

step_naive_preserves_nc_ctx :: Term0 -> Term0 -> Term0 -> String ->
                               Step_naive -> NC -> NC
step_naive_preserves_nc_ctx s t1 t2 x _ hnc =
  case hnc of {
   Nc_nil s0 -> eq_rec_r s (\_ -> false_rec) s0 __;
   Nc_cons s0 x0 t sigma x1 ->
    eq_rec_r s (\_ ->
      eq_rec_r x (\_ ->
        eq_rec_r t1 (\_ ->
          eq_rec_r Nil (\_ _ -> Nc_cons s x t2 Nil (Nc_nil s)) sigma) t) x0
        __ __) s0 __ x1 __}

gu_app_l :: BSort -> Term0 -> Term0 -> GU -> GU
gu_app_l b s t h =
  case h of {
   GU_app b0 s0 t0 x x0 ->
    eq_rec_r b (\_ -> eq_rec_r s (\_ -> eq_rec_r t (\h2 _ _ _ -> h2) t0) s0)
      b0 __ __ x x0 __ __;
   GU_lam _ _ _ _ x -> false_rec x __;
   _ -> false_rec}

gu_app_r :: BSort -> Term0 -> Term0 -> GU -> GU
gu_app_r b s t h =
  case h of {
   GU_app b0 s0 t0 x x0 ->
    eq_rec_r b (\_ -> eq_rec_r s (\_ -> eq_rec_r t (\_ h4 _ _ -> h4) t0) s0)
      b0 __ __ x x0 __ __;
   GU_lam _ _ _ _ x -> false_rec x __;
   _ -> false_rec}

gu_lam :: USort -> String -> Kind -> Term0 -> GU -> GU
gu_lam b x a s h =
  case h of {
   GU_app _ _ _ x0 x1 -> false_rec x0 x1 __ __;
   GU_lam b0 x0 a0 s0 x1 ->
    eq_rec_r b (\_ ->
      eq_rec_r x (\_ -> eq_rec_r a (\_ -> eq_rec_r s (\h2 _ -> h2) s0) a0) x0)
      b0 __ __ __ x1 __;
   _ -> false_rec}

gu_applam_to_nc :: BSort -> USort -> Term0 -> Term0 -> String -> Kind -> GU
                   -> NC
gu_applam_to_nc bA bL s t x a hgu =
  case hgu of {
   GU_app b s0 t0 x0 x1 ->
    eq_rec_r bA (\_ ->
      eq_rec_r (Tmlam bL x a s) (\_ ->
        eq_rec_r t (\_ _ _ _ -> Nc_cons s x t Nil (Nc_nil s)) t0) s0) b __ __
      x0 x1 __ __;
   GU_lam _ _ _ _ x0 -> false_rec x0 __;
   _ -> false_rec}

data IdSubst =
   Id_subst_nil
 | Id_subst_cons String (List (Prod String Term0)) IdSubst

id_ctx_alphavar_refl :: (List (Prod String String)) -> String -> IdCtx ->
                        AlphaVar
id_ctx_alphavar_refl r x x0 =
  let {
   h0 = alpha_extend_ids r (Tmvar x) (Tmvar x) x0
          (alpha_refl (Tmvar x) Nil Alpha_refl_nil)}
  in
  case h0 of {
   Alpha_var x1 y sigma x2 ->
    eq_rec_r r (\_ -> eq_rec_r x (\_ -> eq_rec_r x (\h4 -> h4) y) x1) sigma
      __ __ x2;
   Alpha_lam _ _ _ _ _ _ sigma x1 ->
    eq_rec_r r (\_ -> false_rec) sigma __ __ x1;
   Alpha_app _ _ _ _ _ sigma x1 x2 ->
    eq_rec_r r (\_ -> false_rec) sigma __ __ x1 x2;
   Alpha_builtin r0 _ -> eq_rec_r r (\_ -> false_rec) r0 __ __}

fresh_to_GU_ :: (List String) -> (List (Prod String String)) -> String ->
                String
fresh_to_GU_ ftvs binders x =
  concat0 EmptyString
    (app ftvs
      (app (map fst binders)
        (app (map snd binders) (Cons x
          (app Nil (Cons (String0 (Ascii True False False False False True
            True False) EmptyString) Nil))))))

to_GU_ :: (List String) -> (List (Prod String String)) -> Term0 -> Prod
          (Prod (List String) (List (Prod String String))) Term0
to_GU_ used binders s =
  case s of {
   Tmvar x ->
    case lookup x binders of {
     Some y -> Pair (Pair (Cons y used) binders) (Tmvar y);
     None -> Pair (Pair (Cons x used) binders) (Tmvar x)};
   Tmlam b x a s0 ->
    let {x' = fresh_to_GU_ used binders x} in
    case to_GU_ used (Cons (Pair x x') binders) s0 of {
     Pair acc term_body -> Pair (Pair (app (fst acc) (Cons x (Cons x' Nil)))
      binders) (Tmlam b x' a term_body)};
   Tmapp b s0 t ->
    case to_GU_ used binders s0 of {
     Pair acc_s s' ->
      case to_GU_ (fst acc_s) binders t of {
       Pair acc_t t' -> Pair acc_t (Tmapp b s' t')}};
   Tmbuiltin d -> Pair (Pair used binders) (Tmbuiltin d)}

to_GU :: Term0 -> Term0
to_GU s =
  let {tvs = tv s} in snd (to_GU_ tvs (map (\x -> Pair x x) tvs) s)

type KindOfUniqueRhs = String -> String -> () -> AlphaVar

kindOfUniqueRhsFresh :: String -> (List (Prod String String)) -> (List
                        (Prod String String)) -> (List String) ->
                        KindOfUniqueRhs -> String -> String -> AlphaVar
kindOfUniqueRhsFresh x r r' used x0 x1 y =
  let {b = eqb1 x1 x} in
  case b of {
   True ->
    eq_rec_r x (\_ ->
      let {_evar_0_ = \_ -> Alpha_var_cons x (fresh_to_GU_ used r' x) r} in
      eq_rec_r True _evar_0_ (eqb1 x x) __) x1 __;
   False ->
    let {
     _evar_0_ = \_ ->
      let {
       _evar_0_ = \_ -> Alpha_var_diff x (fresh_to_GU_ used r' x) x1 y r
        (x0 x1 y __)}
      in
      eq_rec_r False _evar_0_ (eqb1 x x1) __}
    in
    eq_rec_r (eqb1 x x1) _evar_0_ (eqb1 x1 x) __}

idCtx__KindOfUniqueRhs :: (List (Prod String String)) -> IdCtx -> String ->
                          String -> AlphaVar
idCtx__KindOfUniqueRhs r x x0 y =
  idCtx_rec (\_ -> false_rec) (\x1 ren _ iHIdCtx _ ->
    let {b = eqb1 x0 x1} in
    case b of {
     True ->
      eq_rec_r x1 (\_ iHIdCtx0 ->
        let {
         _evar_0_ = \_ ->
          eq_rec_r y (eq_rec_r y (\_ -> Alpha_var_cons y y ren) x1 iHIdCtx0)
            x1}
        in
        eq_rec_r True _evar_0_ (eqb1 x1 x1) __) x0 __ iHIdCtx;
     False ->
      let {
       _evar_0_ = \_ ->
        let {
         _evar_0_ = \_ ->
          let {iHIdCtx0 = iHIdCtx __} in
          eq_rec_r y (\_ _ iHIdCtx' -> Alpha_var_diff x1 x1 y y ren iHIdCtx')
            x0 __ __ iHIdCtx0}
        in
        eq_rec_r False _evar_0_ (eqb1 x1 x0) __}
      in
      eq_rec_r (eqb1 x1 x0) _evar_0_ (eqb1 x0 x1) __}) r x __

to_GU__alpha_' :: Term0 -> (List (Prod String String)) -> (List String) ->
                  KindOfUniqueRhs -> (String -> () -> () -> AlphaVar) ->
                  Alpha
to_GU__alpha_' s r used x x0 =
  term_rec (\s0 _ r0 x1 x2 _ ->
    let {o = lookup s0 r0} in
    case o of {
     Some s1 -> Alpha_var s0 s1 r0 (x1 s0 s1 __);
     None -> Alpha_var s0 s0 r0 (x2 s0 __ __)})
    (\uSort s0 k s1 iHs used0 r0 x1 x2 _ ->
    let {p = to_GU_ used0 (Cons (Pair s0 (fresh_to_GU_ used0 r0 s0)) r0) s1}
    in
    case p of {
     Pair p0 t -> Alpha_lam uSort s0 (fresh_to_GU_ used0 r0 s0) k s1 t r0
      (let {iHs0 = iHs used0 (Cons (Pair s0 (fresh_to_GU_ used0 r0 s0)) r0)}
       in
       eq_rec_r
         (to_GU_ used0 (Cons (Pair s0 (fresh_to_GU_ used0 r0 s0)) r0) s1)
         iHs0 (Pair p0 t) (\x3 x4 _ ->
         kindOfUniqueRhsFresh s0 r0 r0 used0 x1 x3 x4) (\x3 _ _ ->
         let {b = eqb1 s0 x3} in
         case b of {
          True -> false_rec;
          False -> Alpha_var_diff s0 (fresh_to_GU_ used0 r0 s0) x3 x3 r0
           (x2 x3 __ __)}) __)}) (\bSort s1 iHs1 s2 iHs2 used0 r0 x1 x2 _ ->
    let {p1 = to_GU_ used0 r0 s1} in
    case p1 of {
     Pair p t ->
      case p of {
       Pair l l0 ->
        let {p2 = to_GU_ l r0 s2} in
        case p2 of {
         Pair p0 t0 -> Alpha_app bSort s1 t s2 t0 r0
          (let {iHs3 = iHs1 used0 r0} in
           eq_rec_r (to_GU_ used0 r0 s1) iHs3 (Pair (Pair l l0) t) x1
             (\x3 _ _ -> x2 x3 __ __) __)
          (let {iHs3 = iHs2 l r0} in
           eq_rec_r (to_GU_ l r0 s2) iHs3 (Pair p0 t0) x1 (\x3 _ _ ->
             x2 x3 __ __) __)}}}) (\d _ r0 _ _ _ -> Alpha_builtin r0 d) s
    used r x x0 __

to_GU__alpha_ :: Term0 -> (List (Prod String String)) -> (List String) ->
                 KindOfUniqueRhs -> (String -> () -> SigT String ()) -> Alpha
to_GU__alpha_ s r used =
  term_rec (\s0 _ r0 x _ ->
    let {o = lookup s0 r0} in
    case o of {
     Some s1 -> Alpha_var s0 s1 r0 (x s0 s1 __);
     None -> Alpha_var s0 s0 r0 false_rec})
    (\uSort s0 k s1 iHs used0 r0 x x0 ->
    let {p = to_GU_ used0 (Cons (Pair s0 (fresh_to_GU_ used0 r0 s0)) r0) s1}
    in
    case p of {
     Pair p0 t -> Alpha_lam uSort s0 (fresh_to_GU_ used0 r0 s0) k s1 t r0
      (let {iHs0 = iHs used0 (Cons (Pair s0 (fresh_to_GU_ used0 r0 s0)) r0)}
       in
       eq_rec_r
         (to_GU_ used0 (Cons (Pair s0 (fresh_to_GU_ used0 r0 s0)) r0) s1)
         iHs0 (Pair p0 t) (\x1 x2 _ ->
         kindOfUniqueRhsFresh s0 r0 r0 used0 x x1 x2) (\x1 _ ->
         let {b = eqb1 x1 s0} in
         case b of {
          True ->
           eq_rec_r s0 (\_ -> ExistT (fresh_to_GU_ used0 r0 s0) __) x1 __;
          False ->
           let {h0 = x0 x1} in
           let {h1 = h0 __} in case h1 of {
                                ExistT x2 _ -> ExistT x2 __}}))})
    (\bSort s1 iHs1 s2 iHs2 used0 r0 x x0 ->
    let {p1 = to_GU_ used0 r0 s1} in
    case p1 of {
     Pair p t ->
      case p of {
       Pair l l0 ->
        let {p2 = to_GU_ l r0 s2} in
        case p2 of {
         Pair p0 t0 -> Alpha_app bSort s1 t s2 t0 r0
          (let {iHs3 = iHs1 used0 r0} in
           eq_rec_r (to_GU_ used0 r0 s1) iHs3 (Pair (Pair l l0) t) x
             (\x1 _ -> x0 x1 __))
          (let {iHs3 = iHs2 l r0} in
           eq_rec_r (to_GU_ l r0 s2) iHs3 (Pair p0 t0) x (\x1 _ -> x0 x1 __))}}})
    (\d _ r0 _ _ -> Alpha_builtin r0 d) s used r

map_creates_IdCtx :: (List String) -> IdCtx
map_creates_IdCtx l =
  list_rec Id_ctx_nil (\a l0 iHl -> Id_ctx_cons a (map (\x -> Pair x x) l0)
    iHl) l

to_GU__alpha :: Term0 -> Alpha
to_GU__alpha s =
  let {s' = to_GU s} in
  let {r = map (\x -> Pair x x) (tv s)} in
  let {
   _evar_0_ = let {
               h = let {
                    h = let {_evar_0_ = map_creates_IdCtx (tv s)} in
                        eq_rec_r (map (\x -> Pair x x) (tv s)) _evar_0_ r}
                   in
                   to_GU__alpha_' s r (tv s) (\x x0 _ ->
                     idCtx__KindOfUniqueRhs r h x x0) (\x _ _ ->
                     id_ctx_alphavar_refl r x h)}
              in
              alpha_weaken_ids r s (snd (to_GU_ (tv s) r s))
                (eq_rec_r (map (\x -> Pair x x) (tv s)) (\_ _ ->
                  let {l = tv s} in
                  list_rec Id_ctx_nil (\a l0 iHl -> Id_ctx_cons a
                    (map (\x -> Pair x x) l0) iHl) l) r __ h) h}
  in
  eq_rec_r (snd (to_GU_ (tv s) r s)) _evar_0_ s'

to_GU__GU_ :: Term0 -> (List (Prod String String)) -> (List String) -> GU
to_GU__GU_ s r used =
  term_rec (\s0 _ r0 _ _ ->
    let {o = lookup s0 r0} in
    case o of {
     Some s1 -> GU_var s1;
     None -> GU_var s0}) (\uSort s0 k s1 iHs used0 r0 _ _ ->
    let {p = to_GU_ used0 (Cons (Pair s0 (fresh_to_GU_ used0 r0 s0)) r0) s1}
    in
    case p of {
     Pair p0 t -> GU_lam uSort (fresh_to_GU_ used0 r0 s0) k t
      (let {iHs0 = iHs used0 (Cons (Pair s0 (fresh_to_GU_ used0 r0 s0)) r0)}
       in
       eq_rec_r
         (to_GU_ used0 (Cons (Pair s0 (fresh_to_GU_ used0 r0 s0)) r0) s1)
         iHs0 (Pair p0 t) __ __)}) (\bSort s1 iHs1 s2 iHs2 used0 r0 _ _ ->
    let {p1 = to_GU_ used0 r0 s1} in
    case p1 of {
     Pair p t ->
      case p of {
       Pair l l0 ->
        let {p2 = to_GU_ l r0 s2} in
        case p2 of {
         Pair p0 t0 -> GU_app bSort t t0
          (let {iHs3 = iHs1 used0 r0} in
           eq_rec_r (to_GU_ used0 r0 s1) iHs3 (Pair (Pair l l0) t) __ __)
          (let {iHs3 = iHs2 l r0} in
           eq_rec_r (to_GU_ l r0 s2) iHs3 (Pair p0 t0) __ __)}}})
    (\d _ _ _ _ -> GU_builtin d) s used r __ __

to_GU__GU :: Term0 -> GU
to_GU__GU s =
  to_GU__GU_ s (map (\x -> Pair x x) (tv s)) (tv s)

to_GU' :: String -> Term0 -> Term0 -> Term0
to_GU' x t s =
  let {tvs = Cons x (app (tv t) (tv s))} in
  snd (to_GU_ tvs (map (\x0 -> Pair x0 x0) tvs) s)

to_GU'__alpha :: String -> Term0 -> Term0 -> Alpha
to_GU'__alpha x t s =
  let {s' = to_GU' x t s} in
  let {r = map (\x0 -> Pair x0 x0) (Cons x (app (tv t) (tv s)))} in
  let {
   _evar_0_ = let {
               h = to_GU__alpha_' s r (Cons x (app (tv t) (tv s)))
                     (\x0 x1 _ ->
                     idCtx__KindOfUniqueRhs r
                       (let {
                         _evar_0_ = map_creates_IdCtx (Cons x
                                      (app (tv t) (tv s)))}
                        in
                        eq_rec_r
                          (map (\x2 -> Pair x2 x2) (Cons x
                            (app (tv t) (tv s)))) _evar_0_ r) x0 x1)
                     (\x0 _ _ ->
                     id_ctx_alphavar_refl r x0
                       (eq_rec_r
                         (map (\x1 -> Pair x1 x1) (Cons x
                           (app (tv t) (tv s)))) (\_ _ ->
                         map_creates_IdCtx (Cons x (app (tv t) (tv s)))) r __
                         __))}
              in
              alpha_weaken_ids r s
                (snd (to_GU_ (Cons x (app (tv t) (tv s))) r s))
                (eq_rec_r
                  (map (\x0 -> Pair x0 x0) (Cons x (app (tv t) (tv s))))
                  (\_ _ ->
                  let {l = Cons x (app (tv t) (tv s))} in
                  list_rec Id_ctx_nil (\a l0 iHl -> Id_ctx_cons a
                    (map (\x0 -> Pair x0 x0) l0) iHl) l) r __ h) h}
  in
  eq_rec_r (snd (to_GU_ (Cons x (app (tv t) (tv s))) r s)) _evar_0_ s'

to_GU'__GU :: String -> Term0 -> Term0 -> GU
to_GU'__GU x t s =
  to_GU__GU_ s (map (\x0 -> Pair x0 x0) (Cons x (app (tv t) (tv s)))) (Cons x
    (app (tv t) (tv s)))

to_GU'__NC :: String -> Term0 -> Term0 -> NC
to_GU'__NC x t s =
  let {
   p = to_GU_ (Cons x (app (tv t) (tv s)))
         (map (\x0 -> Pair x0 x0) (Cons x (app (tv t) (tv s)))) s}
  in
  case p of {
   Pair _ t0 -> Nc_cons t0 x t Nil (Nc_nil t0)}

to_GU_app_unfold :: BSort -> Term0 -> Term0 -> Term0 -> SigT Term0
                    (SigT Term0 (Prod (Prod () Alpha) Alpha))
to_GU_app_unfold b s t st =
  let {
   p = to_GU_ (app (tv s) (tv t)) (map (\x -> Pair x x) (app (tv s) (tv t)))
         s}
  in
  case p of {
   Pair p0 t0 ->
    let {q = to_GU_ (fst p0) (map (\x -> Pair x x) (app (tv s) (tv t))) t} in
    case q of {
     Pair _ t1 -> ExistT t0 (ExistT t1
      (let {
        h0 = eq_rec_r (Tmapp b t0 t1) (\_ ->
               let {
                _evar_0_ = alpha_sym (Tmapp b s t) (to_GU (Tmapp b s t)) Nil
                             Nil Alpha_sym_nil (to_GU__alpha (Tmapp b s t))}
               in
               eq_rec_r (to_GU (Tmapp b s t)) _evar_0_ (Tmapp b t0 t1)) st __}
       in
       case h0 of {
        Alpha_var _ _ sigma x -> eq_rec_r Nil (\_ -> false_rec) sigma __ __ x;
        Alpha_lam _ _ _ _ _ _ sigma x ->
         eq_rec_r Nil (\_ -> false_rec) sigma __ __ x;
        Alpha_app b0 s1 s2 t2 t3 sigma x x0 ->
         eq_rec_r Nil (\_ ->
           eq_rec_r b (\_ ->
             eq_rec_r t0 (\_ ->
               eq_rec_r t1 (\_ ->
                 eq_rec_r s (\_ ->
                   eq_rec_r t (\h4 h8 ->
                     eq_rec_r (Tmapp b t0 t1) (\_ -> Pair (Pair __
                       (alpha_extend_ids Nil s t0 Id_ctx_nil
                         (alpha_extend_ids Nil s t0 Id_ctx_nil
                           (alpha_extend_ids Nil s t0 Id_ctx_nil
                             (alpha_sym t0 s (sym_alpha_ctx Nil) Nil
                               (sym_alpha_ctx_left_is_sym Nil) h4)))))
                       (alpha_extend_ids Nil t t1 Id_ctx_nil
                         (alpha_extend_ids Nil t t1 Id_ctx_nil
                           (alpha_extend_ids Nil t t1 Id_ctx_nil
                             (alpha_sym t1 t (sym_alpha_ctx Nil) Nil
                               (sym_alpha_ctx_left_is_sym Nil) h8))))) st __)
                     t3) s2 __) t2) s1) b0 __ __) sigma __ __ x x0;
        Alpha_builtin r _ -> eq_rec_r Nil (\_ -> false_rec) r __ __}))}}

to_GU_applam_unfold :: BSort -> USort -> Kind -> Term0 -> Term0 -> Term0 ->
                       String -> SigT String
                       (SigT Term0 (SigT Term0 (Prod (Prod () Alpha) Alpha)))
to_GU_applam_unfold bA bL a s t st x =
  let {h = to_GU_app_unfold bA (Tmlam bL x a s) t st} in
  case h of {
   ExistT x0 s0 ->
    case s0 of {
     ExistT x1 p ->
      case p of {
       Pair p0 a0 ->
        case p0 of {
         Pair _ a1 ->
          case a1 of {
           Alpha_var _ _ sigma x2 ->
            eq_rec_r Nil (\_ -> false_rec) sigma __ __ x2;
           Alpha_lam b x2 y a2 s1 s2 sigma x3 ->
            eq_rec_r Nil (\_ ->
              eq_rec_r bL (\_ ->
                eq_rec_r x (\_ ->
                  eq_rec_r a (\_ ->
                    eq_rec_r s (\_ h8 ->
                      eq_rec_r (Tmapp bA x0 x1) (\_ -> ExistT y (ExistT s2
                        (ExistT x1 (Pair (Pair __ h8) a0)))) st __) s1) a2)
                  x2) b __ __ __) sigma __ __ x3;
           Alpha_app _ _ _ _ _ sigma x2 x3 ->
            eq_rec_r Nil (\_ -> false_rec) sigma __ __ x2 x3;
           Alpha_builtin r _ -> eq_rec_r Nil (\_ -> false_rec) r __ __}}}}}

to_GU'' :: String -> Term0 -> Term0
to_GU'' x s =
  to_GU' x (Tmvar x) s

to_GU''__alpha :: String -> Term0 -> Alpha
to_GU''__alpha x s =
  to_GU'__alpha x (Tmvar x) s

to_GU''__GU_lam :: USort -> String -> Kind -> Term0 -> GU
to_GU''__GU_lam b x a s =
  GU_lam b x a (to_GU'' x s) (to_GU'__GU x (Tmvar x) s)

sconstr2 :: String -> Term0 -> String -> Term0 -> Term0 -> Prod
            (Prod Term0 Term0) Term0
sconstr2 x0 t x p s =
  let {ftvs = app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil))))}
  in
  let {r = map (\x1 -> Pair x1 x1) ftvs} in
  Pair (Pair (snd (to_GU_ ftvs r s)) (snd (to_GU_ ftvs r t)))
  (snd (to_GU_ ftvs r p))

sconstr2_alpha_s :: String -> Term0 -> String -> Term0 -> Term0 -> Term0 ->
                    Term0 -> Term0 -> Alpha
sconstr2_alpha_s x0 t x p s s' t' p' =
  eq_rec_r
    (snd
      (to_GU_
        (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))
        (map (\x1 -> Pair x1 x1)
          (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil))))))
        s)) (\_ ->
    eq_rec_r
      (snd
        (to_GU_
          (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))
          (map (\x1 -> Pair x1 x1)
            (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil))))))
          t)) (\_ ->
      eq_rec_r
        (snd
          (to_GU_
            (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))
            (map (\x1 -> Pair x1 x1)
              (app (ftv t)
                (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))) p))
        (alpha_weaken_ids
          (map (\x1 -> Pair x1 x1)
            (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil))))))
          s
          (snd
            (to_GU_
              (app (ftv t)
                (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))
              (map (\x1 -> Pair x1 x1)
                (app (ftv t)
                  (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))) s))
          (map_creates_IdCtx
            (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil))))))
          (to_GU__alpha_ s
            (map (\x1 -> Pair x1 x1)
              (app (ftv t)
                (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil))))))
            (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))
            (\x1 x2 _ ->
            idCtx__KindOfUniqueRhs
              (map (\x3 -> Pair x3 x3)
                (app (ftv t)
                  (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil))))))
              (map_creates_IdCtx
                (app (ftv t)
                  (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))) x1 x2)
            (\x1 _ -> ExistT x1 __))) p') t') s' __ __

sconstr2_alpha_t :: String -> Term0 -> String -> Term0 -> Term0 -> Term0 ->
                    Term0 -> Term0 -> Alpha
sconstr2_alpha_t x0 t x p s s' t' p' =
  eq_rec_r
    (snd
      (to_GU_
        (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))
        (map (\x1 -> Pair x1 x1)
          (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil))))))
        s)) (\_ ->
    eq_rec_r
      (snd
        (to_GU_
          (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))
          (map (\x1 -> Pair x1 x1)
            (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil))))))
          t)) (\_ ->
      eq_rec_r
        (snd
          (to_GU_
            (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))
            (map (\x1 -> Pair x1 x1)
              (app (ftv t)
                (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))) p))
        (alpha_weaken_ids
          (map (\x1 -> Pair x1 x1)
            (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil))))))
          t
          (snd
            (to_GU_
              (app (ftv t)
                (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))
              (map (\x1 -> Pair x1 x1)
                (app (ftv t)
                  (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))) t))
          (map_creates_IdCtx
            (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil))))))
          (to_GU__alpha_ t
            (map (\x1 -> Pair x1 x1)
              (app (ftv t)
                (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil))))))
            (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))
            (\x1 x2 _ ->
            idCtx__KindOfUniqueRhs
              (map (\x3 -> Pair x3 x3)
                (app (ftv t)
                  (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil))))))
              (map_creates_IdCtx
                (app (ftv t)
                  (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))) x1 x2)
            (\x1 _ -> ExistT x1 __))) p') t') s' __ __

sconstr2_alpha_p :: String -> Term0 -> String -> Term0 -> Term0 -> Term0 ->
                    Term0 -> Term0 -> Alpha
sconstr2_alpha_p x0 t x p s s' t' p' =
  eq_rec_r
    (snd
      (to_GU_
        (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))
        (map (\x1 -> Pair x1 x1)
          (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil))))))
        s)) (\_ ->
    eq_rec_r
      (snd
        (to_GU_
          (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))
          (map (\x1 -> Pair x1 x1)
            (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil))))))
          t)) (\_ ->
      eq_rec_r
        (snd
          (to_GU_
            (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))
            (map (\x1 -> Pair x1 x1)
              (app (ftv t)
                (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))) p))
        (alpha_weaken_ids
          (map (\x1 -> Pair x1 x1)
            (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil))))))
          p
          (snd
            (to_GU_
              (app (ftv t)
                (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))
              (map (\x1 -> Pair x1 x1)
                (app (ftv t)
                  (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))) p))
          (map_creates_IdCtx
            (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil))))))
          (to_GU__alpha_ p
            (map (\x1 -> Pair x1 x1)
              (app (ftv t)
                (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil))))))
            (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))
            (\x1 x2 _ ->
            idCtx__KindOfUniqueRhs
              (map (\x3 -> Pair x3 x3)
                (app (ftv t)
                  (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil))))))
              (map_creates_IdCtx
                (app (ftv t)
                  (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))) x1 x2)
            (\x1 _ -> ExistT x1 __))) p') t') s' __ __

sconstr2_nc_s :: String -> Term0 -> String -> Term0 -> Term0 -> Term0 ->
                 Term0 -> Term0 -> NC
sconstr2_nc_s x0 t x p s s' t' p' =
  eq_rec_r
    (snd
      (to_GU_
        (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))
        (map (\x1 -> Pair x1 x1)
          (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil))))))
        s)) (\_ ->
    eq_rec_r
      (snd
        (to_GU_
          (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))
          (map (\x1 -> Pair x1 x1)
            (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil))))))
          t)) (\_ ->
      eq_rec_r
        (snd
          (to_GU_
            (app (ftv t) (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))
            (map (\x1 -> Pair x1 x1)
              (app (ftv t)
                (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))) p))
        (let {
          gU_s = to_GU_
                   (app (ftv t)
                     (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))
                   (map (\x1 -> Pair x1 x1)
                     (app (ftv t)
                       (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))) s}
         in
         case gU_s of {
          Pair _ t0 ->
           let {
            gU_p = to_GU_
                     (app (ftv t)
                       (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil)))))
                     (map (\x1 -> Pair x1 x1)
                       (app (ftv t)
                         (app (ftv p) (app (ftv s) (Cons x0 (Cons x Nil))))))
                     p}
           in
           case gU_p of {
            Pair _ t1 -> Nc_cons t0 x t1 Nil (Nc_nil t0)}}) p') t') s' __ __

sconstr2_nc_s_t :: String -> Term0 -> String -> Term0 -> Term0 -> Term0 ->
                   Term0 -> Term0 -> NC
sconstr2_nc_s_t x0 _ _ _ _ s' t' _ =
  Nc_cons s' x0 t' Nil (Nc_nil s')

sconstr2_nc_t :: String -> Term0 -> String -> Term0 -> Term0 -> Term0 ->
                 Term0 -> Term0 -> NC
sconstr2_nc_t =
  Prelude.error "AXIOM TO BE REALIZED"

sconstr2_nc_sub :: String -> Term0 -> String -> Term0 -> Term0 -> Term0 ->
                   Term0 -> Term0 -> NC
sconstr2_nc_sub =
  Prelude.error "AXIOM TO BE REALIZED"

list_diff :: (a1 -> a1 -> Sumbool) -> (List a1) -> (List a1) -> List a1
list_diff eq_dec l1 l2 =
  filter (\x ->
    case is_left (in_dec eq_dec x l2) of {
     True -> False;
     False -> True}) l1

strip_R'' :: (List (Prod String String)) -> (List String) -> (List String) ->
             List (Prod String String)
strip_R'' r lhs rhs =
  case r of {
   Nil -> Nil;
   Cons p r' ->
    case p of {
     Pair x y ->
      case orb (is_left (in_dec string_dec x lhs))
             (is_left (in_dec string_dec y rhs)) of {
       True -> strip_R'' r' (Cons x lhs) (Cons y rhs);
       False -> Cons (Pair x y) (strip_R'' r' (Cons x lhs) (Cons y rhs))}}}

strip_R :: (List (Prod String String)) -> List (Prod String String)
strip_R r =
  strip_R'' r Nil Nil

freshen2 :: (List String) -> (List String) -> List (Prod String String)
freshen2 used to_freshen =
  fold_right (\x acc ->
    let {fresh_var = fresh_to_GU_ used acc x} in Cons (Pair x fresh_var) acc)
    Nil to_freshen

a_R_constr :: (List (Prod String String)) -> Term0 -> Term0 -> Term0 -> List
              (Prod String String)
a_R_constr r s s' t =
  let {
   used = app (tv s) (app (tv s') (app (tv t) (app (map fst r) (map snd r))))}
  in
  let {to_freshen = list_diff string_dec (ftv t) (ftv s)} in
  let {rfr = freshen2 used to_freshen} in app rfr (strip_R r)

a_R_constr_UniqueRHS :: (List (Prod String String)) -> (List
                        (Prod String String)) -> Term0 -> Term0 -> Term0 ->
                        String -> String -> AlphaVar
a_R_constr_UniqueRHS =
  Prelude.error "AXIOM TO BE REALIZED"

a_constr :: (List (Prod String String)) -> Term0 -> Term0 -> Term0 -> Prod
            (List (Prod String String)) Term0
a_constr r s s' t =
  let {r' = a_R_constr r s s' t} in
  let {
   used' = app (tv s)
             (app (tv s') (app (tv t) (app (map fst r') (map snd r'))))}
  in
  Pair r' (snd (to_GU_ used' r' t))

a_R_constr_alpha_s :: (List (Prod String String)) -> Term0 -> Term0 -> Term0
                      -> (List (Prod String String)) -> Alpha -> Alpha
a_R_constr_alpha_s =
  Prelude.error "AXIOM TO BE REALIZED"

a_constr__t_alpha :: (List (Prod String String)) -> Term0 -> Term0 -> Term0
                     -> (List (Prod String String)) -> Term0 -> Alpha ->
                     Alpha
a_constr__t_alpha r s s' t r' t' _ =
  eq_rec_r (a_R_constr r s s' t) (\_ ->
    eq_rec_r
      (snd
        (to_GU_
          (app (tv s)
            (app (tv s')
              (app (tv t)
                (app (map fst (a_R_constr r s s' t))
                  (map snd (a_R_constr r s s' t)))))) (a_R_constr r s s' t)
          t))
      (to_GU__alpha_' t (a_R_constr r s s' t)
        (app (tv s)
          (app (tv s')
            (app (tv t)
              (app (map fst (a_R_constr r s s' t))
                (map snd (a_R_constr r s s' t)))))) (\x x0 _ ->
        a_R_constr_UniqueRHS r (a_R_constr r s s' t) s s' t x x0) (\x _ _ ->
        alphavar_refl_weaken_vacuouss x r')) t') r' __

a_constr__s_alpha :: (List (Prod String String)) -> Term0 -> Term0 -> Term0
                     -> (List (Prod String String)) -> Term0 -> Alpha ->
                     Alpha
a_constr__s_alpha r s s' t r' t' x =
  eq_rec_r (a_R_constr r s s' t) (\_ ->
    eq_rec_r
      (snd
        (to_GU_
          (app (tv s)
            (app (tv s')
              (app (tv t)
                (app (map fst (a_R_constr r s s' t))
                  (map snd (a_R_constr r s s' t)))))) (a_R_constr r s s' t)
          t))
      (let {h0 = a_R_constr_alpha_s r s s' t r' x} in
       eq_rec_r (a_R_constr r s s' t) (\_ h1 ->
         eq_rec_r
           (snd
             (to_GU_
               (app (tv s)
                 (app (tv s')
                   (app (tv t)
                     (app (map fst (a_R_constr r s s' t))
                       (map snd (a_R_constr r s s' t))))))
               (a_R_constr r s s' t) t)) (\_ -> h1) t' __) r' __ h0) t') r'
    __

r_constr :: Term0 -> Term0 -> (List (Prod String Term0)) -> String -> Prod
            (List (Prod String String)) (List (Prod String String))
r_constr t s sigma _ =
  let {tvs = app (tv s) (tv_keys_env sigma)} in
  let {btvs = app (btv s) (btv_env sigma)} in
  let {tv_t = tv t} in
  let {used = app tv_t tvs} in
  let {r2 = map (\x -> Pair x x) (list_diff string_dec (ftv t) btvs)} in
  let {r1 = freshen2 (app used (app (map fst r2) (map snd r2))) btvs} in
  Pair r1 r2

t_constr :: Term0 -> Term0 -> (List (Prod String Term0)) -> String -> Prod
            Term0 (List (Prod String String))
t_constr t s sigma x =
  let {tvs = app (tv s) (tv_keys_env sigma)} in
  let {tv_t = tv t} in
  let {used = app tv_t tvs} in
  case r_constr t s sigma x of {
   Pair r1 r2 -> Pair (snd (to_GU_ used (app r1 r2) t)) (app r1 r2)}

kindOfUniqueRhsFreshMultiple :: (List String) -> (List (Prod String String))
                                -> (List String) -> KindOfUniqueRhs -> String
                                -> String -> AlphaVar
kindOfUniqueRhsFreshMultiple used r l x x0 y =
  list_rec (\h -> h) (\a l0 iHl x1 ->
    let {
     _evar_0_ = let {
                 r'' = fold_right (\x2 acc -> Cons (Pair x2
                         (fresh_to_GU_
                           (app used (app (map fst r) (map snd r))) acc x2))
                         acc) Nil l0}
                in
                let {
                 iHl0 = eq_rec_r
                          (fold_right (\x2 acc -> Cons (Pair x2
                            (fresh_to_GU_
                              (app used (app (map fst r) (map snd r))) acc
                              x2)) acc) Nil l0) iHl r''}
                in
                let {iHl1 = iHl0 x1} in
                (\x2 x3 _ ->
                kindOfUniqueRhsFresh a (app r'' r) r''
                  (app used (app (map fst r) (map snd r))) iHl1 x2 x3)}
    in
    eq_rec_r
      (fold_right (\x2 acc -> Cons (Pair x2
        (fresh_to_GU_ (app used (app (map fst r) (map snd r))) acc x2)) acc)
        (fold_right (\x2 acc -> Cons (Pair x2
          (fresh_to_GU_ (app used (app (map fst r) (map snd r))) acc x2))
          acc) Nil l0) (Cons a Nil)) _evar_0_
      (fold_right (\x2 acc -> Cons (Pair x2
        (fresh_to_GU_ (app used (app (map fst r) (map snd r))) acc x2)) acc)
        Nil (app (Cons a Nil) l0))) l x x0 y __

t_constr__a_t :: Term0 -> Term0 -> (List (Prod String String)) -> Term0 ->
                 (List (Prod String Term0)) -> String -> Alpha
t_constr__a_t t t' r s sigma x =
  let {used = app (tv t) (app (tv s) (tv_keys_env sigma))} in
  let {r' = r_constr t s sigma x} in
  case r' of {
   Pair l l0 ->
    eq_rec_r (snd (to_GU_ used (app l l0) t)) (\_ ->
      eq_rec_r (app l l0)
        (eq_rec_r (app (tv t) (app (tv s) (tv_keys_env sigma))) (\_ ->
          to_GU__alpha_' t (app l l0)
            (app (tv t) (app (tv s) (tv_keys_env sigma)))
            (eq_rec_r
              (freshen2
                (app (app (tv t) (app (tv s) (tv_keys_env sigma)))
                  (app
                    (map fst
                      (map (\x0 -> Pair x0 x0)
                        (list_diff string_dec (ftv t)
                          (app (btv s) (btv_env sigma)))))
                    (map snd
                      (map (\x0 -> Pair x0 x0)
                        (list_diff string_dec (ftv t)
                          (app (btv s) (btv_env sigma)))))))
                (app (btv s) (btv_env sigma))) (\_ ->
              eq_rec_r
                (map (\x0 -> Pair x0 x0)
                  (list_diff string_dec (ftv t)
                    (app (btv s) (btv_env sigma)))) (\x0 x1 _ ->
                kindOfUniqueRhsFreshMultiple
                  (app (tv t) (app (tv s) (tv_keys_env sigma)))
                  (map (\x2 -> Pair x2 x2)
                    (list_diff string_dec (ftv t)
                      (app (btv s) (btv_env sigma))))
                  (app (btv s) (btv_env sigma)) (\x2 x3 _ ->
                  idCtx__KindOfUniqueRhs
                    (map (\x4 -> Pair x4 x4)
                      (list_diff string_dec (ftv t)
                        (app (btv s) (btv_env sigma))))
                    (map_creates_IdCtx
                      (list_diff string_dec (ftv t)
                        (app (btv s) (btv_env sigma)))) x2 x3) x0 x1) l0) l
              __) (\_ _ _ -> false_rec)) used __) r) t' __}

r_constr__a_s :: (List (Prod String String)) -> (List (Prod String String))
                 -> Term0 -> Term0 -> (List (Prod String Term0)) -> String ->
                 GU -> Alpha
r_constr__a_s r1 r2 t s sigma _ _ =
  alpha_vacuous_R s s r1 r2
    (alpha_extend_ids r2 s s
      (eq_rec_r
        (freshen2
          (app (app (tv t) (app (tv s) (tv_keys_env sigma)))
            (app
              (map fst
                (map (\x -> Pair x x)
                  (list_diff string_dec (ftv t)
                    (app (btv s) (btv_env sigma)))))
              (map snd
                (map (\x -> Pair x x)
                  (list_diff string_dec (ftv t)
                    (app (btv s) (btv_env sigma)))))))
          (app (btv s) (btv_env sigma))) (\_ ->
        eq_rec_r
          (map (\x -> Pair x x)
            (list_diff string_dec (ftv t) (app (btv s) (btv_env sigma))))
          (map_creates_IdCtx
            (list_diff string_dec (ftv t) (app (btv s) (btv_env sigma)))) r2)
        r1 __) (alpha_refl s Nil Alpha_refl_nil))

t_constr__a_s :: Term0 -> Term0 -> (List (Prod String String)) -> Term0 ->
                 (List (Prod String Term0)) -> String -> GU -> Alpha
t_constr__a_s t t' r s sigma x x0 =
  let {p = r_constr t s sigma x} in
  case p of {
   Pair l l0 ->
    eq_rec_r
      (snd
        (to_GU_ (app (tv t) (app (tv s) (tv_keys_env sigma))) (app l l0) t))
      (\_ -> eq_rec_r (app l l0) (r_constr__a_s l l0 t s sigma x x0) r) t' __}

t_constr__a_sigma :: Term0 -> Term0 -> (List (Prod String String)) -> Term0
                     -> (List (Prod String Term0)) -> String ->
                     Coq__UU03b1_CtxSub
t_constr__a_sigma =
  Prelude.error "AXIOM TO BE REALIZED"

t_constr__nc_s :: Term0 -> Term0 -> (List (Prod String String)) -> Term0 ->
                  (List (Prod String Term0)) -> String -> NC -> NC
t_constr__nc_s _ t' _ s sigma x x0 =
  Nc_cons s x t' sigma x0

t_constr__nc_subs :: Term0 -> Term0 -> (List (Prod String String)) -> Term0
                     -> (List (Prod String Term0)) -> String -> NC
t_constr__nc_subs =
  Prelude.error "AXIOM TO BE REALIZED"

s_constr :: Term0 -> (List (Prod String Term0)) -> Term0
s_constr s sigma =
  let {tvs = app (tv_keys_env sigma) (tv s)} in
  snd (to_GU_ tvs (map (\x -> Pair x x) tvs) s)

s_constr__a_s :: Term0 -> Term0 -> (List (Prod String Term0)) -> Alpha
s_constr__a_s s s' sigma =
  let {r = map (\x -> Pair x x) (app (tv_keys_env sigma) (tv s))} in
  let {
   _evar_0_ = let {
               h = let {
                    _evar_0_ = to_GU__alpha_' s r
                                 (app (tv_keys_env sigma) (tv s)) (\x x0 _ ->
                                 idCtx__KindOfUniqueRhs r
                                   (let {
                                     _evar_0_ = map_creates_IdCtx
                                                  (app (tv_keys_env sigma)
                                                    (tv s))}
                                    in
                                    eq_rec_r
                                      (map (\x1 -> Pair x1 x1)
                                        (app (tv_keys_env sigma) (tv s)))
                                      _evar_0_ r) x x0) (\x _ _ ->
                                 id_ctx_alphavar_refl r x
                                   (eq_rec_r
                                     (map (\x0 -> Pair x0 x0)
                                       (app (tv_keys_env sigma) (tv s)))
                                     (\_ _ ->
                                     map_creates_IdCtx
                                       (app (tv_keys_env sigma) (tv s))) r __
                                     __))}
                   in
                   eq_rec_r
                     (snd (to_GU_ (app (tv_keys_env sigma) (tv s)) r s))
                     _evar_0_ s'}
              in
              alpha_weaken_ids r s
                (snd (to_GU_ (app (tv_keys_env sigma) (tv s)) r s))
                (eq_rec_r
                  (map (\x -> Pair x x) (app (tv_keys_env sigma) (tv s)))
                  (\_ h0 ->
                  eq_rec_r
                    (snd
                      (to_GU_ (app (tv_keys_env sigma) (tv s))
                        (map (\x -> Pair x x)
                          (app (tv_keys_env sigma) (tv s))) s)) (\_ ->
                    let {l = app (tv_keys_env sigma) (tv s)} in
                    list_rec Id_ctx_nil (\a l0 iHl -> Id_ctx_cons a
                      (map (\x -> Pair x x) l0) iHl) l) s' h0) r __ h)
                (eq_rec_r
                  (map (\x -> Pair x x) (app (tv_keys_env sigma) (tv s)))
                  (\_ h0 ->
                  eq_rec_r
                    (snd
                      (to_GU_ (app (tv_keys_env sigma) (tv s))
                        (map (\x -> Pair x x)
                          (app (tv_keys_env sigma) (tv s))) s)) (\h1 -> h1)
                    s' h0) r __ h)}
  in
  eq_rec_r (snd (to_GU_ (app (tv_keys_env sigma) (tv s)) r s)) _evar_0_ s'

s_constr__gu :: Term0 -> Term0 -> (List (Prod String Term0)) -> GU
s_constr__gu s s' sigma =
  eq_rec_r
    (snd
      (to_GU_ (app (tv_keys_env sigma) (tv s))
        (map (\x -> Pair x x) (app (tv_keys_env sigma) (tv s))) s))
    (to_GU__GU_ s (map (\x -> Pair x x) (app (tv_keys_env sigma) (tv s)))
      (app (tv_keys_env sigma) (tv s))) s'

nc_helper :: Term0 -> (List (Prod String Term0)) -> NC
nc_helper s sigma =
  list_rec (\_ -> Nc_nil s) (\a sigma0 iHsigma _ ->
    case a of {
     Pair s0 t -> Nc_cons s s0 t sigma0 (iHsigma __)}) sigma __

s_constr__nc_s :: Term0 -> Term0 -> (List (Prod String Term0)) -> NC
s_constr__nc_s s s' sigma =
  eq_rec_r (s_constr s sigma)
    (let {
      p = to_GU_ (app (tv_keys_env sigma) (tv s))
            (map (\x -> Pair x x) (app (tv_keys_env sigma) (tv s))) s}
     in
     nc_helper (snd p) sigma) s'

alpha_extend_fresh_tv :: String -> String -> (List (Prod String String)) ->
                         Term0 -> Term0 -> Alpha -> Alpha
alpha_extend_fresh_tv x x' ren t t' x0 =
  alpha_rec (\x1 y sigma a _ _ -> Alpha_var x1 y (Cons (Pair x x') sigma)
    (Alpha_var_diff x x' x1 y sigma a))
    (\b x1 y a s1 s2 sigma _ iHAlpha _ _ -> Alpha_lam b x1 y a s1 s2 (Cons
    (Pair x x') sigma)
    (alpha_swap s1 s2 (Cons (Pair x1 y) (Cons (Pair x x') sigma)) (Cons (Pair
      x x') (Cons (Pair x1 y) sigma)) (Lrs_start x x' x1 y sigma sigma
      (legalRenSwap_id sigma)) (iHAlpha __ __)))
    (\b s1 s2 t1 t2 sigma _ iHAlpha1 _ iHAlpha2 _ _ -> Alpha_app b s1 s2 t1
    t2 (Cons (Pair x x') sigma) (iHAlpha1 __ __) (iHAlpha2 __ __))
    (\r d _ _ -> Alpha_builtin (Cons (Pair x x') r) d) ren t t' x0 __ __

alpha_extend_fresh :: String -> String -> (List (Prod String String)) ->
                      Term0 -> Term0 -> Alpha -> Alpha
alpha_extend_fresh x x' ren t t' ha_t =
  let {tgu = to_GU'' x t} in
  let {t'gu = to_GU'' x' t'} in
  let {
   ht = alpha_trans tgu t t'gu (ctx_id_left ren) ren ren (id_left_trans ren)
          (alpha_extend_ids (ctx_id_left ren) tgu t (ctx_id_left_is_id ren)
            (eq_rec_r (to_GU'' x t)
              (alpha_sym t (to_GU'' x t) Nil Nil Alpha_sym_nil
                (to_GU''__alpha x t)) tgu))
          (alpha_trans t t' t'gu ren (ctx_id_right ren) ren
            (id_right_trans ren) ha_t
            (alpha_extend_ids (ctx_id_right ren) t' t'gu
              (ctx_id_right_is_id ren)
              (eq_rec_r (to_GU'' x' t') (to_GU''__alpha x' t') t'gu)))}
  in
  let {h1 = alpha_extend_fresh_tv x x' ren tgu t'gu ht} in
  alpha_trans t tgu t' (ctx_id_left (Cons (Pair x x') ren)) (Cons (Pair x x')
    ren) (Cons (Pair x x') ren) (id_left_trans (Cons (Pair x x') ren))
    (alpha_extend_ids (ctx_id_left (Cons (Pair x x') ren)) t tgu
      (ctx_id_left_is_id (Cons (Pair x x') ren))
      (eq_rec_r (to_GU'' x t) (\ht0 _ h2 ->
        eq_rec_r (to_GU'' x' t') (\_ _ _ -> to_GU''__alpha x t) t'gu ht0 __
          h2) tgu ht __ h1))
    (alpha_trans tgu t'gu t' (Cons (Pair x x') ren)
      (ctx_id_right (Cons (Pair x x') ren)) (Cons (Pair x x') ren)
      (id_right_trans (Cons (Pair x x') ren)) h1
      (alpha_extend_ids (ctx_id_right (Cons (Pair x x') ren)) t'gu t'
        (ctx_id_right_is_id (Cons (Pair x x') ren))
        (eq_rec_r (to_GU'' x t) (\ht0 _ h2 ->
          eq_rec_r (to_GU'' x' t') (\_ _ _ ->
            alpha_sym t' (to_GU'' x' t') Nil Nil Alpha_sym_nil
              (to_GU''__alpha x' t')) t'gu ht0 __ h2) tgu ht __ h1)))

alpha_ctx_ren_extend_fresh_ftv :: (List (Prod String Term0)) -> (List
                                  (Prod String Term0)) -> String -> String ->
                                  (List (Prod String String)) ->
                                  Coq__UU03b1_CtxSub -> Coq__UU03b1_CtxSub
alpha_ctx_ren_extend_fresh_ftv sigma sigma' x x' ren h__UU03b1_ =
  _UU03b1_CtxSub_rec (\r _ _ -> Alpha_ctx_nil (Cons (Pair x x') r))
    (\r _UU03c3_ _UU03c3_' x0 y t t' _ iHH__UU03b1_ a a0 _ _ ->
    Alpha_ctx_cons (Cons (Pair x x') r) _UU03c3_ _UU03c3_' x0 y t t'
    (iHH__UU03b1_ __ __) (Alpha_var_diff x x' x0 y r a)
    (alpha_extend_fresh x x' r t t' a0)) ren sigma sigma' h__UU03b1_ __ __

alpha_rename_binder_stronger :: String -> String -> Term0 -> Term0 -> Term0
                                -> (List (Prod String String)) -> Term0 ->
                                (List (Prod String String)) -> Alpha -> Alpha
                                -> LegalRenSwap -> NC -> NC -> Alpha
alpha_rename_binder_stronger x y s t t' rt s' rs x0 x1 x2 x3 x4 =
  term_rec (\s0 _ _ h3 _ h2 rs0 h rt0 h0 h1 ->
    case h of {
     Alpha_var x5 y0 sigma x6 ->
      eq_rec_r rs0 (\_ ->
        eq_rec_r s0 (\_ _ ->
          let {b = eqb1 x s0} in
          case b of {
           True ->
            eq_rec_r s0 (\_ h4 ->
              let {b0 = eqb1 y y0} in
              case b0 of {
               True -> eq_rec_r y0 (\_ _ -> h0) y h3 h4;
               False -> false_rec}) x h2 h1;
           False ->
            let {b0 = eqb1 y y0} in
            case b0 of {
             True -> eq_rec_r y0 (\_ _ -> false_rec) y h3 h1;
             False ->
              let {
               h4 = alpha_swap (Tmvar s0) (Tmvar y0) (Cons (Pair x y) rt0)
                      rs0 (lrs_sym (Cons (Pair x y) rt0) rs0 h1) h}
              in
              case h4 of {
               Alpha_var x7 y1 sigma0 x8 ->
                eq_rec_r (Cons (Pair x y) rt0) (\_ ->
                  eq_rec_r s0 (\_ ->
                    eq_rec_r y0 (\h10 ->
                      case h10 of {
                       Alpha_var_refl _ -> false_rec __ __;
                       Alpha_var_cons z w sigma1 ->
                        eq_rec_r x (\_ ->
                          eq_rec_r y (\_ ->
                            eq_rec_r rt0 (\_ ->
                              eq_rec_r s0 (\_ ->
                                eq_rec_r y0
                                  (eq_rec_r s0 (\_ h5 h6 _ h11 ->
                                    eq_rec_r y0 (\_ _ _ _ _ -> false_rec) y
                                      h3 h5 h6 __ h11) x h2 h4 h1 __ h10) y)
                                x) sigma1) w) z __ __ __ __;
                       Alpha_var_diff x9 y2 z w sigma1 x10 ->
                        eq_rec_r x (\_ ->
                          eq_rec_r y (\_ ->
                            eq_rec_r rt0 (\_ ->
                              eq_rec_r s0 (\_ ->
                                eq_rec_r y0 (\_ _ h15 -> Alpha_var s0 y0 rt0
                                  h15) w) z) sigma1) y2) x9 __ __ __ __ __ __
                          x10}) y1) x7) sigma0 __ __ x8;
               Alpha_lam _ _ _ _ _ _ sigma0 x7 ->
                eq_rec_r (Cons (Pair x y) rt0) (\_ -> false_rec) sigma0 __ __
                  x7;
               Alpha_app _ _ _ _ _ sigma0 x7 x8 ->
                eq_rec_r (Cons (Pair x y) rt0) (\_ -> false_rec) sigma0 __ __
                  x7 x8;
               Alpha_builtin r _ ->
                eq_rec_r (Cons (Pair x y) rt0) (\_ -> false_rec) r __ __}}})
          x5) sigma __ __ x6;
     Alpha_lam _ _ _ _ _ _ sigma x5 ->
      eq_rec_r rs0 (\_ -> false_rec) sigma __ __ x5;
     Alpha_app _ _ _ _ _ sigma x5 x6 ->
      eq_rec_r rs0 (\_ -> false_rec) sigma __ __ x5 x6;
     Alpha_builtin r _ -> eq_rec_r rs0 (\_ -> false_rec) r __ __})
    (\uSort s0 k s1 iHs _ t'0 h3 t0 h2 rs0 h rt0 h0 h1 ->
    case h of {
     Alpha_var _ _ sigma x5 -> eq_rec_r rs0 (\_ -> false_rec) sigma __ __ x5;
     Alpha_lam b x5 y0 a s2 s3 sigma x6 ->
      eq_rec_r rs0 (\_ ->
        eq_rec_r uSort (\_ ->
          eq_rec_r s0 (\_ ->
            eq_rec_r k (\_ ->
              eq_rec_r s1 (\_ h10 -> Alpha_lam uSort s0 y0 k (sub x t0 s1)
                (sub y t'0 s3) rt0
                (iHs s3 t'0 (nc_lam uSort y0 s3 k (Cons (Pair y t'0) Nil) h3)
                  t0 (nc_lam uSort s0 s1 k (Cons (Pair x t0) Nil) h2) (Cons
                  (Pair s0 y0) rs0) h10 (Cons (Pair s0 y0) rt0)
                  (alpha_extend_vacuous_ftv s0 y0 t0 t'0 rt0 h0)
                  (lrs_trans (Cons (Pair x y) (Cons (Pair s0 y0) rt0)) (Cons
                    (Pair s0 y0) (Cons (Pair x y) rt0)) (Cons (Pair s0 y0)
                    rs0) (Lrs_start x y s0 y0 rt0 rt0 (legalRenSwap_id rt0))
                    (Lrs_cons s0 y0 (Cons (Pair x y) rt0) rs0 h1)))) s2) a)
            x5) b __ __ __) sigma __ __ x6;
     Alpha_app _ _ _ _ _ sigma x5 x6 ->
      eq_rec_r rs0 (\_ -> false_rec) sigma __ __ x5 x6;
     Alpha_builtin r _ -> eq_rec_r rs0 (\_ -> false_rec) r __ __})
    (\bSort s1 iHs1 s2 iHs2 _ t'0 h3 t0 h2 rs0 h rt0 h0 h1 ->
    case h of {
     Alpha_var _ _ sigma x5 -> eq_rec_r rs0 (\_ -> false_rec) sigma __ __ x5;
     Alpha_lam _ _ _ _ _ _ sigma x5 ->
      eq_rec_r rs0 (\_ -> false_rec) sigma __ __ x5;
     Alpha_app b s3 s4 t1 t2 sigma x5 x6 ->
      eq_rec_r rs0 (\_ ->
        eq_rec_r bSort (\_ ->
          eq_rec_r s1 (\_ ->
            eq_rec_r s2 (\_ h9 h10 -> Alpha_app bSort (sub x t0 s1)
              (sub y t'0 s4) (sub x t0 s2) (sub y t'0 t2) rt0
              (iHs1 s4 t'0 (nc_app_l bSort s4 t2 (Cons (Pair y t'0) Nil) h3)
                t0 (nc_app_l bSort s1 s2 (Cons (Pair x t0) Nil) h2) rs0 h9
                rt0 h0 h1)
              (iHs2 t2 t'0 (nc_app_r bSort s4 t2 (Cons (Pair y t'0) Nil) h3)
                t0 (nc_app_r bSort s1 s2 (Cons (Pair x t0) Nil) h2) rs0 h10
                rt0 h0 h1)) t1) s3) b __ __) sigma __ __ x5 x6;
     Alpha_builtin r _ -> eq_rec_r rs0 (\_ -> false_rec) r __ __})
    (\d _ _ _ _ _ rs0 h rt0 _ _ ->
    case h of {
     Alpha_var _ _ sigma x5 -> eq_rec_r rs0 (\_ -> false_rec) sigma __ __ x5;
     Alpha_lam _ _ _ _ _ _ sigma x5 ->
      eq_rec_r rs0 (\_ -> false_rec) sigma __ __ x5;
     Alpha_app _ _ _ _ _ sigma x5 x6 ->
      eq_rec_r rs0 (\_ -> false_rec) sigma __ __ x5 x6;
     Alpha_builtin r d0 ->
      eq_rec_r rs0 (\_ -> eq_rec_r d (\_ -> Alpha_builtin rt0 d) d0) r __ __})
    s s' t' x4 t x3 rs x0 rt x1 x2

step_naive_preserves_alpha2 :: Term0 -> Term0 -> Term0 -> (List
                               (Prod String String)) -> GU -> GU -> Alpha ->
                               Step_naive -> SigT Term0
                               (Prod Step_naive Alpha)
step_naive_preserves_alpha2 s t s' r x x0 x1 x2 =
  step_naive_rec (\x3 a s0 t0 h _ h0 r0 h1 ->
    case h1 of {
     Alpha_var _ _ sigma x4 -> eq_rec_r r0 (\_ -> false_rec) sigma __ __ x4;
     Alpha_lam _ _ _ _ _ _ sigma x4 ->
      eq_rec_r r0 (\_ -> false_rec) sigma __ __ x4;
     Alpha_app b s1 _ t1 t2 sigma x4 x5 ->
      eq_rec_r r0 (\_ ->
        eq_rec_r App (\_ ->
          eq_rec_r (Tmlam Lam x3 a s0) (\_ ->
            eq_rec_r t0 (\_ h7 h8 ->
              case h7 of {
               Alpha_var _ _ sigma0 x6 ->
                eq_rec_r r0 (\_ -> false_rec) sigma0 __ __ x6;
               Alpha_lam b0 x6 y a0 s2 s3 sigma0 x7 ->
                eq_rec_r r0 (\_ ->
                  eq_rec_r Lam (\_ ->
                    eq_rec_r x3 (\_ ->
                      eq_rec_r a (\_ ->
                        eq_rec_r s0 (\_ h10 -> ExistT (sub y t2 s3) (Pair
                          (Step_beta0 y a s3 t2)
                          (alpha_rename_binder_stronger x3 y s0 t0 t2 r0 s3
                            (Cons (Pair x3 y) r0) h10 h8 (Lrs_cons x3 y r0 r0
                            (legalRenSwap_id r0))
                            (gu_applam_to_nc App Lam s0 t0 x3 a h)
                            (gu_applam_to_nc App Lam s3 t2 y a h0)))) s2) a0)
                      x6) b0 __ __ __) sigma0 __ __ x7;
               Alpha_app _ _ _ _ _ sigma0 x6 x7 ->
                eq_rec_r r0 (\_ -> false_rec) sigma0 __ __ x6 x7;
               Alpha_builtin r1 _ -> eq_rec_r r0 (\_ -> false_rec) r1 __ __})
              t1) s1) b __ __) sigma __ __ x4 x5;
     Alpha_builtin r1 _ -> eq_rec_r r0 (\_ -> false_rec) r1 __ __})
    (\b s1 s2 t0 _ iHstep_naive h _ h0 r0 h1 ->
    case h1 of {
     Alpha_var _ _ sigma x3 -> eq_rec_r r0 (\_ -> false_rec) sigma __ __ x3;
     Alpha_lam _ _ _ _ _ _ sigma x3 ->
      eq_rec_r r0 (\_ -> false_rec) sigma __ __ x3;
     Alpha_app b0 s3 s4 t1 t2 sigma x3 x4 ->
      eq_rec_r r0 (\_ ->
        eq_rec_r b (\_ ->
          eq_rec_r s1 (\_ ->
            eq_rec_r t0 (\_ h8 h9 ->
              let {
               h3 = iHstep_naive (gu_app_l b s1 t0 h) s4
                      (gu_app_l b s4 t2 h0) r0 h8}
              in
              case h3 of {
               ExistT x5 p ->
                case p of {
                 Pair s0 a -> ExistT (Tmapp b x5 t2) (Pair (Step_appL0 b s4
                  x5 t2 s0) (Alpha_app b s2 x5 t0 t2 r0 a h9))}}) t1) s3) b0
          __ __) sigma __ __ x3 x4;
     Alpha_builtin r1 _ -> eq_rec_r r0 (\_ -> false_rec) r1 __ __})
    (\b s0 t1 t2 _ iHstep_naive h _ h0 r0 h1 ->
    case h1 of {
     Alpha_var _ _ sigma x3 -> eq_rec_r r0 (\_ -> false_rec) sigma __ __ x3;
     Alpha_lam _ _ _ _ _ _ sigma x3 ->
      eq_rec_r r0 (\_ -> false_rec) sigma __ __ x3;
     Alpha_app b0 s1 s2 t3 t4 sigma x3 x4 ->
      eq_rec_r r0 (\_ ->
        eq_rec_r b (\_ ->
          eq_rec_r s0 (\_ ->
            eq_rec_r t1 (\_ h8 h9 ->
              let {
               h3 = iHstep_naive (gu_app_r b s0 t1 h) t4
                      (gu_app_r b s2 t4 h0) r0 h9}
              in
              case h3 of {
               ExistT x5 p ->
                case p of {
                 Pair s3 a -> ExistT (Tmapp b s2 x5) (Pair (Step_appR0 b s2
                  t4 x5 s3) (Alpha_app b s0 s2 t2 x5 r0 h8 a))}}) t3) s1) b0
          __ __) sigma __ __ x3 x4;
     Alpha_builtin r1 _ -> eq_rec_r r0 (\_ -> false_rec) r1 __ __})
    (\b x3 a s1 s2 _ iHstep_naive h _ h0 r0 h1 ->
    case h1 of {
     Alpha_var _ _ sigma x4 -> eq_rec_r r0 (\_ -> false_rec) sigma __ __ x4;
     Alpha_lam b0 x4 y a0 s3 s4 sigma x5 ->
      eq_rec_r r0 (\_ ->
        eq_rec_r b (\_ ->
          eq_rec_r x3 (\_ ->
            eq_rec_r a (\_ ->
              eq_rec_r s1 (\_ h9 ->
                let {
                 h2 = iHstep_naive (gu_lam b x3 a s1 h) s4
                        (gu_lam b y a s4 h0) (Cons (Pair x3 y) r0) h9}
                in
                case h2 of {
                 ExistT x6 p ->
                  case p of {
                   Pair s0 a1 -> ExistT (Tmlam b y a x6) (Pair (Step_abs0 b y
                    a s4 x6 s0) (Alpha_lam b x3 y a s2 x6 r0 a1))}}) s3) a0)
            x4) b0 __ __ __) sigma __ __ x5;
     Alpha_app _ _ _ _ _ sigma x4 x5 ->
      eq_rec_r r0 (\_ -> false_rec) sigma __ __ x4 x5;
     Alpha_builtin r1 _ -> eq_rec_r r0 (\_ -> false_rec) r1 __ __}) s t x2 x
    s' x0 r x1

data Step_gu_naive =
   Step_gu_naive_intro Term0 Term0 Term0 Alpha GU Step_naive

data Sn x e =
   SNI (x -> e -> Sn x e)

sn_rect :: (a1 -> (a1 -> a2 -> Sn a1 a2) -> (a1 -> a2 -> a3) -> a3) -> a1 ->
           (Sn a1 a2) -> a3
sn_rect f0 x s =
  case s of {
   SNI s0 -> f0 x s0 (\y y0 -> sn_rect f0 y (s0 y y0))}

sn_rec :: (a1 -> (a1 -> a2 -> Sn a1 a2) -> (a1 -> a2 -> a3) -> a3) -> a1 ->
          (Sn a1 a2) -> a3
sn_rec =
  sn_rect

step_gu_naive_preserves_alpha :: Term0 -> Term0 -> Term0 -> (List
                                 (Prod String String)) -> Alpha ->
                                 Step_gu_naive -> SigT Term0
                                 (Prod Step_gu_naive Alpha)
step_gu_naive_preserves_alpha s s' t r x x0 =
  case x0 of {
   Step_gu_naive_intro s0 s'0 t0 x1 x2 x3 ->
    eq_rec_r s (\_ ->
      eq_rec_r s' (\h1 h2 h3 ->
        let {
         h4 = step_naive_preserves_alpha2 s'0 s' (to_GU t) r h2 (to_GU__GU t)
                (alpha_trans s'0 s (to_GU t) (ctx_id_left r) r r
                  (id_left_trans r)
                  (alpha_extend_ids (ctx_id_left r) s'0 s
                    (ctx_id_left_is_id r)
                    (alpha_sym s s'0 Nil Nil Alpha_sym_nil h1))
                  (alpha_trans s t (to_GU t) r (ctx_id_right r) r
                    (id_right_trans r) x
                    (alpha_extend_ids (ctx_id_right r) t (to_GU t)
                      (ctx_id_right_is_id r) (to_GU__alpha t)))) h3}
        in
        case h4 of {
         ExistT x4 p ->
          case p of {
           Pair s1 a -> ExistT x4 (Pair (Step_gu_naive_intro t (to_GU t) x4
            (to_GU__alpha t) (to_GU__GU t) s1) a)}}) t0) s0 __ x1 x2 x3}

data Red_gu_na =
   Red_gu_na_star Term0 Term0 Term0 Step_gu_naive Red_gu_na
 | Red_gu_na_nil Term0

red_gu_na_rect :: (Term0 -> Term0 -> Term0 -> Step_gu_naive -> Red_gu_na ->
                  a1 -> a1) -> (Term0 -> a1) -> Term0 -> Term0 -> Red_gu_na
                  -> a1
red_gu_na_rect f0 f1 _ _ r =
  case r of {
   Red_gu_na_star s t t' s0 r0 ->
    f0 s t t' s0 r0 (red_gu_na_rect f0 f1 t t' r0);
   Red_gu_na_nil s -> f1 s}

red_gu_na_rec :: (Term0 -> Term0 -> Term0 -> Step_gu_naive -> Red_gu_na -> a1
                 -> a1) -> (Term0 -> a1) -> Term0 -> Term0 -> Red_gu_na -> a1
red_gu_na_rec =
  red_gu_na_rect

red_gu_naive_preserves_alpha :: Term0 -> Term0 -> Term0 -> (List
                                (Prod String String)) -> Alpha -> Red_gu_na
                                -> SigT Term0 (Prod Red_gu_na Alpha)
red_gu_naive_preserves_alpha s s' t r x x0 =
  red_gu_na_rec (\s0 t0 _ s1 _ iHred_gu_na t1 r0 h ->
    let {s2 = step_gu_naive_preserves_alpha s0 t0 t1 r0 h s1} in
    case s2 of {
     ExistT x1 p ->
      case p of {
       Pair s3 a ->
        let {iHred_gu_na0 = iHred_gu_na x1 r0 a} in
        case iHred_gu_na0 of {
         ExistT x2 p0 ->
          case p0 of {
           Pair r1 a0 -> ExistT x2 (Pair (Red_gu_na_star t1 x1 x2 s3 r1) a0)}}}})
    (\_ t0 _ h -> ExistT t0 (Pair (Red_gu_na_nil t0) h)) s s' x0 t r x

_UU03b1__preserves_SN_R :: Term0 -> Term0 -> (List (Prod String String)) ->
                           Alpha -> (Sn Term0 Step_gu_naive) -> Sn Term0
                           Step_gu_naive
_UU03b1__preserves_SN_R s s' r h_UU03b1_ hsn =
  sn_rect (\x _ x0 r0 s'0 h_UU03b1_0 -> SNI (\y1 hstep ->
    let {
     h = step_gu_naive_preserves_alpha s'0 y1 x (sym_alpha_ctx r0)
           (alpha_sym x s'0 (sym_alpha_ctx (sym_alpha_ctx r0))
             (sym_alpha_ctx r0)
             (sym_alpha_ctx_left_is_sym (sym_alpha_ctx r0))
             (alpha_sym s'0 x (sym_alpha_ctx r0)
               (sym_alpha_ctx (sym_alpha_ctx r0))
               (sym_alpha_ctx_is_sym (sym_alpha_ctx r0))
               (alpha_sym x s'0 r0 (sym_alpha_ctx r0)
                 (sym_alpha_ctx_is_sym r0) h_UU03b1_0))) hstep}
    in
    case h of {
     ExistT x1 p ->
      case p of {
       Pair s0 a ->
        x0 x1 s0 r0 y1
          (alpha_sym y1 x1 (sym_alpha_ctx r0) r0
            (sym_alpha_ctx_left_is_sym r0) a)}})) s hsn r s' h_UU03b1_

sn_preimage__UU03b1_' :: (Term0 -> Term0) -> Term0 -> Term0 -> (Term0 ->
                         Term0 -> Step_gu_naive -> SigT Term0
                         (Prod Step_gu_naive Alpha)) -> (Sn Term0
                         Step_gu_naive) -> Alpha -> Sn Term0 Step_gu_naive
sn_preimage__UU03b1_' h x v a b halpha =
  sn_rect (\x0 _ x1 x2 h0 a0 eqn -> SNI (\y c ->
    let {c0 = a0 x2 y c} in
    let {
     h1 = case c0 of {
           ExistT x3 p ->
            case p of {
             Pair s a1 ->
              let {eqn0 = alpha_sym x0 (h0 x2) Nil Nil Alpha_sym_nil eqn} in
              let {
               ehy = step_gu_naive_preserves_alpha (h0 x2) x3 x0 Nil eqn0 s}
              in
              case ehy of {
               ExistT x4 p0 ->
                case p0 of {
                 Pair s0 a2 -> ExistT x4 (Pair s0
                  (alpha_trans x4 x3 (h0 y) Nil Nil Nil Alpha_trans_nil
                    (alpha_sym x3 x4 Nil Nil Alpha_sym_nil a2) a1))}}}}}
    in
    case h1 of {
     ExistT x3 p -> case p of {
                     Pair s a1 -> x1 x3 s y h0 a0 a1}})) v b x h a halpha

sn_preimage__UU03b1_ :: (Term0 -> Term0) -> Term0 -> (Term0 -> Term0 ->
                        Step_gu_naive -> SigT Term0
                        (Prod Step_gu_naive Alpha)) -> (Sn Term0
                        Step_gu_naive) -> Sn Term0 Step_gu_naive
sn_preimage__UU03b1_ h x a b =
  sn_preimage__UU03b1_' h x (h x) a b (alpha_refl (h x) Nil Alpha_refl_nil)

step_gu_naive_app_l :: BSort -> Term0 -> Term0 -> Term0 -> Step_gu_naive ->
                       SigT Term0
                       (Prod Alpha (SigT Term0 (Prod Alpha Step_gu_naive)))
step_gu_naive_app_l b s1 s2 t1 x =
  let {app0 = to_GU (Tmapp b s1 s2)} in
  let {heqapp = to_GU_app_unfold b s1 s2 app0} in
  case heqapp of {
   ExistT x0 s ->
    case s of {
     ExistT x1 p ->
      case p of {
       Pair p0 a ->
        case p0 of {
         Pair _ a0 ->
          case x of {
           Step_gu_naive_intro s0 s' t x2 x3 x4 ->
            eq_rec_r s1 (\_ ->
              eq_rec_r t1 (\h0 h1 h2 ->
                eq_rec_r (Tmapp b x0 x1) (\_ ->
                  let {
                   h3 = step_naive_preserves_alpha2 s' t1 x0 Nil h1
                          (gu_app_l b x0 x1
                            (eq_rec_r (to_GU (Tmapp b s1 s2))
                              (to_GU__GU (Tmapp b s1 s2)) (Tmapp b x0 x1)))
                          (alpha_extend_ids Nil s' x0 Id_ctx_nil
                            (alpha_extend_ids Nil s' x0 Id_ctx_nil
                              (alpha_trans s' s1 x0 Nil Nil Nil
                                Alpha_trans_nil
                                (alpha_sym s1 s' (sym_alpha_ctx Nil) Nil
                                  (sym_alpha_ctx_left_is_sym Nil) h0) a0)))
                          h2}
                  in
                  case h3 of {
                   ExistT x5 p1 ->
                    case p1 of {
                     Pair s3 a1 -> ExistT x5 (Pair a1 (ExistT x1 (Pair a
                      (Step_gu_naive_intro (Tmapp b s1 s2) (Tmapp b x0 x1)
                      (Tmapp b x5 x1)
                      (let {_evar_0_ = to_GU__alpha (Tmapp b s1 s2)} in
                       eq_rec_r (to_GU (Tmapp b s1 s2)) _evar_0_ (Tmapp b x0
                         x1))
                      (let {_evar_0_ = to_GU__GU (Tmapp b s1 s2)} in
                       eq_rec_r (to_GU (Tmapp b s1 s2)) _evar_0_ (Tmapp b x0
                         x1)) (Step_appL0 b x0 x5 x1 s3)))))}}) app0 __) t)
              s0 __ x2 x3 x4}}}}}

sn_ty_fun :: BSort -> Term0 -> Term0 -> (Sn Term0 Step_gu_naive) -> (Sn 
             Term0 Step_gu_naive) -> Sn Term0 Step_gu_naive
sn_ty_fun b s t hSN_s hSN_t =
  sn_rect (\x _ x0 t0 _top_assumption_ ->
    let {
     _evar_0_ = \x1 s0 x2 -> SNI (\_ x3 ->
      case x3 of {
       Step_gu_naive_intro _ _ _ x4 x5 x6 ->
        case x4 of {
         Alpha_app _ _ s2 _ t2 _ x7 x8 ->
          case x6 of {
           Step_appL0 _ _ s3 _ x9 ->
            let {
             h7 = step_naive_preserves_alpha2 s2 s3 (to_GU x) Nil
                    (gu_app_l b s2 t2 x5) (to_GU__GU x)
                    (alpha_trans s2 x (to_GU x) Nil Nil Nil Alpha_trans_nil
                      (alpha_extend_ids Nil s2 x Id_ctx_nil
                        (alpha_extend_ids Nil s2 x Id_ctx_nil
                          (alpha_extend_ids Nil s2 x Id_ctx_nil
                            (alpha_sym x s2 (sym_alpha_ctx Nil) Nil
                              (sym_alpha_ctx_left_is_sym Nil) x7))))
                      (to_GU__alpha x)) x9}
            in
            case h7 of {
             ExistT x10 p ->
              case p of {
               Pair s1 a ->
                _UU03b1__preserves_SN_R (Tmapp b x10 t2) (Tmapp b s3 t2) Nil
                  (alpha_extend_ids Nil (Tmapp b x10 t2) (Tmapp b s3 t2)
                    Id_ctx_nil (Alpha_app b x10 s3 t2 t2 Nil
                    (alpha_sym s3 x10 (sym_alpha_ctx Nil) Nil
                      (sym_alpha_ctx_left_is_sym Nil) a)
                    (alpha_refl t2 Nil Alpha_refl_nil)))
                  (x0 x10 (Step_gu_naive_intro x (to_GU x) x10
                    (to_GU__alpha x) (to_GU__GU x) s1) t2
                    (_UU03b1__preserves_SN_R x1 t2 Nil x8 (SNI s0)))}};
           Step_appR0 _ _ _ t3 x9 ->
            let {
             h7 = step_naive_preserves_alpha2 t2 t3 (to_GU x1) Nil
                    (gu_app_r b s2 t2 x5) (to_GU__GU x1)
                    (alpha_trans t2 x1 (to_GU x1) Nil Nil Nil Alpha_trans_nil
                      (alpha_extend_ids Nil t2 x1 Id_ctx_nil
                        (alpha_extend_ids Nil t2 x1 Id_ctx_nil
                          (alpha_extend_ids Nil t2 x1 Id_ctx_nil
                            (alpha_sym x1 t2 (sym_alpha_ctx Nil) Nil
                              (sym_alpha_ctx_left_is_sym Nil) x8))))
                      (to_GU__alpha x1)) x9}
            in
            case h7 of {
             ExistT x10 p ->
              case p of {
               Pair s1 a ->
                _UU03b1__preserves_SN_R (Tmapp b x x10) (Tmapp b s2 t3) Nil
                  (alpha_extend_ids Nil (Tmapp b x x10) (Tmapp b s2 t3)
                    Id_ctx_nil
                    (alpha_extend_ids Nil (Tmapp b x x10) (Tmapp b s2 t3)
                      Id_ctx_nil (Alpha_app b x s2 x10 t3 Nil x7
                      (alpha_sym t3 x10 (sym_alpha_ctx Nil) Nil
                        (sym_alpha_ctx_left_is_sym Nil) a))))
                  (x2 x10 (Step_gu_naive_intro x1 (to_GU x1) x10
                    (to_GU__alpha x1) (to_GU__GU x1) s1))}};
           _ -> Prelude.error "absurd case"};
         _ -> Prelude.error "absurd case"}})}
    in
    sn_rect _evar_0_ t0 _top_assumption_) s hSN_s t hSN_t

sn_ty_forall :: USort -> String -> Kind -> Term0 -> (Sn Term0 Step_gu_naive)
                -> Sn Term0 Step_gu_naive
sn_ty_forall b x k t hSN_T =
  sn_rect (\x0 _ x1 -> SNI (\_ hstep ->
    case hstep of {
     Step_gu_naive_intro _ _ _ x2 x3 x4 ->
      case x2 of {
       Alpha_lam _ _ y _ _ s2 _ x5 ->
        case x4 of {
         Step_abs0 _ _ _ _ s3 x6 ->
          let {
           h7 = step_naive_preserves_alpha2 s2 s3 (to_GU x0) (Cons (Pair y x)
                  Nil) (gu_lam b y k s2 x3) (to_GU__GU x0)
                  (alpha_trans s2 x0 (to_GU x0) (Cons (Pair y x) Nil) (Cons
                    (Pair x x) Nil) (Cons (Pair y x) Nil) (Alpha_trans_cons y
                    x x Nil Nil Nil Alpha_trans_nil)
                    (alpha_sym x0 s2 (sym_alpha_ctx (Cons (Pair y x) Nil))
                      (Cons (Pair y x) Nil)
                      (sym_alpha_ctx_left_is_sym (Cons (Pair y x) Nil)) x5)
                    (alpha_extend_ids (Cons (Pair x x) Nil) x0 (to_GU x0)
                      (Id_ctx_cons x Nil Id_ctx_nil) (to_GU__alpha x0))) x6}
          in
          case h7 of {
           ExistT x7 p ->
            case p of {
             Pair s a ->
              let {
               h2 = Pair (Alpha_lam b y x k s3 x7 Nil a) (Step_gu_naive_intro
                x0 (to_GU x0) x7 (to_GU__alpha x0) (to_GU__GU x0) s)}
              in
              case h2 of {
               Pair _ s0 ->
                _UU03b1__preserves_SN_R (Tmlam b x k x7) (Tmlam b y k s3) Nil
                  (Alpha_lam b x y k x7 s3 Nil
                  (alpha_sym s3 x7 (sym_alpha_ctx (Cons (Pair x y) Nil))
                    (Cons (Pair x y) Nil)
                    (sym_alpha_ctx_left_is_sym (Cons (Pair x y) Nil)) a))
                  (x1 x7 s0)}}};
         _ -> Prelude.error "absurd case"};
       _ -> Prelude.error "absurd case"}})) t hSN_T

sn_closedL :: BSort -> Term0 -> Term0 -> (Sn Term0 Step_gu_naive) -> Sn 
              Term0 Step_gu_naive
sn_closedL b t s =
  sn_preimage__UU03b1_ (\x -> Tmapp b x t) s (\x y x0 ->
    let {h = step_gu_naive_app_l b x t y x0} in
    case h of {
     ExistT x1 p ->
      case p of {
       Pair a s0 ->
        case s0 of {
         ExistT x2 p0 ->
          case p0 of {
           Pair a0 s1 -> ExistT (Tmapp b x1 x2) (Pair s1 (Alpha_app b x1 y x2
            t Nil
            (alpha_sym y x1 (sym_alpha_ctx Nil) Nil
              (sym_alpha_ctx_left_is_sym Nil) a)
            (alpha_sym t x2 (sym_alpha_ctx Nil) Nil
              (sym_alpha_ctx_left_is_sym Nil) a0)))}}}})

subs_preserves_alpha__UU03c3__R :: Term0 -> (List (Prod String String)) ->
                                   Term0 -> (List (Prod String Term0)) ->
                                   (List (Prod String Term0)) -> NC -> NC ->
                                   Alpha -> Coq__UU03b1_CtxSub -> Alpha
subs_preserves_alpha__UU03c3__R s =
  term_rec (\s0 r _ sigma sigma' _ _ x x0 ->
    case x of {
     Alpha_var x1 y sigma0 x2 ->
      eq_rec_r r (\_ ->
        eq_rec_r s0 (\_ h5 ->
          let {o = lookup s0 sigma} in
          case o of {
           Some t ->
            let {s1 = alpha_ctx_right_ex r sigma sigma' s0 y t x0 h5} in
            case s1 of {
             ExistT x3 p ->
              case p of {
               Pair _ a -> eq_rec_r (Some x3) a (lookup y sigma')}};
           None ->
            let {_evar_0_ = Alpha_var s0 y r h5} in
            eq_rec_r None _evar_0_ (lookup y sigma')}) x1) sigma0 __ __ x2;
     Alpha_lam _ _ _ _ _ _ sigma0 x1 ->
      eq_rec_r r (\_ -> false_rec) sigma0 __ __ x1;
     Alpha_app _ _ _ _ _ sigma0 x1 x2 ->
      eq_rec_r r (\_ -> false_rec) sigma0 __ __ x1 x2;
     Alpha_builtin r0 _ -> eq_rec_r r (\_ -> false_rec) r0 __ __})
    (\uSort s0 k s1 iHs r _ sigma sigma' x x0 x1 x2 ->
    case x1 of {
     Alpha_var _ _ sigma0 x3 -> eq_rec_r r (\_ -> false_rec) sigma0 __ __ x3;
     Alpha_lam b x3 y a s2 s3 sigma0 x4 ->
      eq_rec_r r (\_ ->
        eq_rec_r uSort (\_ ->
          eq_rec_r s0 (\_ ->
            eq_rec_r k (\_ ->
              eq_rec_r s1 (\_ h9 -> Alpha_lam uSort s0 y k (psubs sigma s1)
                (psubs sigma' s3) r
                (iHs (Cons (Pair s0 y) r) s3 sigma sigma'
                  (nc_lam uSort s0 s1 k sigma x)
                  (nc_lam uSort y s3 k sigma' x0) h9
                  (alpha_ctx_ren_extend_fresh_ftv sigma sigma' s0 y r x2)))
                s2) a) x3) b __ __ __) sigma0 __ __ x4;
     Alpha_app _ _ _ _ _ sigma0 x3 x4 ->
      eq_rec_r r (\_ -> false_rec) sigma0 __ __ x3 x4;
     Alpha_builtin r0 _ -> eq_rec_r r (\_ -> false_rec) r0 __ __})
    (\bSort s1 iHs1 s2 iHs2 r _ sigma sigma' x x0 x1 x2 ->
    case x1 of {
     Alpha_var _ _ sigma0 x3 -> eq_rec_r r (\_ -> false_rec) sigma0 __ __ x3;
     Alpha_lam _ _ _ _ _ _ sigma0 x3 ->
      eq_rec_r r (\_ -> false_rec) sigma0 __ __ x3;
     Alpha_app b s3 s4 t1 t2 sigma0 x3 x4 ->
      eq_rec_r r (\_ ->
        eq_rec_r bSort (\_ ->
          eq_rec_r s1 (\_ ->
            eq_rec_r s2 (\_ h8 h9 -> Alpha_app bSort (psubs sigma s1)
              (psubs sigma' s4) (psubs sigma s2) (psubs sigma' t2) r
              (iHs1 r s4 sigma sigma' (nc_app_l bSort s1 s2 sigma x)
                (nc_app_l bSort s4 t2 sigma' x0) h8 x2)
              (iHs2 r t2 sigma sigma' (nc_app_r bSort s1 s2 sigma x)
                (nc_app_r bSort s4 t2 sigma' x0) h9 x2)) t1) s3) b __ __)
        sigma0 __ __ x3 x4;
     Alpha_builtin r0 _ -> eq_rec_r r (\_ -> false_rec) r0 __ __})
    (\d r _ _ _ _ _ x _ ->
    case x of {
     Alpha_var _ _ sigma x0 -> eq_rec_r r (\_ -> false_rec) sigma __ __ x0;
     Alpha_lam _ _ _ _ _ _ sigma x0 ->
      eq_rec_r r (\_ -> false_rec) sigma __ __ x0;
     Alpha_app _ _ _ _ _ sigma x0 x1 ->
      eq_rec_r r (\_ -> false_rec) sigma __ __ x0 x1;
     Alpha_builtin r0 d0 ->
      eq_rec_r r (\_ -> eq_rec_r d (\_ -> Alpha_builtin r d) d0) r0 __ __}) s

data ParSeq =
   ParSeq_nil
 | ParSeq_cons String Term0 (List (Prod String Term0)) ParSeq

id_subst :: (List (Prod String Kind)) -> List (Prod String Term0)
id_subst e =
  case e of {
   Nil -> Nil;
   Cons p e' ->
    case p of {
     Pair x _ -> Cons (Pair x (Tmvar x)) (id_subst e')}}

id_subst_is_IdSubst :: (List (Prod String Kind)) -> IdSubst
id_subst_is_IdSubst e =
  list_rec Id_subst_nil (\a e0 iHE ->
    case a of {
     Pair s _ -> Id_subst_cons s (id_subst e0) iHE}) e

commute_sub_naive :: (List (Prod String String)) -> String -> Term0 -> Term0
                     -> (List (Prod String Term0)) -> (List
                     (Prod String Term0)) -> Term0 -> Alpha ->
                     Coq__UU03b1_CtxSub -> NC -> NC -> NC -> NC -> NC ->
                     Alpha
commute_sub_naive r x s t sigma sigma' xtsAlpha x0 x1 x2 x3 x4 x5 x6 =
  term_rec (\s0 h4 h5 h7 r0 h0 xtsAlpha0 h h3 ->
    let {b = eqb1 x s0} in
    case b of {
     True ->
      eq_rec_r s0 (\_ _ _ _ h1 ->
        let {
         _evar_0_ = \h2 ->
          let {s1 = in_dec string_dec s0 (map fst sigma)} in
          case s1 of {
           Left -> false_rec;
           Right ->
            let {
             _evar_0_ = let {
                         _evar_0_ = subs_preserves_alpha__UU03c3__R t r0
                                      xtsAlpha0 sigma sigma' x5 h3 h2 h0}
                        in
                        eq_rec_r True _evar_0_ (eqb1 s0 s0)}
            in
            eq_rec_r (Tmvar s0) _evar_0_ (psubs sigma (Tmvar s0))}}
        in
        eq_rec_r True _evar_0_ (eqb1 s0 s0) h1) x __ __ h4 h7 h;
     False ->
      let {
       _evar_0_ = \h1 ->
        case h1 of {
         Alpha_var x7 y sigma0 x8 ->
          eq_rec_r r0 (\_ ->
            eq_rec_r s0 (\_ _ ->
              let {s1 = in_dec string_dec s0 (map fst sigma)} in
              case s1 of {
               Left ->
                let {
                 _evar_0_ = subs_preserves_alpha__UU03c3__R (Tmvar s0) r0
                              (Tmvar y) sigma sigma' h5 h3 h1 h0}
                in
                eq_rec_r (psubs sigma (Tmvar s0)) _evar_0_
                  (sub x (psubs sigma t) (psubs sigma (Tmvar s0)));
               Right ->
                let {
                 _evar_0_ = let {
                             _evar_0_ = subs_preserves_alpha__UU03c3__R
                                          (Tmvar s0) r0 (Tmvar y) sigma
                                          sigma' h5 h3 h1 h0}
                            in
                            eq_rec_r False _evar_0_ (eqb1 x s0)}
                in
                eq_rec_r (Tmvar s0) _evar_0_ (psubs sigma (Tmvar s0))}) x7)
            sigma0 __ __ x8;
         Alpha_lam _ _ _ _ _ _ sigma0 x7 ->
          eq_rec_r r0 (\_ -> false_rec) sigma0 __ __ x7;
         Alpha_app _ _ _ _ _ sigma0 x7 x8 ->
          eq_rec_r r0 (\_ -> false_rec) sigma0 __ __ x7 x8;
         Alpha_builtin r1 _ -> eq_rec_r r0 (\_ -> false_rec) r1 __ __}}
      in
      eq_rec_r False _evar_0_ (eqb1 x s0) h})
    (\uSort s0 k s1 iHs h4 h5 h7 r0 h0 _ h h3 ->
    case h of {
     Alpha_var _ _ sigma0 x7 -> eq_rec_r r0 (\_ -> false_rec) sigma0 __ __ x7;
     Alpha_lam b x7 y a s2 s3 sigma0 x8 ->
      eq_rec_r r0 (\_ ->
        eq_rec_r uSort (\_ ->
          eq_rec_r s0 (\_ ->
            eq_rec_r k (\_ ->
              eq_rec_r (sub x t s1) (\_ h14 -> Alpha_lam uSort s0 y k
                (let {
                  sub0 x9 u t0 =
                    case t0 of {
                     Tmvar y0 ->
                      case eqb1 x9 y0 of {
                       True -> u;
                       False -> Tmvar y0};
                     Tmlam b0 y0 k1 t' -> Tmlam b0 y0 k1 (sub0 x9 u t');
                     Tmapp b0 t1 t2 -> Tmapp b0 (sub0 x9 u t1) (sub0 x9 u t2);
                     Tmbuiltin d -> Tmbuiltin d}}
                 in sub0 x (psubs sigma t)
                      (let {
                        psubs0 sigma1 t0 =
                          case t0 of {
                           Tmvar x9 ->
                            case lookup x9 sigma1 of {
                             Some t1 -> t1;
                             None -> Tmvar x9};
                           Tmlam b0 x9 a0 s4 -> Tmlam b0 x9 a0
                            (psubs0 sigma1 s4);
                           Tmapp b0 s4 t1 -> Tmapp b0 (psubs0 sigma1 s4)
                            (psubs0 sigma1 t1);
                           Tmbuiltin d -> Tmbuiltin d}}
                       in psubs0 sigma s1))
                (let {
                  psubs0 sigma1 t0 =
                    case t0 of {
                     Tmvar x9 ->
                      case lookup x9 sigma1 of {
                       Some t1 -> t1;
                       None -> Tmvar x9};
                     Tmlam b0 x9 a0 s4 -> Tmlam b0 x9 a0 (psubs0 sigma1 s4);
                     Tmapp b0 s4 t1 -> Tmapp b0 (psubs0 sigma1 s4)
                      (psubs0 sigma1 t1);
                     Tmbuiltin d -> Tmbuiltin d}}
                 in psubs0 sigma' s3) r0
                (iHs (nc_lam uSort s0 s1 k (Cons (Pair x t) Nil) h4)
                  (nc_lam uSort s0 s1 k sigma h5)
                  (nc_lam uSort s0 (psubs sigma s1) k (Cons (Pair x
                    (psubs sigma t)) Nil) h7) (Cons (Pair s0 y) r0)
                  (alpha_ctx_ren_extend_fresh_ftv sigma sigma' s0 y r0 h0) s3
                  h14 (nc_lam uSort y s3 k sigma' h3))) s2) a) x7) b __ __ __)
        sigma0 __ __ x8;
     Alpha_app _ _ _ _ _ sigma0 x7 x8 ->
      eq_rec_r r0 (\_ -> false_rec) sigma0 __ __ x7 x8;
     Alpha_builtin r1 _ -> eq_rec_r r0 (\_ -> false_rec) r1 __ __})
    (\bSort s1 iHs1 s2 iHs2 h4 h5 h7 r0 h0 _ h h3 ->
    case h of {
     Alpha_var _ _ sigma0 x7 -> eq_rec_r r0 (\_ -> false_rec) sigma0 __ __ x7;
     Alpha_lam _ _ _ _ _ _ sigma0 x7 ->
      eq_rec_r r0 (\_ -> false_rec) sigma0 __ __ x7;
     Alpha_app b s3 s4 t1 t2 sigma0 x7 x8 ->
      eq_rec_r r0 (\_ ->
        eq_rec_r bSort (\_ ->
          eq_rec_r (sub x t s1) (\_ ->
            eq_rec_r (sub x t s2) (\_ h13 h14 -> Alpha_app bSort
              (let {
                sub0 x9 u t0 =
                  case t0 of {
                   Tmvar y ->
                    case eqb1 x9 y of {
                     True -> u;
                     False -> Tmvar y};
                   Tmlam b0 y k1 t' -> Tmlam b0 y k1 (sub0 x9 u t');
                   Tmapp b0 t3 t4 -> Tmapp b0 (sub0 x9 u t3) (sub0 x9 u t4);
                   Tmbuiltin d -> Tmbuiltin d}}
               in sub0 x (psubs sigma t)
                    (let {
                      psubs0 sigma1 t0 =
                        case t0 of {
                         Tmvar x9 ->
                          case lookup x9 sigma1 of {
                           Some t3 -> t3;
                           None -> Tmvar x9};
                         Tmlam b0 x9 a s0 -> Tmlam b0 x9 a (psubs0 sigma1 s0);
                         Tmapp b0 s0 t3 -> Tmapp b0 (psubs0 sigma1 s0)
                          (psubs0 sigma1 t3);
                         Tmbuiltin d -> Tmbuiltin d}}
                     in psubs0 sigma s1))
              (let {
                psubs0 sigma1 t0 =
                  case t0 of {
                   Tmvar x9 ->
                    case lookup x9 sigma1 of {
                     Some t3 -> t3;
                     None -> Tmvar x9};
                   Tmlam b0 x9 a s0 -> Tmlam b0 x9 a (psubs0 sigma1 s0);
                   Tmapp b0 s0 t3 -> Tmapp b0 (psubs0 sigma1 s0)
                    (psubs0 sigma1 t3);
                   Tmbuiltin d -> Tmbuiltin d}}
               in psubs0 sigma' s4)
              (let {
                sub0 x9 u t0 =
                  case t0 of {
                   Tmvar y ->
                    case eqb1 x9 y of {
                     True -> u;
                     False -> Tmvar y};
                   Tmlam b0 y k1 t' -> Tmlam b0 y k1 (sub0 x9 u t');
                   Tmapp b0 t3 t4 -> Tmapp b0 (sub0 x9 u t3) (sub0 x9 u t4);
                   Tmbuiltin d -> Tmbuiltin d}}
               in sub0 x (psubs sigma t)
                    (let {
                      psubs0 sigma1 t0 =
                        case t0 of {
                         Tmvar x9 ->
                          case lookup x9 sigma1 of {
                           Some t3 -> t3;
                           None -> Tmvar x9};
                         Tmlam b0 x9 a s0 -> Tmlam b0 x9 a (psubs0 sigma1 s0);
                         Tmapp b0 s0 t3 -> Tmapp b0 (psubs0 sigma1 s0)
                          (psubs0 sigma1 t3);
                         Tmbuiltin d -> Tmbuiltin d}}
                     in psubs0 sigma s2))
              (let {
                psubs0 sigma1 t0 =
                  case t0 of {
                   Tmvar x9 ->
                    case lookup x9 sigma1 of {
                     Some t3 -> t3;
                     None -> Tmvar x9};
                   Tmlam b0 x9 a s0 -> Tmlam b0 x9 a (psubs0 sigma1 s0);
                   Tmapp b0 s0 t3 -> Tmapp b0 (psubs0 sigma1 s0)
                    (psubs0 sigma1 t3);
                   Tmbuiltin d -> Tmbuiltin d}}
               in psubs0 sigma' t2) r0
              (iHs1 (nc_app_l bSort s1 s2 (Cons (Pair x t) Nil) h4)
                (nc_app_l bSort s1 s2 sigma h5)
                (nc_app_l bSort (psubs sigma s1)
                  (let {
                    psubs0 sigma1 t0 =
                      case t0 of {
                       Tmvar x9 ->
                        case lookup x9 sigma1 of {
                         Some t3 -> t3;
                         None -> Tmvar x9};
                       Tmlam b0 x9 a s0 -> Tmlam b0 x9 a (psubs0 sigma1 s0);
                       Tmapp b0 s0 t3 -> Tmapp b0 (psubs0 sigma1 s0)
                        (psubs0 sigma1 t3);
                       Tmbuiltin d -> Tmbuiltin d}}
                   in psubs0 sigma s2) (Cons (Pair x (psubs sigma t)) Nil)
                  h7) r0 h0 s4 h13 (nc_app_l bSort s4 t2 sigma' h3))
              (iHs2 (nc_app_r bSort s1 s2 (Cons (Pair x t) Nil) h4)
                (nc_app_r bSort s1 s2 sigma h5)
                (nc_app_r bSort
                  (let {
                    psubs0 sigma1 t0 =
                      case t0 of {
                       Tmvar x9 ->
                        case lookup x9 sigma1 of {
                         Some t3 -> t3;
                         None -> Tmvar x9};
                       Tmlam b0 x9 a s0 -> Tmlam b0 x9 a (psubs0 sigma1 s0);
                       Tmapp b0 s0 t3 -> Tmapp b0 (psubs0 sigma1 s0)
                        (psubs0 sigma1 t3);
                       Tmbuiltin d -> Tmbuiltin d}}
                   in psubs0 sigma s1) (psubs sigma s2) (Cons (Pair x
                  (psubs sigma t)) Nil) h7) r0 h0 t2 h14
                (nc_app_r bSort s4 t2 sigma' h3))) t1) s3) b __ __) sigma0 __
        __ x7 x8;
     Alpha_builtin r1 _ -> eq_rec_r r0 (\_ -> false_rec) r1 __ __})
    (\d _ _ _ r0 _ _ h _ ->
    case h of {
     Alpha_var _ _ sigma0 x7 -> eq_rec_r r0 (\_ -> false_rec) sigma0 __ __ x7;
     Alpha_lam _ _ _ _ _ _ sigma0 x7 ->
      eq_rec_r r0 (\_ -> false_rec) sigma0 __ __ x7;
     Alpha_app _ _ _ _ _ sigma0 x7 x8 ->
      eq_rec_r r0 (\_ -> false_rec) sigma0 __ __ x7 x8;
     Alpha_builtin r1 d0 ->
      eq_rec_r r0 (\_ -> eq_rec_r d (\_ -> Alpha_builtin r0 d) d0) r1 __ __})
    s x3 x4 x6 r x1 xtsAlpha x0 x2

gu_app_st__gu_app_ts :: BSort -> Term0 -> Term0 -> GU -> GU
gu_app_st__gu_app_ts b s1 s2 x =
  case x of {
   GU_app b0 s t x0 x1 ->
    eq_rec_r b (\_ ->
      eq_rec_r s1 (\_ -> eq_rec_r s2 (\h2 h4 _ _ -> GU_app b s2 s1 h4 h2) t)
        s) b0 __ __ x0 x1 __ __;
   GU_lam _ _ _ _ x0 -> false_rec x0 __;
   _ -> false_rec}

step_subst_single :: (List (Prod String String)) -> String -> Term0 -> Term0
                     -> Term0 -> Term0 -> Step_naive -> GU -> NC -> Alpha ->
                     Coq__UU03b1_CtxSub -> NC -> SigT Term0
                     (Prod Step_gu_naive Alpha)
step_subst_single r x p s t t' x0 x1 x2 x3 x4 x5 =
  step_naive_rec (\x6 a s0 t0 h0 h1 r0 h3 t'0 h2 h4 ->
    eq_rec_r (Tmapp App (subs (Cons (Pair x p) Nil) (Tmlam Lam x6 a s0))
      (subs (Cons (Pair x p) Nil) t0))
      (eq_rec_r (Tmlam Lam x6 a (subs (Cons (Pair x p) Nil) s0))
        (let {
          h = to_GU_applam_unfold App Lam a (subs (Cons (Pair x p) Nil) s0)
                (subs (Cons (Pair x p) Nil) t0)
                (to_GU (Tmapp App (Tmlam Lam x6 a
                  (subs (Cons (Pair x p) Nil) s0))
                  (subs (Cons (Pair x p) Nil) t0))) x6}
         in
         case h of {
          ExistT x7 s1 ->
           case s1 of {
            ExistT x8 s2 ->
             case s2 of {
              ExistT x9 p0 ->
               case p0 of {
                Pair p1 a0 ->
                 case p1 of {
                  Pair _ a1 -> ExistT (sub x7 x9 x8) (Pair
                   (Step_gu_naive_intro (Tmapp App (Tmlam Lam x6 a
                   (subs (Cons (Pair x p) Nil) s0))
                   (subs (Cons (Pair x p) Nil) t0)) (Tmapp App (Tmlam Lam x7
                   a x8) x9) (sub x7 x9 x8) (Alpha_app App (Tmlam Lam x6 a
                   (subs (Cons (Pair x p) Nil) s0)) (Tmlam Lam x7 a x8)
                   (subs (Cons (Pair x p) Nil) t0) x9 Nil (Alpha_lam Lam x6
                   x7 a (subs (Cons (Pair x p) Nil) s0) x8 Nil a1) a0)
                   (to_GU__GU (Tmapp App (Tmlam Lam x6 a
                     (subs (Cons (Pair x p) Nil) s0))
                     (subs (Cons (Pair x p) Nil) t0))) (Step_beta0 x7 a x8
                   x9))
                   (let {sconstr2_ = sconstr2 x6 t0 x p s0} in
                    case sconstr2_ of {
                     Pair p2 t1 ->
                      case p2 of {
                       Pair t2 t3 ->
                        alpha_trans (sub x7 x9 x8)
                          (sub x6 (subs (Cons (Pair x t1) Nil) t3)
                            (subs (Cons (Pair x t1) Nil) t2))
                          (subs (Cons (Pair x p) Nil) t'0) (ctx_id_left r0)
                          r0 r0 (id_left_trans r0)
                          (alpha_extend_ids (ctx_id_left r0) (sub x7 x9 x8)
                            (sub x6 (subs (Cons (Pair x t1) Nil) t3)
                              (subs (Cons (Pair x t1) Nil) t2))
                            (ctx_id_left_is_id r0)
                            (alpha_rename_binder_stronger x7 x6 x8 x9
                              (subs (Cons (Pair x t1) Nil) t3) Nil
                              (subs (Cons (Pair x t1) Nil) t2) (Cons (Pair x7
                              x6) Nil)
                              (alpha_trans x8 (subs (Cons (Pair x p) Nil) s0)
                                (subs (Cons (Pair x t1) Nil) t2) (Cons (Pair
                                x7 x6) Nil)
                                (ctx_id_right (Cons (Pair x7 x6) Nil)) (Cons
                                (Pair x7 x6) Nil)
                                (id_right_trans (Cons (Pair x7 x6) Nil))
                                (alpha_sym (subs (Cons (Pair x p) Nil) s0) x8
                                  (sym_alpha_ctx (Cons (Pair x7 x6) Nil))
                                  (Cons (Pair x7 x6) Nil)
                                  (sym_alpha_ctx_left_is_sym (Cons (Pair x7
                                    x6) Nil)) a1)
                                (alpha_extend_ids
                                  (ctx_id_right (Cons (Pair x7 x6) Nil))
                                  (subs (Cons (Pair x p) Nil) s0)
                                  (subs (Cons (Pair x t1) Nil) t2)
                                  (Id_ctx_cons x6 Nil Id_ctx_nil)
                                  (let {
                                    _evar_0_ = let {
                                                _evar_0_ = subs_preserves_alpha__UU03c3__R
                                                             s0 Nil t2 (Cons
                                                             (Pair x p) Nil)
                                                             (Cons (Pair x
                                                             t1) Nil)
                                                             (nc_lam Lam x6
                                                               s0 a (Cons
                                                               (Pair x p)
                                                               Nil)
                                                               (nc_app_l App
                                                                 (Tmlam Lam
                                                                 x6 a s0) t0
                                                                 (Cons (Pair
                                                                 x p) Nil)
                                                                 h1))
                                                             (sconstr2_nc_s
                                                               x6 t0 x p s0
                                                               t2 t3 t1)
                                                             (sconstr2_alpha_s
                                                               x6 t0 x p s0
                                                               t2 t3 t1)
                                                             (Alpha_ctx_cons
                                                             Nil Nil Nil x x
                                                             p t1
                                                             (Alpha_ctx_nil
                                                             Nil)
                                                             (Alpha_var_refl
                                                             x)
                                                             (sconstr2_alpha_p
                                                               x6 t0 x p s0
                                                               t2 t3 t1))}
                                               in
                                               eq_rec_r
                                                 (psubs (Cons (Pair x t1)
                                                   Nil) t2) _evar_0_
                                                 (subs (Cons (Pair x t1) Nil)
                                                   t2)}
                                   in
                                   eq_rec_r (psubs (Cons (Pair x p) Nil) s0)
                                     _evar_0_ (subs (Cons (Pair x p) Nil) s0))))
                              (alpha_trans x9 (subs (Cons (Pair x p) Nil) t0)
                                (subs (Cons (Pair x t1) Nil) t3) Nil Nil Nil
                                Alpha_trans_nil
                                (alpha_extend_ids Nil x9
                                  (subs (Cons (Pair x p) Nil) t0) Id_ctx_nil
                                  (alpha_extend_ids Nil x9
                                    (subs (Cons (Pair x p) Nil) t0)
                                    Id_ctx_nil
                                    (alpha_extend_ids Nil x9
                                      (subs (Cons (Pair x p) Nil) t0)
                                      Id_ctx_nil
                                      (alpha_sym
                                        (subs (Cons (Pair x p) Nil) t0) x9
                                        (sym_alpha_ctx Nil) Nil
                                        (sym_alpha_ctx_left_is_sym Nil) a0))))
                                (let {
                                  _evar_0_ = let {
                                              _evar_0_ = subs_preserves_alpha__UU03c3__R
                                                           t0 Nil t3 (Cons
                                                           (Pair x p) Nil)
                                                           (Cons (Pair x t1)
                                                           Nil)
                                                           (nc_app_r App
                                                             (Tmlam Lam x6 a
                                                             s0) t0 (Cons
                                                             (Pair x p) Nil)
                                                             h1)
                                                           (sconstr2_nc_t x6
                                                             t0 x p s0 t2 t3
                                                             t1)
                                                           (sconstr2_alpha_t
                                                             x6 t0 x p s0 t2
                                                             t3 t1)
                                                           (Alpha_ctx_cons
                                                           Nil Nil Nil x x p
                                                           t1 (Alpha_ctx_nil
                                                           Nil)
                                                           (Alpha_var_refl x)
                                                           (sconstr2_alpha_p
                                                             x6 t0 x p s0 t2
                                                             t3 t1))}
                                             in
                                             eq_rec_r
                                               (psubs (Cons (Pair x t1) Nil)
                                                 t3) _evar_0_
                                               (subs (Cons (Pair x t1) Nil)
                                                 t3)}
                                 in
                                 eq_rec_r (psubs (Cons (Pair x p) Nil) t0)
                                   _evar_0_ (subs (Cons (Pair x p) Nil) t0)))
                              (Lrs_cons x7 x6 Nil Nil Lrs_nil)
                              (gu_applam_to_nc App Lam x8 x9 x7 a
                                (to_GU__GU (Tmapp App (Tmlam Lam x6 a
                                  (subs (Cons (Pair x p) Nil) s0))
                                  (subs (Cons (Pair x p) Nil) t0))))
                              (let {
                                _evar_0_ = let {
                                            _evar_0_ = sconstr2_nc_sub x6 t0
                                                         x p s0 t2 t3 t1}
                                           in
                                           eq_rec_r
                                             (psubs (Cons (Pair x t1) Nil)
                                               t3) _evar_0_
                                             (subs (Cons (Pair x t1) Nil) t3)}
                               in
                               eq_rec_r (psubs (Cons (Pair x t1) Nil) t2)
                                 _evar_0_ (subs (Cons (Pair x t1) Nil) t2))))
                          (let {
                            _evar_0_ = let {
                                        _evar_0_ = let {
                                                    _evar_0_ = commute_sub_naive
                                                                 r0 x6 t2 t3
                                                                 (Cons (Pair
                                                                 x t1) Nil)
                                                                 (Cons (Pair
                                                                 x p) Nil)
                                                                 t'0
                                                                 (alpha_trans
                                                                   (sub x6 t3
                                                                    t2)
                                                                   (sub x6 t0
                                                                    s0) t'0
                                                                   (ctx_id_left
                                                                    r0) r0 r0
                                                                   (id_left_trans
                                                                    r0)
                                                                   (alpha_extend_ids
                                                                    (ctx_id_left
                                                                    r0)
                                                                    (sub x6
                                                                    t3 t2)
                                                                    (sub x6
                                                                    t0 s0)
                                                                    (ctx_id_left_is_id
                                                                    r0)
                                                                    (let {
                                                                    _evar_0_ = 
                                                                    let {
                                                                    _evar_0_ = 
                                                                    subs_preserves_alpha__UU03c3__R
                                                                    t2 Nil s0
                                                                    (Cons
                                                                    (Pair x6
                                                                    t3) Nil)
                                                                    (Cons
                                                                    (Pair x6
                                                                    t0) Nil)
                                                                    (sconstr2_nc_s_t
                                                                    x6 t0 x p
                                                                    s0 t2 t3
                                                                    t1)
                                                                    (gu_applam_to_nc
                                                                    App Lam
                                                                    s0 t0 x6
                                                                    a h0)
                                                                    (alpha_sym
                                                                    s0 t2 Nil
                                                                    Nil
                                                                    Alpha_sym_nil
                                                                    (sconstr2_alpha_s
                                                                    x6 t0 x p
                                                                    s0 t2 t3
                                                                    t1))
                                                                    (Alpha_ctx_cons
                                                                    Nil Nil
                                                                    Nil x6 x6
                                                                    t3 t0
                                                                    (Alpha_ctx_nil
                                                                    Nil)
                                                                    (Alpha_var_refl
                                                                    x6)
                                                                    (alpha_sym
                                                                    t0 t3 Nil
                                                                    Nil
                                                                    Alpha_sym_nil
                                                                    (sconstr2_alpha_t
                                                                    x6 t0 x p
                                                                    s0 t2 t3
                                                                    t1)))}
                                                                    in
                                                                    eq_rec_r
                                                                    (psubs
                                                                    (Cons
                                                                    (Pair x6
                                                                    t0) Nil)
                                                                    s0)
                                                                    _evar_0_
                                                                    (subs
                                                                    (Cons
                                                                    (Pair x6
                                                                    t0) Nil)
                                                                    s0)}
                                                                    in
                                                                    eq_rec_r
                                                                    (psubs
                                                                    (Cons
                                                                    (Pair x6
                                                                    t3) Nil)
                                                                    t2)
                                                                    _evar_0_
                                                                    (subs
                                                                    (Cons
                                                                    (Pair x6
                                                                    t3) Nil)
                                                                    t2))) h2)
                                                                 (_UU03b1_ctx_trans
                                                                   (ctx_id_left
                                                                    r0) r0 r0
                                                                   (Cons
                                                                   (Pair x
                                                                   t1) Nil)
                                                                   (Cons
                                                                   (Pair x p)
                                                                   Nil) (Cons
                                                                   (Pair x p)
                                                                   Nil)
                                                                   (id_left_trans
                                                                    r0)
                                                                   (Alpha_ctx_cons
                                                                   (ctx_id_left
                                                                    r0) Nil
                                                                   Nil x x t1
                                                                   p
                                                                   (Alpha_ctx_nil
                                                                   (ctx_id_left
                                                                    r0))
                                                                   (alphavar_extend_ids
                                                                    (ctx_id_left
                                                                    r0) x x
                                                                    (ctx_id_left_is_id
                                                                    r0)
                                                                    (Alpha_var_refl
                                                                    x))
                                                                   (alpha_extend_ids
                                                                    (ctx_id_left
                                                                    r0) t1 p
                                                                    (ctx_id_left_is_id
                                                                    r0)
                                                                    (alpha_sym
                                                                    p t1 Nil
                                                                    Nil
                                                                    Alpha_sym_nil
                                                                    (sconstr2_alpha_p
                                                                    x6 t0 x p
                                                                    s0 t2 t3
                                                                    t1))))
                                                                   h3) h4
                                                                 (sconstr2_nc_s_t
                                                                   x6 t0 x p
                                                                   s0 t2 t3
                                                                   t1)
                                                                 (sconstr2_nc_s
                                                                   x6 t0 x p
                                                                   s0 t2 t3
                                                                   t1)
                                                                 (sconstr2_nc_t
                                                                   x6 t0 x p
                                                                   s0 t2 t3
                                                                   t1)
                                                                 (sconstr2_nc_sub
                                                                   x6 t0 x p
                                                                   s0 t2 t3
                                                                   t1)}
                                                   in
                                                   eq_rec_r
                                                     (psubs (Cons (Pair x p)
                                                       Nil) t'0) _evar_0_
                                                     (subs (Cons (Pair x p)
                                                       Nil) t'0)}
                                       in
                                       eq_rec_r
                                         (psubs (Cons (Pair x t1) Nil) t2)
                                         _evar_0_
                                         (subs (Cons (Pair x t1) Nil) t2)}
                           in
                           eq_rec_r (psubs (Cons (Pair x t1) Nil) t3)
                             _evar_0_ (subs (Cons (Pair x t1) Nil) t3))}}))}}}}})
        (subs (Cons (Pair x p) Nil) (Tmlam Lam x6 a s0)))
      (subs (Cons (Pair x p) Nil) (Tmapp App (Tmlam Lam x6 a s0) t0)))
    (\b s1 s2 t0 _ iHHstep h0 h1 r0 h3 _ h2 h4 ->
    case h2 of {
     Alpha_var _ _ sigma x6 -> eq_rec_r r0 (\_ -> false_rec) sigma __ __ x6;
     Alpha_lam _ _ _ _ _ _ sigma x6 ->
      eq_rec_r r0 (\_ -> false_rec) sigma __ __ x6;
     Alpha_app b0 s3 s4 t1 t2 sigma x6 x7 ->
      eq_rec_r r0 (\_ ->
        eq_rec_r b (\_ ->
          eq_rec_r s2 (\_ ->
            eq_rec_r t0 (\_ h9 h10 ->
              let {
               h = iHHstep (gu_app_l b s1 t0 h0)
                     (nc_app_l b s1 t0 (Cons (Pair x p) Nil) h1) r0 h3 s4 h9
                     (nc_app_l b s4 t2 (Cons (Pair x p) Nil) h4)}
              in
              case h of {
               ExistT x8 p0 ->
                case p0 of {
                 Pair s0 a ->
                  case s0 of {
                   Step_gu_naive_intro s5 s' t3 x9 x10 x11 ->
                    eq_rec_r (subs (Cons (Pair x p) Nil) s1) (\_ ->
                      eq_rec_r x8 (\h5 h6 h7 ->
                        let {
                         st_gu = to_GU (Tmapp b s'
                                   (subs (Cons (Pair x p) Nil) t0))}
                        in
                        let {
                         s6 = to_GU_app_unfold b s'
                                (subs (Cons (Pair x p) Nil) t0) st_gu}
                        in
                        case s6 of {
                         ExistT x12 s7 ->
                          case s7 of {
                           ExistT x13 p1 ->
                            case p1 of {
                             Pair p2 a0 ->
                              case p2 of {
                               Pair _ a1 ->
                                let {
                                 h8 = step_naive_preserves_alpha2 s' x8 x12
                                        Nil h6
                                        (gu_app_l b x12 x13
                                          (let {
                                            _evar_0_ = \_ ->
                                             to_GU__GU (Tmapp b s'
                                               (subs (Cons (Pair x p) Nil)
                                                 t0))}
                                           in
                                           eq_rec_r
                                             (to_GU (Tmapp b s'
                                               (subs (Cons (Pair x p) Nil)
                                                 t0))) _evar_0_ st_gu __)) a1
                                        h7}
                                in
                                case h8 of {
                                 ExistT x14 p3 ->
                                  case p3 of {
                                   Pair s8 a2 -> ExistT (Tmapp b x14 x13)
                                    (Pair (Step_gu_naive_intro
                                    (subs (Cons (Pair x p) Nil) (Tmapp b s1
                                      t0)) (Tmapp b x12 x13) (Tmapp b x14
                                    x13) (Alpha_app b
                                    (let {
                                      sub0 x15 u t4 =
                                        case t4 of {
                                         Tmvar y ->
                                          case eqb1 x15 y of {
                                           True -> u;
                                           False -> Tmvar y};
                                         Tmlam b1 y k1 t'0 -> Tmlam b1 y k1
                                          (sub0 x15 u t'0);
                                         Tmapp b1 t5 t6 -> Tmapp b1
                                          (sub0 x15 u t5) (sub0 x15 u t6);
                                         Tmbuiltin d -> Tmbuiltin d}}
                                     in sub0 x p s1) x12
                                    (let {
                                      sub0 x15 u t4 =
                                        case t4 of {
                                         Tmvar y ->
                                          case eqb1 x15 y of {
                                           True -> u;
                                           False -> Tmvar y};
                                         Tmlam b1 y k1 t'0 -> Tmlam b1 y k1
                                          (sub0 x15 u t'0);
                                         Tmapp b1 t5 t6 -> Tmapp b1
                                          (sub0 x15 u t5) (sub0 x15 u t6);
                                         Tmbuiltin d -> Tmbuiltin d}}
                                     in sub0 x p t0) x13 Nil
                                    (alpha_trans
                                      (let {
                                        sub0 x15 u t4 =
                                          case t4 of {
                                           Tmvar y ->
                                            case eqb1 x15 y of {
                                             True -> u;
                                             False -> Tmvar y};
                                           Tmlam b1 y k1 t'0 -> Tmlam b1 y k1
                                            (sub0 x15 u t'0);
                                           Tmapp b1 t5 t6 -> Tmapp b1
                                            (sub0 x15 u t5) (sub0 x15 u t6);
                                           Tmbuiltin d -> Tmbuiltin d}}
                                       in sub0 x p s1) s' x12 Nil Nil Nil
                                      Alpha_trans_nil h5 a1) a0)
                                    (eq_rec_r
                                      (to_GU (Tmapp b s'
                                        (subs (Cons (Pair x p) Nil) t0)))
                                      (\_ ->
                                      to_GU__GU (Tmapp b s'
                                        (subs (Cons (Pair x p) Nil) t0)))
                                      st_gu __) (Step_appL0 b x12 x14 x13
                                    s8))
                                    (alpha_trans (Tmapp b x14 x13) (Tmapp b
                                      x8 (subs (Cons (Pair x p) Nil) t0))
                                      (subs (Cons (Pair x p) Nil) (Tmapp b s4
                                        t2)) (ctx_id_left r0) r0 r0
                                      (id_left_trans r0)
                                      (alpha_extend_ids (ctx_id_left r0)
                                        (Tmapp b x14 x13) (Tmapp b x8
                                        (subs (Cons (Pair x p) Nil) t0))
                                        (ctx_id_left_is_id r0) (Alpha_app b
                                        x14 x8 x13
                                        (subs (Cons (Pair x p) Nil) t0) Nil
                                        (alpha_sym x8 x14 Nil Nil
                                          Alpha_sym_nil a2)
                                        (alpha_sym
                                          (subs (Cons (Pair x p) Nil) t0) x13
                                          Nil Nil Alpha_sym_nil a0)))
                                      (let {
                                        _evar_0_ = Alpha_app b x8
                                         (subs (Cons (Pair x p) Nil) s4)
                                         (subs (Cons (Pair x p) Nil) t0)
                                         (subs (Cons (Pair x p) Nil) t2) r0 a
                                         (let {
                                           _evar_0_ = let {
                                                       _evar_0_ = subs_preserves_alpha__UU03c3__R
                                                                    t0 r0 t2
                                                                    (Cons
                                                                    (Pair x
                                                                    p) Nil)
                                                                    (Cons
                                                                    (Pair x
                                                                    p) Nil)
                                                                    (nc_app_r
                                                                    b s1 t0
                                                                    (Cons
                                                                    (Pair x
                                                                    p) Nil)
                                                                    h1)
                                                                    (nc_app_r
                                                                    b s4 t2
                                                                    (Cons
                                                                    (Pair x
                                                                    p) Nil)
                                                                    h4) h10
                                                                    h3}
                                                      in
                                                      eq_rec_r
                                                        (psubs (Cons (Pair x
                                                          p) Nil) t2)
                                                        _evar_0_
                                                        (subs (Cons (Pair x
                                                          p) Nil) t2)}
                                          in
                                          eq_rec_r
                                            (psubs (Cons (Pair x p) Nil) t0)
                                            _evar_0_
                                            (subs (Cons (Pair x p) Nil) t0))}
                                       in
                                       eq_rec_r (Tmapp b
                                         (subs (Cons (Pair x p) Nil) s4)
                                         (subs (Cons (Pair x p) Nil) t2))
                                         _evar_0_
                                         (subs (Cons (Pair x p) Nil) (Tmapp b
                                           s4 t2)))))}}}}}}) t3) s5 __ x9 x10
                      x11}}}) t1) s3) b0 __ __) sigma __ __ x6 x7;
     Alpha_builtin r1 _ -> eq_rec_r r0 (\_ -> false_rec) r1 __ __})
    (\b s0 t1 t2 _ iHHstep h0 h1 r0 h3 _ h2 h4 ->
    case h2 of {
     Alpha_var _ _ sigma x6 -> eq_rec_r r0 (\_ -> false_rec) sigma __ __ x6;
     Alpha_lam _ _ _ _ _ _ sigma x6 ->
      eq_rec_r r0 (\_ -> false_rec) sigma __ __ x6;
     Alpha_app b0 s1 s2 t3 t4 sigma x6 x7 ->
      eq_rec_r r0 (\_ ->
        eq_rec_r b (\_ ->
          eq_rec_r s0 (\_ ->
            eq_rec_r t2 (\_ h9 h10 ->
              let {
               h = iHHstep (gu_app_r b s0 t1 h0)
                     (nc_app_r b s0 t1 (Cons (Pair x p) Nil) h1) r0 h3 t4 h10
                     (nc_app_r b s2 t4 (Cons (Pair x p) Nil) h4)}
              in
              case h of {
               ExistT x8 p0 ->
                case p0 of {
                 Pair s3 a ->
                  let {
                   _evar_0_ = let {
                               _evar_0_ = case s3 of {
                                           Step_gu_naive_intro s4 s' t0 x9
                                            x10 x11 ->
                                            eq_rec_r
                                              (subs (Cons (Pair x p) Nil) t1)
                                              (\_ ->
                                              eq_rec_r x8 (\h5 h6 h7 ->
                                                let {
                                                 st_gu = to_GU (Tmapp b s'
                                                           (subs (Cons (Pair
                                                             x p) Nil) s0))}
                                                in
                                                let {
                                                 s5 = to_GU_app_unfold b s'
                                                        (subs (Cons (Pair x
                                                          p) Nil) s0) st_gu}
                                                in
                                                case s5 of {
                                                 ExistT x12 s6 ->
                                                  case s6 of {
                                                   ExistT x13 p1 ->
                                                    case p1 of {
                                                     Pair p2 a0 ->
                                                      case p2 of {
                                                       Pair _ a1 ->
                                                        let {
                                                         h8 = step_naive_preserves_alpha2
                                                                s' x8 x12 Nil
                                                                h6
                                                                (gu_app_l b
                                                                  x12 x13
                                                                  (let {
                                                                    _evar_0_ = \_ ->
                                                                    to_GU__GU
                                                                    (Tmapp b
                                                                    s'
                                                                    (subs
                                                                    (Cons
                                                                    (Pair x
                                                                    p) Nil)
                                                                    s0))}
                                                                   in
                                                                   eq_rec_r
                                                                    (to_GU
                                                                    (Tmapp b
                                                                    s'
                                                                    (subs
                                                                    (Cons
                                                                    (Pair x
                                                                    p) Nil)
                                                                    s0)))
                                                                    _evar_0_
                                                                    st_gu __))
                                                                a1 h7}
                                                        in
                                                        case h8 of {
                                                         ExistT x14 p3 ->
                                                          case p3 of {
                                                           Pair s7 a2 ->
                                                            ExistT (Tmapp b
                                                            x13 x14) (Pair
                                                            (Step_gu_naive_intro
                                                            (Tmapp b
                                                            (subs (Cons (Pair
                                                              x p) Nil) s0)
                                                            (subs (Cons (Pair
                                                              x p) Nil) t1))
                                                            (Tmapp b x13 x12)
                                                            (Tmapp b x13 x14)
                                                            (Alpha_app b
                                                            (subs (Cons (Pair
                                                              x p) Nil) s0)
                                                            x13
                                                            (subs (Cons (Pair
                                                              x p) Nil) t1)
                                                            x12 Nil a0
                                                            (alpha_trans
                                                              (subs (Cons
                                                                (Pair x p)
                                                                Nil) t1) s'
                                                              x12 Nil Nil Nil
                                                              Alpha_trans_nil
                                                              h5 a1))
                                                            (gu_app_st__gu_app_ts
                                                              b x12 x13
                                                              (let {
                                                                _evar_0_ = 
                                                                 to_GU__GU
                                                                   (Tmapp b
                                                                   s'
                                                                   (subs
                                                                    (Cons
                                                                    (Pair x
                                                                    p) Nil)
                                                                    s0))}
                                                               in
                                                               eq_rec_r
                                                                 (to_GU
                                                                   (Tmapp b
                                                                   s'
                                                                   (subs
                                                                    (Cons
                                                                    (Pair x
                                                                    p) Nil)
                                                                    s0)))
                                                                 _evar_0_
                                                                 st_gu))
                                                            (Step_appR0 b x13
                                                            x12 x14 s7))
                                                            (alpha_trans
                                                              (Tmapp b x13
                                                              x14) (Tmapp b
                                                              (subs (Cons
                                                                (Pair x p)
                                                                Nil) s0) x8)
                                                              (Tmapp b
                                                              (subs (Cons
                                                                (Pair x p)
                                                                Nil) s2)
                                                              (subs (Cons
                                                                (Pair x p)
                                                                Nil) t4))
                                                              (ctx_id_left
                                                                r0) r0 r0
                                                              (id_left_trans
                                                                r0)
                                                              (alpha_extend_ids
                                                                (ctx_id_left
                                                                  r0) (Tmapp
                                                                b x13 x14)
                                                                (Tmapp b
                                                                (subs (Cons
                                                                  (Pair x p)
                                                                  Nil) s0)
                                                                x8)
                                                                (ctx_id_left_is_id
                                                                  r0)
                                                                (Alpha_app b
                                                                x13
                                                                (subs (Cons
                                                                  (Pair x p)
                                                                  Nil) s0)
                                                                x14 x8 Nil
                                                                (alpha_sym
                                                                  (subs (Cons
                                                                    (Pair x
                                                                    p) Nil)
                                                                    s0) x13
                                                                  Nil Nil
                                                                  Alpha_sym_nil
                                                                  a0)
                                                                (alpha_sym x8
                                                                  x14 Nil Nil
                                                                  Alpha_sym_nil
                                                                  a2)))
                                                              (Alpha_app b
                                                              (subs (Cons
                                                                (Pair x p)
                                                                Nil) s0)
                                                              (subs (Cons
                                                                (Pair x p)
                                                                Nil) s2) x8
                                                              (subs (Cons
                                                                (Pair x p)
                                                                Nil) t4) r0
                                                              (let {
                                                                _evar_0_ = 
                                                                 let {
                                                                  _evar_0_ = 
                                                                   subs_preserves_alpha__UU03c3__R
                                                                    s0 r0 s2
                                                                    (Cons
                                                                    (Pair x
                                                                    p) Nil)
                                                                    (Cons
                                                                    (Pair x
                                                                    p) Nil)
                                                                    (nc_app_l
                                                                    b s0 t1
                                                                    (Cons
                                                                    (Pair x
                                                                    p) Nil)
                                                                    h1)
                                                                    (nc_app_l
                                                                    b s2 t4
                                                                    (Cons
                                                                    (Pair x
                                                                    p) Nil)
                                                                    h4) h9 h3}
                                                                 in
                                                                 eq_rec_r
                                                                   (psubs
                                                                    (Cons
                                                                    (Pair x
                                                                    p) Nil)
                                                                    s2)
                                                                   _evar_0_
                                                                   (subs
                                                                    (Cons
                                                                    (Pair x
                                                                    p) Nil)
                                                                    s2)}
                                                               in
                                                               eq_rec_r
                                                                 (psubs (Cons
                                                                   (Pair x p)
                                                                   Nil) s0)
                                                                 _evar_0_
                                                                 (subs (Cons
                                                                   (Pair x p)
                                                                   Nil) s0))
                                                              a)))}}}}}}) t0)
                                              s4 __ x9 x10 x11}}
                              in
                              eq_rec_r (Tmapp b
                                (subs (Cons (Pair x p) Nil) s2)
                                (subs (Cons (Pair x p) Nil) t4)) _evar_0_
                                (subs (Cons (Pair x p) Nil) (Tmapp b s2 t4))}
                  in
                  eq_rec_r (Tmapp b (subs (Cons (Pair x p) Nil) s0)
                    (subs (Cons (Pair x p) Nil) t1)) _evar_0_
                    (subs (Cons (Pair x p) Nil) (Tmapp b s0 t1))}}) t3) s1)
          b0 __ __) sigma __ __ x6 x7;
     Alpha_builtin r1 _ -> eq_rec_r r0 (\_ -> false_rec) r1 __ __})
    (\b x6 a s1 s2 _ iHHstep h0 h1 r0 h3 _ h2 h4 ->
    case h2 of {
     Alpha_var _ _ sigma x7 -> eq_rec_r r0 (\_ -> false_rec) sigma __ __ x7;
     Alpha_lam b0 x7 y a0 s3 s4 sigma x8 ->
      eq_rec_r r0 (\_ ->
        eq_rec_r b (\_ ->
          eq_rec_r x6 (\_ ->
            eq_rec_r a (\_ ->
              eq_rec_r s2 (\_ h10 ->
                let {iHHstep0 = iHHstep (gu_lam b x6 a s1 h0)} in
                let {
                 hctxSub = alpha_ctx_ren_extend_fresh_ftv (Cons (Pair x p)
                             Nil) (Cons (Pair x p) Nil) x6 y r0 h3}
                in
                let {
                 iHHstep1 = iHHstep0
                              (nc_lam b x6 s1 a (Cons (Pair x p) Nil) h1)
                              (Cons (Pair x6 y) r0) hctxSub s4 h10
                              (nc_lam b y s4 a (Cons (Pair x p) Nil) h4)}
                in
                case iHHstep1 of {
                 ExistT x9 p0 ->
                  case p0 of {
                   Pair s0 a1 ->
                    case s0 of {
                     Step_gu_naive_intro s5 s' t0 x10 x11 x12 ->
                      eq_rec_r (subs (Cons (Pair x p) Nil) s1) (\_ ->
                        eq_rec_r x9 (\h h5 h6 ->
                          let {s'' = to_GU'' x6 s'} in
                          let {
                           h7 = step_naive_preserves_alpha2 s' x9 s'' Nil h5
                                  (gu_lam b x6 a s''
                                    (eq_rec_r (to_GU'' x6 s')
                                      (to_GU''__GU_lam b x6 a s') s''))
                                  (eq_rec_r (to_GU'' x6 s')
                                    (to_GU''__alpha x6 s') s'') h6}
                          in
                          case h7 of {
                           ExistT x13 p1 ->
                            case p1 of {
                             Pair s6 a2 -> ExistT (Tmlam b x6 a x13) (Pair
                              (Step_gu_naive_intro
                              (subs (Cons (Pair x p) Nil) (Tmlam b x6 a s1))
                              (Tmlam b x6 a s'') (Tmlam b x6 a x13)
                              (Alpha_lam b x6 x6 a
                              (let {
                                sub0 x14 u t1 =
                                  case t1 of {
                                   Tmvar y0 ->
                                    case eqb1 x14 y0 of {
                                     True -> u;
                                     False -> Tmvar y0};
                                   Tmlam b1 y0 k1 t'0 -> Tmlam b1 y0 k1
                                    (sub0 x14 u t'0);
                                   Tmapp b1 t2 t3 -> Tmapp b1 (sub0 x14 u t2)
                                    (sub0 x14 u t3);
                                   Tmbuiltin d -> Tmbuiltin d}}
                               in sub0 x p s1) s'' Nil
                              (alpha_extend_ids (Cons (Pair x6 x6) Nil)
                                (let {
                                  sub0 x14 u t1 =
                                    case t1 of {
                                     Tmvar y0 ->
                                      case eqb1 x14 y0 of {
                                       True -> u;
                                       False -> Tmvar y0};
                                     Tmlam b1 y0 k1 t'0 -> Tmlam b1 y0 k1
                                      (sub0 x14 u t'0);
                                     Tmapp b1 t2 t3 -> Tmapp b1
                                      (sub0 x14 u t2) (sub0 x14 u t3);
                                     Tmbuiltin d -> Tmbuiltin d}}
                                 in sub0 x p s1) s'' (Id_ctx_cons x6 Nil
                                Id_ctx_nil)
                                (alpha_trans
                                  (let {
                                    sub0 x14 u t1 =
                                      case t1 of {
                                       Tmvar y0 ->
                                        case eqb1 x14 y0 of {
                                         True -> u;
                                         False -> Tmvar y0};
                                       Tmlam b1 y0 k1 t'0 -> Tmlam b1 y0 k1
                                        (sub0 x14 u t'0);
                                       Tmapp b1 t2 t3 -> Tmapp b1
                                        (sub0 x14 u t2) (sub0 x14 u t3);
                                       Tmbuiltin d -> Tmbuiltin d}}
                                   in sub0 x p s1) s' s'' Nil Nil Nil
                                  Alpha_trans_nil h
                                  (eq_rec_r (to_GU'' x6 s') (\_ ->
                                    to_GU''__alpha x6 s') s'' s6))))
                              (eq_rec_r (to_GU'' x6 s') (\_ ->
                                to_GU''__GU_lam b x6 a s') s'' s6) (Step_abs0
                              b x6 a s'' x13 s6)) (Alpha_lam b x6 y a x13
                              (let {
                                sub0 x14 u t1 =
                                  case t1 of {
                                   Tmvar y0 ->
                                    case eqb1 x14 y0 of {
                                     True -> u;
                                     False -> Tmvar y0};
                                   Tmlam b1 y0 k1 t'0 -> Tmlam b1 y0 k1
                                    (sub0 x14 u t'0);
                                   Tmapp b1 t2 t3 -> Tmapp b1 (sub0 x14 u t2)
                                    (sub0 x14 u t3);
                                   Tmbuiltin d -> Tmbuiltin d}}
                               in sub0 x p s4) r0
                              (alpha_trans x13 x9
                                (let {
                                  sub0 x14 u t1 =
                                    case t1 of {
                                     Tmvar y0 ->
                                      case eqb1 x14 y0 of {
                                       True -> u;
                                       False -> Tmvar y0};
                                     Tmlam b1 y0 k1 t'0 -> Tmlam b1 y0 k1
                                      (sub0 x14 u t'0);
                                     Tmapp b1 t2 t3 -> Tmapp b1
                                      (sub0 x14 u t2) (sub0 x14 u t3);
                                     Tmbuiltin d -> Tmbuiltin d}}
                                 in sub0 x p s4)
                                (ctx_id_left (Cons (Pair x6 y) r0)) (Cons
                                (Pair x6 y) r0) (Cons (Pair x6 y) r0)
                                (id_left_trans (Cons (Pair x6 y) r0))
                                (alpha_extend_ids
                                  (ctx_id_left (Cons (Pair x6 y) r0)) x13 x9
                                  (ctx_id_left_is_id (Cons (Pair x6 y) r0))
                                  (alpha_sym x9 x13 Nil Nil Alpha_sym_nil a2))
                                a1)))}}) t0) s5 __ x10 x11 x12}}}) s3) a0) x7)
          b0 __ __ __) sigma __ __ x8;
     Alpha_app _ _ _ _ _ sigma x7 x8 ->
      eq_rec_r r0 (\_ -> false_rec) sigma __ __ x7 x8;
     Alpha_builtin r1 _ -> eq_rec_r r0 (\_ -> false_rec) r1 __ __}) s t x0 x1
    x2 r x4 t' x3 x5

sub_gu :: String -> Term0 -> Term0 -> Term0
sub_gu x t s =
  sub x t (to_GU' x t s)

sn_subst :: String -> Term0 -> Term0 -> NC -> (Sn Term0 Step_gu_naive) -> Sn
            Term0 Step_gu_naive
sn_subst x t s nc x0 =
  let {
   x1 = _UU03b1__preserves_SN_R (psubs (Cons (Pair x t) Nil) s)
          (psubs (Cons (Pair x t) Nil) (to_GU' x t s)) Nil
          (subs_preserves_alpha__UU03c3__R s Nil (to_GU' x t s) (Cons (Pair x
            t) Nil) (Cons (Pair x t) Nil) nc (to_GU'__NC x t s)
            (to_GU'__alpha x t s) (Alpha_ctx_cons Nil Nil Nil x x t t
            (Alpha_ctx_nil Nil) (Alpha_var_refl x)
            (alpha_refl t Nil Alpha_refl_nil))) x0}
  in
  sn_preimage__UU03b1_ (sub_gu x t) s (\x2 y x3 ->
    case x3 of {
     Step_gu_naive_intro s0 s' t0 x4 x5 x6 ->
      eq_rec_r x2 (\_ ->
        eq_rec_r y (\h1 h2 h3 ->
          let {
           h4 = step_naive_preserves_alpha2 s' y (to_GU' x t x2) Nil h2
                  (to_GU'__GU x t x2)
                  (alpha_trans s' x2 (to_GU' x t x2) Nil Nil Nil
                    Alpha_trans_nil
                    (alpha_extend_ids Nil s' x2 Id_ctx_nil
                      (alpha_extend_ids Nil s' x2 Id_ctx_nil
                        (alpha_extend_ids Nil s' x2 Id_ctx_nil
                          (alpha_sym x2 s' (sym_alpha_ctx Nil) Nil
                            (sym_alpha_ctx_left_is_sym Nil) h1))))
                    (to_GU'__alpha x t x2)) h3}
          in
          case h4 of {
           ExistT x7 p ->
            case p of {
             Pair s1 a ->
              step_subst_single Nil x t (to_GU' x t x2) x7 (to_GU' x t y) s1
                (to_GU'__GU x t x2) (to_GU'__NC x t x2)
                (alpha_trans x7 y (to_GU' x t y) Nil Nil Nil Alpha_trans_nil
                  (alpha_extend_ids Nil x7 y Id_ctx_nil
                    (alpha_extend_ids Nil x7 y Id_ctx_nil
                      (alpha_extend_ids Nil x7 y Id_ctx_nil
                        (alpha_sym y x7 (sym_alpha_ctx Nil) Nil
                          (sym_alpha_ctx_left_is_sym Nil) a))))
                  (to_GU'__alpha x t y)) (Alpha_ctx_cons Nil Nil Nil x x t t
                (Alpha_ctx_nil Nil) (Alpha_var_refl x)
                (alpha_refl t Nil Alpha_refl_nil)) (to_GU'__NC x t y)}}) t0)
        s0 __ x4 x5 x6}) x1

data Reducible p =
   Build_reducible (Term0 -> p -> Sn Term0 Step_gu_naive) (Term0 -> Term0 ->
                                                          p -> Step_gu_naive
                                                          -> p) (Term0 -> ()
                                                                -> (Term0 ->
                                                                Step_gu_naive
                                                                -> p) -> p)

p_sn :: (Reducible a1) -> Term0 -> a1 -> Sn Term0 Step_gu_naive
p_sn r =
  case r of {
   Build_reducible p_sn0 _ _ -> p_sn0}

p_cl :: (Reducible a1) -> Term0 -> Term0 -> a1 -> Step_gu_naive -> a1
p_cl r =
  case r of {
   Build_reducible _ p_cl0 _ -> p_cl0}

p_nc :: (Reducible a1) -> Term0 -> (Term0 -> Step_gu_naive -> a1) -> a1
p_nc r s x =
  case r of {
   Build_reducible _ _ p_nc0 -> p_nc0 s __ x}

type L = Any

_UU03b1__preserves_L_R :: Kind -> Term0 -> Term0 -> (List
                          (Prod String String)) -> Alpha -> L -> L
_UU03b1__preserves_L_R a s s' r x x0 =
  kind_rect (\r0 s'0 s0 h x1 ->
    unsafeCoerce _UU03b1__preserves_SN_R s0 s'0 r0 h x1)
    (\_ iHA1 _ iHA2 r0 s'0 s0 h x1 ->
    unsafeCoerce (\t' ht ->
      let {r' = sym_alpha_ctx r0} in
      let {
       h0 = eq_rec_r (sym_alpha_ctx r0)
              (alpha_sym s0 s'0 (sym_alpha_ctx (sym_alpha_ctx r0))
                (sym_alpha_ctx r0)
                (sym_alpha_ctx_left_is_sym (sym_alpha_ctx r0))
                (alpha_sym s'0 s0 (sym_alpha_ctx r0)
                  (sym_alpha_ctx (sym_alpha_ctx r0))
                  (sym_alpha_ctx_is_sym (sym_alpha_ctx r0))
                  (alpha_sym s0 s'0 r0 (sym_alpha_ctx r0)
                    (sym_alpha_ctx_is_sym r0) h))) r'}
      in
      let {rt = a_constr r' s'0 s0 t'} in
      case rt of {
       Pair l t ->
        iHA2 (sym_alpha_ctx l) (Tmapp App s'0 t') (Tmapp App s0 t)
          (alpha_sym (Tmapp App s'0 t') (Tmapp App s0 t) l (sym_alpha_ctx l)
            (sym_alpha_ctx_is_sym l) (Alpha_app App s'0 s0 t' t l
            (a_constr__s_alpha r' s'0 s0 t' l t h0)
            (a_constr__t_alpha r' s'0 s0 t' l t h0)))
          (unsafeCoerce x1 t
            (iHA1 l t t' (a_constr__t_alpha r' s'0 s0 t' l t h0) ht))})) a r
    s' s x x0

reducible_sn :: Reducible (Sn Term0 Step_gu_naive)
reducible_sn =
  Build_reducible (\_ x -> x) (\_ t __top_assumption_ ->
    let {_evar_0_ = \f0 _view_subject_ -> f0 t _view_subject_} in
    case __top_assumption_ of {
     SNI s -> _evar_0_ s}) (\s ->
    let {_evar_0_ = \_ x -> SNI x} in
    let {_evar_0_0 = \_ _ _ _ _ _ -> Prelude.error "absurd case"} in
    let {_evar_0_1 = \_ _ _ _ _ x -> SNI x} in
    let {_evar_0_2 = \_ x -> SNI x} in
    term_rect (\s0 _ x -> _evar_0_ s0 x) (\uSort s0 k t x _ x0 ->
      _evar_0_0 uSort s0 k t x x0) (\bSort t x t0 x0 _ x1 ->
      _evar_0_1 bSort t x t0 x0 x1) (\d _ x -> _evar_0_2 d x) s)

reducible_var :: String -> (Reducible a1) -> a1
reducible_var x _view_subject_ =
  let {_top_assumption_ = \x0 -> p_nc _view_subject_ x0} in
  let {_evar_0_ = \_ _ -> Prelude.error "absurd case"} in
  _top_assumption_ (Tmvar x) _evar_0_

l_reducible :: Kind -> Reducible L
l_reducible a =
  let {
   _evar_0_ = \a0 ih1 b ih2 -> Build_reducible (\s h ->
    sn_closedL App (Tmvar (String0 (Ascii False False False True True True
      True False) EmptyString)) s
      (p_sn ih2 (Tmapp App s (Tmvar (String0 (Ascii False False False True
        True True True False) EmptyString)))
        (h (Tmvar (String0 (Ascii False False False True True True True
          False) EmptyString))
          (reducible_var (String0 (Ascii False False False True True True
            True False) EmptyString) ih1)))) (\s t x x0 t0 x1 ->
    let {x2 = x t0 x1} in
    let {h = step_gu_naive_app_l App s t0 t x0} in
    case h of {
     ExistT x3 p ->
      case p of {
       Pair a1 s0 ->
        case s0 of {
         ExistT x4 p0 ->
          case p0 of {
           Pair a2 s1 ->
            let {x5 = p_cl ih2 (Tmapp App s t0) (Tmapp App x3 x4) x2 s1} in
            _UU03b1__preserves_L_R b (Tmapp App x3 x4) (Tmapp App t t0) Nil
              (Alpha_app App x3 t x4 t0 Nil
              (alpha_sym t x3 Nil Nil Alpha_sym_nil a1)
              (alpha_sym t0 x4 Nil Nil Alpha_sym_nil a2)) x5}}}})
    (\s _ h t la ->
    let {snt = p_sn ih1 t la} in
    let {
     _evar_0_ = \t0 _ ih3 la0 ->
      p_nc ih2 (Tmapp App s t0) (\_ st ->
        case st of {
         Step_gu_naive_intro _ _ _ x x0 x1 ->
          case x of {
           Alpha_app _ _ s2 _ t2 _ x2 x3 ->
            case x1 of {
             Step_appL0 _ _ s3 _ x4 ->
              let {
               hgn = let {h0 = gu_app_l App s2 t2 x0} in
                     Step_gu_naive_intro s s2 s3 x2 h0 x4}
              in
              let {h0 = h s3 hgn} in
              let {la1 = _UU03b1__preserves_L_R a0 t0 t2 Nil x3 la0} in
              h0 t2 la1;
             Step_appR0 _ _ _ t3 x4 ->
              let {
               h0 = let {h0 = gu_app_r App s2 t2 x0} in
                    Step_gu_naive_intro t0 t2 t3 x3 h0 x4}
              in
              let {ih4 = ih3 t3 h0} in
              let {h1 = p_cl ih1 t0 t3 la0 h0} in
              let {ih5 = ih4 h1} in
              _UU03b1__preserves_L_R b (Tmapp App s t3) (Tmapp App s2 t3) Nil
                (Alpha_app App s s2 t3 t3 Nil x2
                (alpha_refl t3 Nil Alpha_refl_nil)) ih5;
             _ -> Prelude.error "absurd case"};
           _ -> Prelude.error "absurd case"}})}
    in
    sn_rect _evar_0_ t snt la)}
  in
  kind_rect (unsafeCoerce reducible_sn) (unsafeCoerce _evar_0_) a

l_sn :: Kind -> Term0 -> L -> Sn Term0 Step_gu_naive
l_sn a s las =
  let {x = l_reducible a} in p_sn x s las

l_cl :: Kind -> Term0 -> Term0 -> L -> Step_gu_naive -> L
l_cl t s t0 hstep hst =
  let {h = l_reducible t} in p_cl h s t0 hstep hst

l_nc :: Kind -> Term0 -> (Term0 -> Step_gu_naive -> L) -> L
l_nc t s hstep =
  let {h = l_reducible t} in p_nc h s hstep

l_var :: Kind -> String -> L
l_var t x =
  l_nc t (Tmvar x) (\_ _ -> Prelude.error "absurd case")

l_cl_star :: Kind -> Term0 -> Term0 -> L -> Red_gu_na -> L
l_cl_star t s t0 ls red_st =
  red_gu_na_rect (\s0 t1 _ s1 _ iHred_st ls0 ->
    iHred_st (l_cl t s0 t1 ls0 s1)) (\_ ls0 -> ls0) s t0 red_st ls

type EL = String -> Kind -> () -> SigT Term0 (Prod () L)

extend_EL :: (List (Prod String Kind)) -> (List (Prod String Term0)) ->
             String -> Kind -> Term0 -> EL -> L -> String -> Kind -> SigT
             Term0 (Prod () L)
extend_EL _ _ x _ t x0 x1 x2 t0 =
  let {b = eqb1 x2 x} in
  case b of {
   True -> ExistT t (Pair __ x1);
   False ->
    let {x3 = x0 x2 t0 __} in
    case x3 of {
     ExistT x4 p -> case p of {
                     Pair _ l -> ExistT x4 (Pair __ l)}}}

step_gu_na_lam_fold :: USort -> String -> Kind -> Term0 -> Term0 ->
                       Step_gu_naive -> SigT Term0 (Prod Step_gu_naive Alpha)
step_gu_na_lam_fold b x a s s' x0 =
  let {h0 = to_GU__alpha (Tmlam b x a s)} in
  case x0 of {
   Step_gu_naive_intro s0 s'0 t x1 x2 x3 ->
    eq_rec_r s (\_ ->
      eq_rec_r s' (\h1 h2 h3 ->
        case h0 of {
         Alpha_var _ _ sigma x4 ->
          eq_rec_r Nil (\_ -> false_rec) sigma __ __ x4;
         Alpha_lam b0 x4 y a0 s1 s2 sigma x5 ->
          eq_rec_r Nil (\_ ->
            eq_rec_r b (\_ ->
              eq_rec_r x (\_ ->
                eq_rec_r a (\_ ->
                  eq_rec_r s (\_ _ ->
                    let {
                     h4 = alpha_trans s'0 s s2 (Cons (Pair x x) Nil) (Cons
                            (Pair x y) Nil) (Cons (Pair x y) Nil)
                            (Alpha_trans_cons x x y Nil Nil Nil
                            Alpha_trans_nil)
                            (alpha_extend_ids (Cons (Pair x x) Nil) s'0 s
                              (Id_ctx_cons x Nil Id_ctx_nil)
                              (alpha_extend_ids Nil s'0 s Id_ctx_nil
                                (alpha_extend_ids Nil s'0 s Id_ctx_nil
                                  (alpha_extend_ids Nil s'0 s Id_ctx_nil
                                    (alpha_sym s s'0 (sym_alpha_ctx Nil) Nil
                                      (sym_alpha_ctx_left_is_sym Nil) h1)))))
                            (let {
                              h4 = eq_rec_r (to_GU (Tmlam b x a s)) h0 (Tmlam
                                     b y a s2)}
                             in
                             case h4 of {
                              Alpha_var _ _ sigma0 x6 ->
                               eq_rec_r Nil (\_ -> false_rec) sigma0 __ __ x6;
                              Alpha_lam b1 x6 y0 a1 s3 s4 sigma0 x7 ->
                               eq_rec_r Nil (\_ ->
                                 eq_rec_r b (\_ ->
                                   eq_rec_r x (\_ ->
                                     eq_rec_r a (\_ ->
                                       eq_rec_r s (\_ ->
                                         eq_rec_r y (\_ ->
                                           eq_rec_r s2 (\h7 -> h7) s4) y0 __)
                                         s3) a1) x6) b1 __ __ __) sigma0 __
                                 __ x7;
                              Alpha_app _ _ _ _ _ sigma0 x6 x7 ->
                               eq_rec_r Nil (\_ -> false_rec) sigma0 __ __ x6
                                 x7;
                              Alpha_builtin r _ ->
                               eq_rec_r Nil (\_ -> false_rec) r __ __})}
                    in
                    let {
                     h5 = step_naive_preserves_alpha2 s'0 s' s2 (Cons (Pair x
                            y) Nil) h2
                            (let {h5 = to_GU__GU (Tmlam b x a s)} in
                             let {
                              h6 = eq_rec_r (to_GU (Tmlam b x a s)) h5 (Tmlam
                                     b y a s2)}
                             in
                             gu_lam b y a s2 h6) h4 h3}
                    in
                    case h5 of {
                     ExistT x6 p ->
                      case p of {
                       Pair s3 a1 -> ExistT (Tmlam b y a x6) (Pair
                        (Step_gu_naive_intro (Tmlam b x a s) (Tmlam b y a s2)
                        (Tmlam b y a x6)
                        (eq_rec_r (to_GU (Tmlam b x a s)) h0 (Tmlam b y a
                          s2))
                        (let {h6 = to_GU__GU (Tmlam b x a s)} in
                         eq_rec_r (to_GU (Tmlam b x a s)) h6 (Tmlam b y a s2))
                        (Step_abs0 b y a s2 x6 s3))
                        (alpha_sym (Tmlam b x a s') (Tmlam b y a x6) Nil Nil
                          Alpha_sym_nil (Alpha_lam b x y a s' x6 Nil a1)))}})
                    s1) a0) x4) b0 __ __ __) sigma __ __ x5;
         Alpha_app _ _ _ _ _ sigma x4 x5 ->
          eq_rec_r Nil (\_ -> false_rec) sigma __ __ x4 x5;
         Alpha_builtin r _ -> eq_rec_r Nil (\_ -> false_rec) r __ __}) t) s0
      __ x1 x2 x3}

red_gu_na_lam_fold :: USort -> String -> Kind -> Term0 -> Term0 -> Red_gu_na
                      -> SigT Term0 (Prod Red_gu_na Alpha)
red_gu_na_lam_fold b x a s s' x0 =
  red_gu_na_rec (\s0 t t' s1 _ iHred_gu_na ->
    case iHred_gu_na of {
     ExistT x1 p ->
      case p of {
       Pair r a0 ->
        let {s2 = step_gu_na_lam_fold b x a s0 t s1} in
        case s2 of {
         ExistT x2 p0 ->
          case p0 of {
           Pair s3 a1 ->
            let {
             h0 = red_gu_naive_preserves_alpha (Tmlam b x a t) x1 x2 Nil
                    (alpha_extend_ids Nil (Tmlam b x a t) x2 Id_ctx_nil
                      (alpha_extend_ids Nil (Tmlam b x a t) x2 Id_ctx_nil
                        (alpha_extend_ids Nil (Tmlam b x a t) x2 Id_ctx_nil
                          (alpha_sym x2 (Tmlam b x a t) (sym_alpha_ctx Nil)
                            Nil (sym_alpha_ctx_left_is_sym Nil) a1)))) r}
            in
            case h0 of {
             ExistT x3 p1 ->
              case p1 of {
               Pair r0 a2 -> ExistT x3 (Pair (Red_gu_na_star (Tmlam b x a s0)
                x2 x3 s3 r0)
                (alpha_extend_ids Nil x3 (Tmlam b x a t') Id_ctx_nil
                  (alpha_extend_ids Nil x3 (Tmlam b x a t') Id_ctx_nil
                    (alpha_trans x3 x1 (Tmlam b x a t') Nil Nil Nil
                      Alpha_trans_nil
                      (alpha_sym x1 x3 (sym_alpha_ctx Nil) Nil
                        (sym_alpha_ctx_left_is_sym Nil) a2) a0))))}}}}}})
    (\s0 -> ExistT (Tmlam b x a s0) (Pair (Red_gu_na_nil (Tmlam b x a s0))
    (alpha_refl (Tmlam b x a s0) Nil Alpha_refl_nil))) s s' x0

step_gu_na_appl_fold :: BSort -> Term0 -> Term0 -> Term0 -> Step_gu_naive ->
                        SigT Term0 (Prod Step_gu_naive Alpha)
step_gu_na_appl_fold b s1 s2 t1 hstep_gu =
  case hstep_gu of {
   Step_gu_naive_intro s s' t x x0 x1 ->
    eq_rec_r s1 (\_ ->
      eq_rec_r s2 (\h h0 h1 ->
        let {hgu_a = to_GU__alpha (Tmapp b s1 t1)} in
        case hgu_a of {
         Alpha_var _ _ sigma x2 ->
          eq_rec_r Nil (\_ -> false_rec) sigma __ __ x2;
         Alpha_lam _ _ _ _ _ _ sigma x2 ->
          eq_rec_r Nil (\_ -> false_rec) sigma __ __ x2;
         Alpha_app b0 s3 s4 t2 t3 sigma x2 x3 ->
          eq_rec_r Nil (\_ ->
            eq_rec_r b (\_ ->
              eq_rec_r s1 (\_ ->
                eq_rec_r t1 (\_ h5 h8 ->
                  let {
                   hstep_na' = step_naive_preserves_alpha2 s' s2 s4 Nil h0
                                 (let {hgu_app = to_GU__GU (Tmapp b s1 t1)}
                                  in
                                  let {
                                   hgu_app0 = eq_rec_r
                                                (to_GU (Tmapp b s1 t1))
                                                hgu_app (Tmapp b s4 t3)}
                                  in
                                  gu_app_l b s4 t3 hgu_app0)
                                 (alpha_extend_ids Nil s' s4 Id_ctx_nil
                                   (alpha_extend_ids Nil s' s4 Id_ctx_nil
                                     (alpha_trans s' s1 s4 Nil Nil Nil
                                       Alpha_trans_nil
                                       (alpha_sym s1 s' (sym_alpha_ctx Nil)
                                         Nil (sym_alpha_ctx_left_is_sym Nil)
                                         h) h5))) h1}
                  in
                  case hstep_na' of {
                   ExistT x4 p ->
                    case p of {
                     Pair s0 a -> ExistT (Tmapp b x4 t3) (Pair
                      (Step_gu_naive_intro (Tmapp b s1 t1) (Tmapp b s4 t3)
                      (Tmapp b x4 t3)
                      (eq_rec_r (to_GU (Tmapp b s1 t1)) hgu_a (Tmapp b s4
                        t3))
                      (let {_evar_0_ = to_GU__GU (Tmapp b s1 t1)} in
                       eq_rec_r (to_GU (Tmapp b s1 t1)) _evar_0_ (Tmapp b s4
                         t3)) (Step_appL0 b s4 x4 t3 s0)) (Alpha_app b x4 s2
                      t3 t1 Nil
                      (alpha_extend_ids Nil x4 s2 Id_ctx_nil
                        (alpha_extend_ids Nil x4 s2 Id_ctx_nil
                          (alpha_extend_ids Nil x4 s2 Id_ctx_nil
                            (alpha_sym s2 x4 (sym_alpha_ctx Nil) Nil
                              (sym_alpha_ctx_left_is_sym Nil) a))))
                      (alpha_extend_ids Nil t3 t1 Id_ctx_nil
                        (alpha_extend_ids Nil t3 t1 Id_ctx_nil
                          (alpha_extend_ids Nil t3 t1 Id_ctx_nil
                            (alpha_sym t1 t3 (sym_alpha_ctx Nil) Nil
                              (sym_alpha_ctx_left_is_sym Nil) h8))))))}}) t2)
                s3) b0 __ __) sigma __ __ x2 x3;
         Alpha_builtin r _ -> eq_rec_r Nil (\_ -> false_rec) r __ __}) t) s
      __ x x0 x1}

step_gu_na_appr_fold :: BSort -> Term0 -> Term0 -> Term0 -> Step_gu_naive ->
                        SigT Term0 (Prod Step_gu_naive Alpha)
step_gu_na_appr_fold b s1 t1 t2 hstep_gu =
  case hstep_gu of {
   Step_gu_naive_intro s s' t x x0 x1 ->
    eq_rec_r t1 (\_ ->
      eq_rec_r t2 (\h h0 h1 ->
        let {hgu_a = to_GU__alpha (Tmapp b s1 t1)} in
        case hgu_a of {
         Alpha_var _ _ sigma x2 ->
          eq_rec_r Nil (\_ -> false_rec) sigma __ __ x2;
         Alpha_lam _ _ _ _ _ _ sigma x2 ->
          eq_rec_r Nil (\_ -> false_rec) sigma __ __ x2;
         Alpha_app b0 s2 s3 t3 t4 sigma x2 x3 ->
          eq_rec_r Nil (\_ ->
            eq_rec_r b (\_ ->
              eq_rec_r s1 (\_ ->
                eq_rec_r t1 (\_ h5 h8 ->
                  let {
                   hstep_na' = step_naive_preserves_alpha2 s' t2 t4 Nil h0
                                 (let {hgu_app = to_GU__GU (Tmapp b s1 t1)}
                                  in
                                  let {
                                   hgu_app0 = eq_rec_r
                                                (to_GU (Tmapp b s1 t1))
                                                hgu_app (Tmapp b s3 t4)}
                                  in
                                  gu_app_r b s3 t4 hgu_app0)
                                 (alpha_extend_ids Nil s' t4 Id_ctx_nil
                                   (alpha_extend_ids Nil s' t4 Id_ctx_nil
                                     (alpha_trans s' t1 t4 Nil Nil Nil
                                       Alpha_trans_nil
                                       (alpha_sym t1 s' (sym_alpha_ctx Nil)
                                         Nil (sym_alpha_ctx_left_is_sym Nil)
                                         h) h8))) h1}
                  in
                  case hstep_na' of {
                   ExistT x4 p ->
                    case p of {
                     Pair s0 a -> ExistT (Tmapp b s3 x4) (Pair
                      (Step_gu_naive_intro (Tmapp b s1 t1) (Tmapp b s3 t4)
                      (Tmapp b s3 x4)
                      (eq_rec_r (to_GU (Tmapp b s1 t1)) hgu_a (Tmapp b s3
                        t4))
                      (let {_evar_0_ = to_GU__GU (Tmapp b s1 t1)} in
                       eq_rec_r (to_GU (Tmapp b s1 t1)) _evar_0_ (Tmapp b s3
                         t4)) (Step_appR0 b s3 t4 x4 s0)) (Alpha_app b s3 s1
                      x4 t2 Nil
                      (alpha_extend_ids Nil s3 s1 Id_ctx_nil
                        (alpha_extend_ids Nil s3 s1 Id_ctx_nil
                          (alpha_extend_ids Nil s3 s1 Id_ctx_nil
                            (alpha_sym s1 s3 (sym_alpha_ctx Nil) Nil
                              (sym_alpha_ctx_left_is_sym Nil) h5))))
                      (alpha_extend_ids Nil x4 t2 Id_ctx_nil
                        (alpha_extend_ids Nil x4 t2 Id_ctx_nil
                          (alpha_extend_ids Nil x4 t2 Id_ctx_nil
                            (alpha_sym t2 x4 (sym_alpha_ctx Nil) Nil
                              (sym_alpha_ctx_left_is_sym Nil) a))))))}}) t3)
                s2) b0 __ __) sigma __ __ x2 x3;
         Alpha_builtin r _ -> eq_rec_r Nil (\_ -> false_rec) r __ __}) t) s
      __ x x0 x1}

red_gu_na_trans :: Term0 -> Term0 -> Term0 -> Red_gu_na -> Red_gu_na ->
                   Red_gu_na
red_gu_na_trans s t u x x0 =
  red_gu_na_rec (\s0 t0 t' s1 h iHred_gu_na u0 h0 ->
    red_gu_na_rec (\s2 t1 _ s3 _ iHred_gu_na0 t2 _ iHred_gu_na1 s4 s5 ->
      iHred_gu_na0 t2
        (iHred_gu_na1 t1 (Red_gu_na_star s2 t1 t1 s3 (Red_gu_na_nil t1)))
        (\u1 h1 -> iHred_gu_na1 u1 (Red_gu_na_star s2 t1 u1 s3 h1)) s4 s5)
      (\s2 t1 h1 _ s3 s4 -> Red_gu_na_star s3 t1 s2 s4 h1) t' u0 h0 t0 h
      iHred_gu_na s0 s1) (\s0 u0 h0 ->
    red_gu_na_rec (\s1 t0 t' s2 _ iHred_gu_na -> Red_gu_na_star s1 t0 t' s2
      iHred_gu_na) (\s1 -> Red_gu_na_nil s1) s0 u0 h0) s t x u x0

red_gu_na_appl_fold :: BSort -> Term0 -> Term0 -> Term0 -> Red_gu_na -> SigT
                       Term0 (Prod Red_gu_na Alpha)
red_gu_na_appl_fold b s1 s2 t h0 =
  red_gu_na_rec (\s t0 t' s0 _ iHred_gu_na ->
    case iHred_gu_na of {
     ExistT x p ->
      case p of {
       Pair r a ->
        let {s3 = step_gu_na_appl_fold b s t0 t s0} in
        case s3 of {
         ExistT x0 p0 ->
          case p0 of {
           Pair s4 a0 ->
            let {
             h = red_gu_naive_preserves_alpha (Tmapp b t0 t) x x0 Nil
                   (alpha_extend_ids Nil (Tmapp b t0 t) x0 Id_ctx_nil
                     (alpha_extend_ids Nil (Tmapp b t0 t) x0 Id_ctx_nil
                       (alpha_extend_ids Nil (Tmapp b t0 t) x0 Id_ctx_nil
                         (alpha_sym x0 (Tmapp b t0 t) (sym_alpha_ctx Nil) Nil
                           (sym_alpha_ctx_left_is_sym Nil) a0)))) r}
            in
            case h of {
             ExistT x1 p1 ->
              case p1 of {
               Pair r0 a1 -> ExistT x1 (Pair (Red_gu_na_star (Tmapp b s t) x0
                x1 s4 r0)
                (alpha_extend_ids Nil x1 (Tmapp b t' t) Id_ctx_nil
                  (alpha_extend_ids Nil x1 (Tmapp b t' t) Id_ctx_nil
                    (alpha_trans x1 x (Tmapp b t' t) Nil Nil Nil
                      Alpha_trans_nil
                      (alpha_sym x x1 (sym_alpha_ctx Nil) Nil
                        (sym_alpha_ctx_left_is_sym Nil) a1) a))))}}}}}})
    (\s -> ExistT (Tmapp b s t) (Pair (Red_gu_na_nil (Tmapp b s t))
    (alpha_refl (Tmapp b s t) Nil Alpha_refl_nil))) s1 s2 h0

red_gu_na_appr_fold :: BSort -> Term0 -> Term0 -> Term0 -> Red_gu_na -> SigT
                       Term0 (Prod Red_gu_na Alpha)
red_gu_na_appr_fold b s1 t1 t2 h0 =
  red_gu_na_rec (\s t t' s0 _ iHred_gu_na ->
    case iHred_gu_na of {
     ExistT x p ->
      case p of {
       Pair r a ->
        let {s2 = step_gu_na_appr_fold b s1 s t s0} in
        case s2 of {
         ExistT x0 p0 ->
          case p0 of {
           Pair s3 a0 ->
            let {
             h = red_gu_naive_preserves_alpha (Tmapp b s1 t) x x0 Nil
                   (alpha_extend_ids Nil (Tmapp b s1 t) x0 Id_ctx_nil
                     (alpha_extend_ids Nil (Tmapp b s1 t) x0 Id_ctx_nil
                       (alpha_extend_ids Nil (Tmapp b s1 t) x0 Id_ctx_nil
                         (alpha_sym x0 (Tmapp b s1 t) (sym_alpha_ctx Nil) Nil
                           (sym_alpha_ctx_left_is_sym Nil) a0)))) r}
            in
            case h of {
             ExistT x1 p1 ->
              case p1 of {
               Pair r0 a1 -> ExistT x1 (Pair (Red_gu_na_star (Tmapp b s1 s)
                x0 x1 s3 r0)
                (alpha_extend_ids Nil x1 (Tmapp b s1 t') Id_ctx_nil
                  (alpha_extend_ids Nil x1 (Tmapp b s1 t') Id_ctx_nil
                    (alpha_trans x1 x (Tmapp b s1 t') Nil Nil Nil
                      Alpha_trans_nil
                      (alpha_sym x x1 (sym_alpha_ctx Nil) Nil
                        (sym_alpha_ctx_left_is_sym Nil) a1) a))))}}}}}})
    (\s -> ExistT (Tmapp b s1 s) (Pair (Red_gu_na_nil (Tmapp b s1 s))
    (alpha_refl (Tmapp b s1 s) Nil Alpha_refl_nil))) t1 t2 h0

red_gu_na_app_fold :: BSort -> Term0 -> Term0 -> Term0 -> Term0 -> Red_gu_na
                      -> Red_gu_na -> SigT Term0 (Prod Red_gu_na Alpha)
red_gu_na_app_fold b s1 s2 t1 t2 x x0 =
  let {h = red_gu_na_appl_fold b s1 s2 t1 x} in
  case h of {
   ExistT x1 p ->
    case p of {
     Pair r a ->
      let {h0 = red_gu_na_appr_fold b s2 t1 t2 x0} in
      case h0 of {
       ExistT x2 p0 ->
        case p0 of {
         Pair r0 a0 ->
          let {
           h1 = red_gu_naive_preserves_alpha (Tmapp b s2 t1) x2 x1 Nil
                  (alpha_extend_ids Nil (Tmapp b s2 t1) x1 Id_ctx_nil
                    (alpha_extend_ids Nil (Tmapp b s2 t1) x1 Id_ctx_nil
                      (alpha_extend_ids Nil (Tmapp b s2 t1) x1 Id_ctx_nil
                        (alpha_sym x1 (Tmapp b s2 t1) (sym_alpha_ctx Nil) Nil
                          (sym_alpha_ctx_left_is_sym Nil) a)))) r0}
          in
          case h1 of {
           ExistT x3 p1 ->
            case p1 of {
             Pair r1 a1 -> ExistT x3 (Pair
              (red_gu_na_trans (Tmapp b s1 t1) x1 x3 r r1)
              (alpha_extend_ids Nil x3 (Tmapp b s2 t2) Id_ctx_nil
                (alpha_extend_ids Nil x3 (Tmapp b s2 t2) Id_ctx_nil
                  (alpha_trans x3 x2 (Tmapp b s2 t2) Nil Nil Nil
                    Alpha_trans_nil
                    (alpha_sym x2 x3 (sym_alpha_ctx Nil) Nil
                      (sym_alpha_ctx_left_is_sym Nil) a1) a0))))}}}}}}

red_beta :: String -> Term0 -> Term0 -> Term0 -> Step_gu_naive -> NC -> NC ->
            SigT Term0 (Prod Red_gu_na Alpha)
red_beta x s t1 t2 hstep =
  term_rec (\s0 x0 x1 ->
    let {b = eqb1 x s0} in
    case b of {
     True ->
      eq_rec_r s0 (\_ _ ->
        let {
         _evar_0_ = ExistT t2 (Pair (Red_gu_na_star t1 t2 t2 hstep
          (Red_gu_na_nil t2)) (alpha_refl t2 Nil Alpha_refl_nil))}
        in
        eq_rec_r True _evar_0_ (eqb1 s0 s0)) x x0 x1;
     False ->
      let {
       _evar_0_ = ExistT (Tmvar s0) (Pair (Red_gu_na_nil (Tmvar s0))
        (alpha_refl (Tmvar s0) Nil Alpha_refl_nil))}
      in
      eq_rec_r False _evar_0_ (eqb1 x s0)}) (\uSort s0 k s1 iHs x0 x1 ->
    let {
     h2 = iHs (nc_lam uSort s0 s1 k (Cons (Pair x t1) Nil) x0)
            (nc_lam uSort s0 s1 k (Cons (Pair x t2) Nil) x1)}
    in
    case h2 of {
     ExistT x2 p ->
      case p of {
       Pair r a ->
        let {h3 = red_gu_na_lam_fold uSort s0 k (sub x t1 s1) x2 r} in
        case h3 of {
         ExistT x3 p0 ->
          case p0 of {
           Pair r0 a0 -> ExistT x3 (Pair r0
            (alpha_trans x3 (Tmlam uSort s0 k x2) (Tmlam uSort s0 k
              (sub x t2 s1)) Nil Nil Nil Alpha_trans_nil a0 (Alpha_lam uSort
              s0 s0 k x2 (sub x t2 s1) Nil
              (alpha_extend_id' x2 (sub x t2 s1) s0 Nil a
                (Not_break_shadow_nil s0)))))}}}})
    (\bSort s1 iHs1 s2 iHs2 x0 x1 ->
    let {
     h1 = iHs1 (nc_app_l bSort s1 s2 (Cons (Pair x t1) Nil) x0)
            (nc_app_l bSort s1 s2 (Cons (Pair x t2) Nil) x1)}
    in
    case h1 of {
     ExistT x2 p ->
      case p of {
       Pair r a ->
        let {
         h2 = iHs2 (nc_app_r bSort s1 s2 (Cons (Pair x t1) Nil) x0)
                (nc_app_r bSort s1 s2 (Cons (Pair x t2) Nil) x1)}
        in
        case h2 of {
         ExistT x3 p0 ->
          case p0 of {
           Pair r0 a0 ->
            let {
             ha_g2 = eq_rec_r (sub x t2 s2) a0
                       (subs (Cons (Pair x t2) Nil) s2)}
            in
            let {
             hred_g2 = eq_rec_r (sub x t1 s2) r0
                         (subs (Cons (Pair x t1) Nil) s2)}
            in
            let {
             ha_g1 = eq_rec_r (sub x t2 s1) a
                       (subs (Cons (Pair x t2) Nil) s1)}
            in
            let {
             hred_g1 = eq_rec_r (sub x t1 s1) r
                         (subs (Cons (Pair x t1) Nil) s1)}
            in
            let {
             _evar_0_ = let {
                         _evar_0_ = let {
                                     h3 = red_gu_na_app_fold bSort
                                            (subs (Cons (Pair x t1) Nil) s1)
                                            x2
                                            (subs (Cons (Pair x t1) Nil) s2)
                                            x3 hred_g1 hred_g2}
                                    in
                                    case h3 of {
                                     ExistT x4 p1 ->
                                      case p1 of {
                                       Pair r1 a1 -> ExistT x4 (Pair r1
                                        (alpha_trans x4 (Tmapp bSort x2 x3)
                                          (sub x t2 (Tmapp bSort s1 s2)) Nil
                                          Nil Nil Alpha_trans_nil a1
                                          (alpha_extend_ids Nil (Tmapp bSort
                                            x2 x3)
                                            (sub x t2 (Tmapp bSort s1 s2))
                                            Id_ctx_nil
                                            (alpha_extend_ids Nil (Tmapp
                                              bSort x2 x3)
                                              (sub x t2 (Tmapp bSort s1 s2))
                                              Id_ctx_nil
                                              (alpha_extend_ids Nil (Tmapp
                                                bSort x2 x3)
                                                (sub x t2 (Tmapp bSort s1
                                                  s2)) Id_ctx_nil (Alpha_app
                                                bSort x2
                                                (let {
                                                  sub0 x5 u t =
                                                    case t of {
                                                     Tmvar y ->
                                                      case eqb1 x5 y of {
                                                       True -> u;
                                                       False -> Tmvar y};
                                                     Tmlam b y k1 t' -> Tmlam
                                                      b y k1 (sub0 x5 u t');
                                                     Tmapp b t3 t4 -> Tmapp b
                                                      (sub0 x5 u t3)
                                                      (sub0 x5 u t4);
                                                     Tmbuiltin d -> Tmbuiltin
                                                      d}}
                                                 in sub0 x t2 s1) x3
                                                (let {
                                                  sub0 x5 u t =
                                                    case t of {
                                                     Tmvar y ->
                                                      case eqb1 x5 y of {
                                                       True -> u;
                                                       False -> Tmvar y};
                                                     Tmlam b y k1 t' -> Tmlam
                                                      b y k1 (sub0 x5 u t');
                                                     Tmapp b t3 t4 -> Tmapp b
                                                      (sub0 x5 u t3)
                                                      (sub0 x5 u t4);
                                                     Tmbuiltin d -> Tmbuiltin
                                                      d}}
                                                 in sub0 x t2 s2) Nil ha_g1
                                                ha_g2))))))}}}
                        in
                        eq_rec_r (sub x t2 (Tmapp bSort s1 s2)) _evar_0_
                          (subs (Cons (Pair x t2) Nil) (Tmapp bSort s1 s2))}
            in
            eq_rec_r (sub x t1 (Tmapp bSort s1 s2)) _evar_0_
              (subs (Cons (Pair x t1) Nil) (Tmapp bSort s1 s2))}}}})
    (\d _ _ -> ExistT (Tmbuiltin d) (Pair (Red_gu_na_nil (Tmbuiltin d))
    (Alpha_builtin Nil d))) s

beta_expansion' :: BSort -> USort -> Kind -> Kind -> String -> String ->
                   Term0 -> Term0 -> Term0 -> Alpha -> GU -> NC -> (Sn 
                   Term0 Step_gu_naive) -> L -> L
beta_expansion' bA bL a b x y s s' t ha_s' gu nc snt h =
  let {sns = sn_subst x t s nc (l_sn a (sub x t s) h)} in
  let {
   x0 = _UU03b1__preserves_SN_R s s' (sym_alpha_ctx (Cons (Pair y x) Nil))
          (alpha_sym s' s
            (sym_alpha_ctx (sym_alpha_ctx (Cons (Pair y x) Nil)))
            (sym_alpha_ctx (Cons (Pair y x) Nil))
            (sym_alpha_ctx_left_is_sym (sym_alpha_ctx (Cons (Pair y x) Nil)))
            (alpha_sym s s' (sym_alpha_ctx (Cons (Pair y x) Nil))
              (sym_alpha_ctx (sym_alpha_ctx (Cons (Pair y x) Nil)))
              (sym_alpha_ctx_is_sym (sym_alpha_ctx (Cons (Pair y x) Nil)))
              (alpha_sym s' s (Cons (Pair y x) Nil)
                (sym_alpha_ctx (Cons (Pair y x) Nil))
                (sym_alpha_ctx_is_sym (Cons (Pair y x) Nil)) ha_s'))) sns}
  in
  sn_rect (\x1 _ x2 t0 snt0 s0 ha hnc ->
    let {
     _evar_0_ = \x3 s1 x4 hnc0 nc0 h0 ->
      l_nc a (Tmapp bA (Tmlam bL y b x1) x3) (\_ st ->
        case st of {
         Step_gu_naive_intro _ _ _ x5 x6 x7 ->
          case x5 of {
           Alpha_app _ _ _ _ t2 _ x8 x9 ->
            case x8 of {
             Alpha_lam _ _ y0 _ _ s2 _ x10 ->
              case x7 of {
               Step_beta0 _ _ _ _ ->
                _UU03b1__preserves_L_R a (sub x x3 s0) (sub y0 t2 s2) Nil
                  (alpha_rename_binder_stronger x y0 s0 x3 t2 Nil s2 (Cons
                    (Pair x y0) Nil)
                    (alpha_sym s2 s0 (sym_alpha_ctx (Cons (Pair x y0) Nil))
                      (Cons (Pair x y0) Nil)
                      (sym_alpha_ctx_left_is_sym (Cons (Pair x y0) Nil))
                      (alpha_trans s2 x1 s0 (Cons (Pair y0 y) Nil) (Cons
                        (Pair y x) Nil)
                        (sym_alpha_ctx (Cons (Pair x y0) Nil))
                        (Alpha_trans_cons y0 y x Nil Nil Nil Alpha_trans_nil)
                        (alpha_sym x1 s2
                          (sym_alpha_ctx (Cons (Pair y0 y) Nil)) (Cons (Pair
                          y0 y) Nil)
                          (sym_alpha_ctx_left_is_sym (Cons (Pair y0 y) Nil))
                          x10) ha)) x9 (Lrs_cons x y0 Nil Nil Lrs_nil) nc0
                    (gu_applam_to_nc App Lam s2 t2 y0 b x6)) h0;
               Step_appL0 _ _ _ _ x11 ->
                case x11 of {
                 Step_abs0 _ _ _ _ s3 x12 ->
                  let {
                   h1 = alpha_trans (to_GU x1) x1 s2 (Cons (Pair y y) Nil)
                          (Cons (Pair y y0) Nil) (Cons (Pair y y0) Nil)
                          (Alpha_trans_cons y y y0 Nil Nil Nil
                          Alpha_trans_nil)
                          (alpha_extend_ids (Cons (Pair y y) Nil) (to_GU x1)
                            x1 (Id_ctx_cons y Nil Id_ctx_nil)
                            (alpha_sym x1 (to_GU x1) Nil Nil Alpha_sym_nil
                              (to_GU__alpha x1))) x10}
                  in
                  let {
                   h2 = step_naive_preserves_alpha2 s2 s3 (to_GU x1) (Cons
                          (Pair y0 y) Nil)
                          (gu_lam bL y0 b s2
                            (gu_app_l bA (Tmlam bL y0 b s2) t2 x6))
                          (to_GU__GU x1)
                          (alpha_sym (to_GU x1) s2
                            (sym_alpha_ctx (Cons (Pair y0 y) Nil)) (Cons
                            (Pair y0 y) Nil)
                            (sym_alpha_ctx_left_is_sym (Cons (Pair y0 y)
                              Nil)) h1) x12}
                  in
                  case h2 of {
                   ExistT x13 p ->
                    case p of {
                     Pair s4 a0 ->
                      let {
                       hstep_s5' = Step_gu_naive_intro x1 (to_GU x1) x13
                        (to_GU__alpha x1) (to_GU__GU x1) s4}
                      in
                      _UU03b1__preserves_L_R a (Tmapp bA (Tmlam bL y b x13)
                        x3) (Tmapp bA (Tmlam bL y0 b s3) t2) Nil
                        (alpha_extend_ids Nil (Tmapp bA (Tmlam bL y b x13)
                          x3) (Tmapp bA (Tmlam bL y0 b s3) t2) Id_ctx_nil
                          (Alpha_app bA (Tmlam bL y b x13) (Tmlam bL y0 b s3)
                          x3 t2 Nil (Alpha_lam bL y y0 b x13 s3 Nil
                          (alpha_sym s3 x13
                            (sym_alpha_ctx (Cons (Pair y y0) Nil)) (Cons
                            (Pair y y0) Nil)
                            (sym_alpha_ctx_left_is_sym (Cons (Pair y y0)
                              Nil)) a0)) x9))
                        (let {x14 = x2 x13 hstep_s5' x3} in
                         case hstep_s5' of {
                          Step_gu_naive_intro _ s'0 _ x15 x16 x17 ->
                           let {hSN_x1 = SNI s1} in
                           let {
                            h4 = step_naive_preserves_alpha2 s'0 x13 s0 (Cons
                                   (Pair y x) Nil) x16 hnc0
                                   (alpha_trans s'0 x1 s0 (Cons (Pair y y)
                                     Nil) (Cons (Pair y x) Nil) (Cons (Pair y
                                     x) Nil) (Alpha_trans_cons y y x Nil Nil
                                     Nil Alpha_trans_nil)
                                     (alpha_extend_ids (Cons (Pair y y) Nil)
                                       s'0 x1 (Id_ctx_cons y Nil Id_ctx_nil)
                                       (alpha_extend_ids Nil s'0 x1
                                         Id_ctx_nil
                                         (alpha_sym x1 s'0
                                           (sym_alpha_ctx Nil) Nil
                                           (sym_alpha_ctx_left_is_sym Nil)
                                           x15))) ha) x17}
                           in
                           case h4 of {
                            ExistT x18 p0 ->
                             case p0 of {
                              Pair s5 a1 ->
                               let {x19 = x14 hSN_x1 (to_GU' x x3 x18)} in
                               let {s'_a1 = to_GU' x x3 x18} in
                               let {
                                h5 = alpha_trans x13 x18 s'_a1 (Cons (Pair y
                                       x) Nil)
                                       (ctx_id_right (Cons (Pair y x) Nil))
                                       (Cons (Pair y x) Nil)
                                       (Alpha_trans_cons y x x Nil Nil Nil
                                       Alpha_trans_nil) a1
                                       (alpha_extend_ids
                                         (ctx_id_right (Cons (Pair y x) Nil))
                                         x18 s'_a1 (Id_ctx_cons x Nil
                                         Id_ctx_nil)
                                         (to_GU'__alpha x x3 x18))}
                               in
                               x19 h5 (to_GU'__GU x x3 x18)
                                 (to_GU'__NC x x3 x18)
                                 (let {
                                   h6 = step_subst_single Nil x x3 s0 x18
                                          s'_a1 s5 hnc0 nc0
                                          (to_GU'__alpha x x3 x18)
                                          (Alpha_ctx_cons Nil Nil Nil x x x3
                                          x3 (Alpha_ctx_nil Nil)
                                          (Alpha_var_refl x)
                                          (alpha_refl x3 Nil Alpha_refl_nil))
                                          (to_GU'__NC x x3 x18)}
                                  in
                                  case h6 of {
                                   ExistT x20 p1 ->
                                    case p1 of {
                                     Pair s6 a2 ->
                                      _UU03b1__preserves_L_R a x20
                                        (sub x x3 s'_a1) Nil a2
                                        (l_cl a (sub x x3 s0) x20 h0 s6)}})}}})}};
                 _ -> Prelude.error "absurd case"};
               Step_appR0 _ _ _ t3 x11 ->
                _UU03b1__preserves_L_R a (Tmapp bA (Tmlam bL y b x1) t3)
                  (Tmapp bA (Tmlam bL y0 b s2) t3) Nil
                  (alpha_extend_ids Nil (Tmapp bA (Tmlam bL y b x1) t3)
                    (Tmapp bA (Tmlam bL y0 b s2) t3) Id_ctx_nil
                    (alpha_extend_ids Nil (Tmapp bA (Tmlam bL y b x1) t3)
                      (Tmapp bA (Tmlam bL y0 b s2) t3) Id_ctx_nil (Alpha_app
                      bA (Tmlam bL y b x1) (Tmlam bL y0 b s2) t3 t3 Nil x8
                      (alpha_refl t3 Nil Alpha_refl_nil))))
                  (x4 t3 (Step_gu_naive_intro x3 t2 t3 x9
                    (gu_app_r bA (Tmlam bL y0 b s2) t2 x6) x11) hnc0
                    (step_naive_preserves_nc_ctx s0 t2 t3 x x11
                      (alpha_preserves_nc_ctx s0 x x3 t2 x9 nc0))
                    (let {
                      h1 = red_beta x s0 x3 t3 (Step_gu_naive_intro x3 t2 t3
                             x9 (gu_app_r bA (Tmlam bL y0 b s2) t2 x6) x11)
                             nc0
                             (step_naive_preserves_nc_ctx s0 t2 t3 x x11
                               (alpha_preserves_nc_ctx s0 x x3 t2 x9 nc0))}
                     in
                     case h1 of {
                      ExistT x12 p ->
                       case p of {
                        Pair r a0 ->
                         let {h2 = l_cl_star a (sub x x3 s0) x12 h0 r} in
                         _UU03b1__preserves_L_R a x12 (sub x t3 s0) Nil a0 h2}}));
               Step_abs0 _ _ _ _ _ _ -> Prelude.error "absurd case"};
             _ -> Prelude.error "absurd case"};
           _ -> Prelude.error "absurd case"}})}
    in
    sn_rect _evar_0_ t0 snt0 hnc) s' x0 t snt s ha_s' gu nc h

beta_expansion_subst :: BSort -> USort -> String -> Term0 -> (List
                        (Prod String Term0)) -> Term0 -> Kind -> Kind -> NC
                        -> (Sn Term0 Step_gu_naive) -> L -> L
beta_expansion_subst bA bL x t sigma s a b nc snt h =
  _UU03b1__preserves_L_R a (Tmapp bA (Tmlam bL x b
    (to_GU' x t (subs sigma s))) t) (Tmapp bA (Tmlam bL x b (subs sigma s))
    t) Nil (Alpha_app bA (Tmlam bL x b (to_GU' x t (subs sigma s))) (Tmlam bL
    x b (subs sigma s)) t t Nil (Alpha_lam bL x x b
    (to_GU' x t (subs sigma s)) (subs sigma s) Nil
    (alpha_extend_ids (Cons (Pair x x) Nil) (to_GU' x t (subs sigma s))
      (subs sigma s) (Id_ctx_cons x Nil Id_ctx_nil)
      (alpha_sym (subs sigma s) (to_GU' x t (subs sigma s)) Nil Nil
        Alpha_sym_nil (to_GU'__alpha x t (subs sigma s)))))
    (alpha_refl t Nil Alpha_refl_nil))
    (let {
      h0 = _UU03b1__preserves_L_R a (sub x t (subs sigma s))
             (sub x t (to_GU' x t (subs sigma s))) Nil
             (subs_preserves_alpha__UU03c3__R (subs sigma s) Nil
               (to_GU' x t (subs sigma s)) (Cons (Pair x t) Nil) (Cons (Pair
               x t) Nil) nc (to_GU'__NC x t (subs sigma s))
               (to_GU'__alpha x t (subs sigma s))
               (alpha_ctx_ren_nil (Cons (Pair x t) Nil))) h}
     in
     beta_expansion' bA bL a b x x (to_GU' x t (subs sigma s))
       (to_GU' x t (subs sigma s)) t
       (alpha_extend_ids (Cons (Pair x x) Nil) (to_GU' x t (subs sigma s))
         (to_GU' x t (subs sigma s)) (Id_ctx_cons x Nil Id_ctx_nil)
         (alpha_refl (to_GU' x t (subs sigma s)) Nil Alpha_refl_nil))
       (to_GU'__GU x t (subs sigma s)) (to_GU'__NC x t (subs sigma s)) snt h0)

soundness :: (List (Prod BinderTyname Kind)) -> Term0 -> Kind -> Has_kind0 ->
             GU -> (List (Prod String Term0)) -> NC -> ParSeq -> EL -> L
soundness gamma s a _top_assumption_ x sigma x0 x1 x2 =
  let {
   _evar_0_ = \_ x3 a0 _ _ _ _ hEL ->
    let {hEL0 = hEL x3 a0 __} in
    case hEL0 of {
     ExistT _ p -> case p of {
                    Pair _ l -> l}}}
  in
  let {
   _evar_0_0 = \_ t1 t2 _ x3 _ x4 x5 sigma0 x6 x7 x8 ->
    sn_ty_fun Fun (subs sigma0 t1) (subs sigma0 t2)
      (x3 (gu_app_l Fun t1 t2 x5) sigma0 __ (nc_app_l Fun t1 t2 sigma0 x6) x7
        x8)
      (x4 (gu_app_r Fun t1 t2 x5) sigma0 __ (nc_app_r Fun t1 t2 sigma0 x6) x7
        x8)}
  in
  let {
   _evar_0_1 = \_ f0 t k _ x3 _ x4 x5 sigma0 x6 x7 x8 ->
    sn_ty_fun IFix (subs sigma0 f0) (subs sigma0 t)
      (l_sn (Kind_Arrow (Kind_Arrow k Kind_Base) (Kind_Arrow k Kind_Base))
        (subs sigma0 f0)
        (x4 (gu_app_l IFix f0 t x5) sigma0 __ (nc_app_l IFix f0 t sigma0 x6)
          x7 x8))
      (l_sn k (subs sigma0 t)
        (x3 (gu_app_r IFix f0 t x5) sigma0 __ (nc_app_r IFix f0 t sigma0 x6)
          x7 x8))}
  in
  let {
   _evar_0_2 = \_UU0394_ x3 k t _ x4 x5 sigma0 x6 x7 x8 ->
    sn_ty_forall ForAll x3 k (subs sigma0 t)
      (x4 (gu_lam ForAll x3 k t x5) (Cons (Pair x3 (Tmvar x3)) sigma0) __
        (Nc_cons t x3 (Tmvar x3) sigma0 (nc_lam ForAll x3 t k sigma0 x6))
        (ParSeq_cons x3 (Tmvar x3) sigma0 x7) (\x9 x10 _ ->
        extend_EL _UU0394_ sigma0 x3 k (Tmvar x3) x8 (l_var k x3) x9 x10))}
  in
  let {
   _evar_0_3 = \_ _ _ _ _ _ _ _ -> SNI (\_ _ -> Prelude.error "absurd case")}
  in
  let {
   _evar_0_4 = \gamma0 x3 a0 s0 b _ ih gu sigma0 nc blabla eL t x4 ->
    let {t'R = t_constr t s0 sigma0 x3} in
    case t'R of {
     Pair t0 l ->
      let {
       ih0 = ih (gu_lam Lam x3 a0 s0 gu) (Cons (Pair x3 t0) sigma0) __
               (t_constr__nc_s t t0 l s0 sigma0 x3
                 (nc_lam Lam x3 s0 a0 sigma0 nc))}
      in
      let {hparseq = ParSeq_cons x3 t0 sigma0 blabla} in
      let {
       ih1 = ih0 hparseq (\x5 x6 _ ->
               extend_EL gamma0 sigma0 x3 a0 t0 eL
                 (_UU03b1__preserves_L_R a0 t t0 l
                   (t_constr__a_t t t0 l s0 sigma0 x3) x4) x5 x6)}
      in
      let {
       ih2 = beta_expansion_subst App Lam x3 t0 sigma0 s0 b a0
               (t_constr__nc_subs t t0 l s0 sigma0 x3)
               (_UU03b1__preserves_SN_R t t0 l
                 (t_constr__a_t t t0 l s0 sigma0 x3) (l_sn a0 t x4)) ih1}
      in
      _UU03b1__preserves_L_R b (Tmapp App (subs sigma0 (Tmlam Lam x3 a0 s0))
        t0) (Tmapp App (subs sigma0 (Tmlam Lam x3 a0 s0)) t)
        (sym_alpha_ctx l) (Alpha_app App (subs sigma0 (Tmlam Lam x3 a0 s0))
        (subs sigma0 (Tmlam Lam x3 a0 s0)) t0 t (sym_alpha_ctx l)
        (alpha_sym (subs sigma0 (Tmlam Lam x3 a0 s0))
          (subs sigma0 (Tmlam Lam x3 a0 s0)) l (sym_alpha_ctx l)
          (sym_alpha_ctx_is_sym l)
          (let {
            _evar_0_4 = let {
                         _evar_0_4 = subs_preserves_alpha__UU03c3__R (Tmlam
                                       Lam x3 a0 s0) l (Tmlam Lam x3 a0 s0)
                                       sigma0 sigma0 nc nc (Alpha_lam Lam x3
                                       x3 a0 s0 s0 l
                                       (alpha_extend_id'' s0 x3 l
                                         (t_constr__a_s t t0 l s0 sigma0 x3
                                           (gu_lam Lam x3 a0 s0 gu))))
                                       (t_constr__a_sigma t t0 l s0 sigma0
                                         x3)}
                        in
                        eq_rec_r (psubs sigma0 (Tmlam Lam x3 a0 s0))
                          _evar_0_4 (subs sigma0 (Tmlam Lam x3 a0 s0))}
           in
           eq_rec_r (psubs sigma0 (Tmlam Lam x3 a0 s0)) _evar_0_4
             (subs sigma0 (Tmlam Lam x3 a0 s0))))
        (alpha_sym t t0 l (sym_alpha_ctx l) (sym_alpha_ctx_is_sym l)
          (t_constr__a_t t t0 l s0 sigma0 x3))) ih2}}
  in
  let {
   _evar_0_5 = \_ s0 t _ _ _ ih1 _ ih2 gu sigma0 nc blabla hEL ->
    let {ih3 = ih1 (gu_app_l App s0 t gu) sigma0} in
    let {ih4 = ih3 __ (nc_app_l App s0 t sigma0 nc) blabla hEL} in
    let {
     ih5 = ih2 (gu_app_r App s0 t gu) sigma0 __ (nc_app_r App s0 t sigma0 nc)
             blabla hEL}
    in
    ih4 (subs sigma0 t) ih5}
  in
  has_kind_rect (\gamma0 x3 a0 _ gu sigma0 _ nc ->
    _evar_0_ gamma0 x3 a0 gu sigma0 nc)
    (\_UU0394_ t1 t2 h x3 h0 x4 x5 sigma0 _ x6 ->
    unsafeCoerce _evar_0_0 _UU0394_ t1 t2 h x3 h0 x4 x5 sigma0 x6)
    (\_UU0394_ f0 t k h x3 h0 x4 x5 sigma0 _ x6 ->
    unsafeCoerce _evar_0_1 _UU0394_ f0 t k h x3 h0 x4 x5 sigma0 x6)
    (\_UU0394_ x3 k t h x4 x5 sigma0 _ x6 ->
    unsafeCoerce _evar_0_2 _UU0394_ x3 k t h x4 x5 sigma0 x6)
    (\_UU0394_ t h x3 sigma0 _ x4 ->
    unsafeCoerce _evar_0_3 _UU0394_ t h x3 sigma0 x4)
    (\gamma0 x3 a0 s0 b _H ih gu sigma0 _ nc ->
    unsafeCoerce _evar_0_4 gamma0 x3 a0 s0 b _H ih gu sigma0 nc)
    (\gamma0 s0 t a0 b _H ih1 _H0 ih2 gu sigma0 _ nc ->
    unsafeCoerce _evar_0_5 gamma0 s0 t a0 b _H ih1 _H0 ih2 gu sigma0 nc)
    gamma s a _top_assumption_ x sigma __ x0 x1 x2

id_subst__EL :: (List (Prod String Kind)) -> String -> Kind -> SigT Term0
                (Prod () L)
id_subst__EL e x t =
  list_rect (\_ _ _ -> Prelude.error "absurd case") (\a e0 iHE x0 x1 _ ->
    case a of {
     Pair s k ->
      extend_EL e0 (id_subst e0) s k (Tmvar s) iHE (l_var k s) x0 x1}) e x t
    __

id_subst__ParSeq :: (List (Prod String Term0)) -> IdSubst -> ParSeq
id_subst__ParSeq _UU03c3_ x =
  list_rec (\_ -> ParSeq_nil) (\a _UU03c3_0 iH_UU03c3_ h ->
    case a of {
     Pair s t -> ParSeq_cons s t _UU03c3_0
      (iH_UU03c3_
        (case h of {
          Id_subst_nil -> false_rec;
          Id_subst_cons x0 sigma x1 ->
           eq_rec_r s (\_ _ -> eq_rec_r _UU03c3_0 (\h1 -> h1) sigma) x0 __ __
             x1}))}) _UU03c3_ x

type_L :: (List (Prod String Kind)) -> Term0 -> Kind -> Has_kind0 -> L
type_L e s t htype =
  let {hEL = \x x0 -> id_subst__EL e x x0} in
  let {s' = s_constr s (id_subst e)} in
  let {
   htype0 = alpha_preserves_typing Nil s s' t e e
              (s_constr__a_s s s' (id_subst e)) htype}
  in
  let {
   htype1 = soundness e s' t htype0 (s_constr__gu s s' (id_subst e))
              (id_subst e) (s_constr__nc_s s s' (id_subst e))
              (id_subst__ParSeq (id_subst e) (id_subst_is_IdSubst e))
              (\x x0 _ -> hEL x x0)}
  in
  _UU03b1__preserves_L_R t s' s Nil
    (alpha_sym s s' Nil Nil Alpha_sym_nil (s_constr__a_s s s' (id_subst e)))
    htype1

sN_naive :: (List (Prod BinderTyname Kind)) -> Term0 -> Kind -> Has_kind0 ->
            Sn Term0 Step_gu_naive
sN_naive e s t x =
  let {h = type_L e s t x} in l_sn t s h

data Step_nd =
   Step_beta_nd String Kind Term0 Term0
 | Step_appL_nd BSort Term0 Term0 Term0 Step_nd
 | Step_appR_nd BSort Term0 Term0 Term0 Step_nd
 | Step_abs_nd USort String Kind Term0 Term0 Step_nd

step_nd_rect :: (String -> Kind -> Term0 -> Term0 -> a1) -> (BSort -> Term0
                -> Term0 -> Term0 -> Step_nd -> a1 -> a1) -> (BSort -> Term0
                -> Term0 -> Term0 -> Step_nd -> a1 -> a1) -> (USort -> String
                -> Kind -> Term0 -> Term0 -> Step_nd -> a1 -> a1) -> Term0 ->
                Term0 -> Step_nd -> a1
step_nd_rect f0 f1 f2 f3 _ _ s =
  case s of {
   Step_beta_nd x a s0 t -> f0 x a s0 t;
   Step_appL_nd b s1 s2 t s0 ->
    f1 b s1 s2 t s0 (step_nd_rect f0 f1 f2 f3 s1 s2 s0);
   Step_appR_nd b s0 t1 t2 s1 ->
    f2 b s0 t1 t2 s1 (step_nd_rect f0 f1 f2 f3 t1 t2 s1);
   Step_abs_nd b x a s1 s2 s0 ->
    f3 b x a s1 s2 s0 (step_nd_rect f0 f1 f2 f3 s1 s2 s0)}

step_nd_rec :: (String -> Kind -> Term0 -> Term0 -> a1) -> (BSort -> Term0 ->
               Term0 -> Term0 -> Step_nd -> a1 -> a1) -> (BSort -> Term0 ->
               Term0 -> Term0 -> Step_nd -> a1 -> a1) -> (USort -> String ->
               Kind -> Term0 -> Term0 -> Step_nd -> a1 -> a1) -> Term0 ->
               Term0 -> Step_nd -> a1
step_nd_rec =
  step_nd_rect

gU_step_d_implies_step_na :: Term0 -> Term0 -> GU -> Step_nd -> Step_naive
gU_step_d_implies_step_na t t' hGU_vars h =
  step_nd_rec (\x a s t0 _ ->
    let {_evar_0_ = Step_beta0 x a s t0} in
    eq_rec_r (sub x t0 s) _evar_0_ (substituteTCA x t0 s))
    (\b s1 s2 t0 _ iHstep_nd hGU_vars0 -> Step_appL0 b s1 s2 t0
    (case hGU_vars0 of {
      GU_app b0 s t1 x x0 ->
       eq_rec_r b (\_ ->
         eq_rec_r s1 (\_ -> eq_rec_r t0 (\h2 _ _ _ -> iHstep_nd h2) t1) s) b0
         __ __ x x0 __ __;
      GU_lam _ _ _ _ x -> false_rec x __;
      _ -> false_rec})) (\b s t1 t2 _ iHstep_nd hGU_vars0 -> Step_appR0 b s
    t1 t2
    (case hGU_vars0 of {
      GU_app b0 s0 t0 x x0 ->
       eq_rec_r b (\_ ->
         eq_rec_r s (\_ -> eq_rec_r t1 (\_ h4 _ _ -> iHstep_nd h4) t0) s0) b0
         __ __ x x0 __ __;
      GU_lam _ _ _ _ x -> false_rec x __;
      _ -> false_rec})) (\b x a s1 s2 _ iHstep_nd hGU_vars0 -> Step_abs0 b x
    a s1 s2
    (case hGU_vars0 of {
      GU_app _ _ _ x0 x1 -> false_rec x0 x1 __ __;
      GU_lam b0 x0 a0 s x1 ->
       eq_rec_r b (\_ ->
         eq_rec_r x (\_ ->
           eq_rec_r a (\_ -> eq_rec_r s1 (\h2 _ -> iHstep_nd h2) s) a0) x0)
         b0 __ __ __ x1 __;
      _ -> false_rec})) t t' h hGU_vars

subs_preserves_alpha' :: String -> Term0 -> Term0 -> Term0 -> Term0 -> (List
                         (Prod String String)) -> (List (Prod String String))
                         -> (List (Prod String String)) -> Alpha -> Alpha ->
                         Coq__UU03b1_CtxTrans -> Alpha -> Alpha -> Alpha
subs_preserves_alpha' x t i =
  term_rec (\xi _ _ r1 r2 r ha_X ha_T htrans h_UU03b1_s h_UU03b1_s' ->
    case h_UU03b1_s of {
     Alpha_var x0 y sigma x1 ->
      eq_rec_r r1 (\_ _ ->
        eq_rec_r xi (\h_UU03b1_vs ->
          case h_UU03b1_s' of {
           Alpha_var x2 y0 sigma0 x3 ->
            eq_rec_r r2 (\_ ->
              eq_rec_r xi (\_ h_UU03b1_vs' ->
                let {
                 _evar_0_ = let {
                             _evar_0_ = let {
                                         h_UU03b1_v = alpha_var_trans x0 xi
                                                        y0 r1 r2 r htrans
                                                        h_UU03b1_vs
                                                        h_UU03b1_vs'}
                                        in
                                        let {b = eqb1 x x0} in
                                        case b of {
                                         True ->
                                          eq_rec_r x0 (\ha_X0 ->
                                            case ha_X0 of {
                                             Alpha_var x4 y1 sigma1 x5 ->
                                              eq_rec_r r (\_ ->
                                                eq_rec_r x0 (\_ ->
                                                  eq_rec_r x0 (\h2 ->
                                                    eq_rec_r y0 (\_ _ _ _ ->
                                                      eq_rec_r True ha_T
                                                        (eqb1 y0 y0)) x0
                                                      ha_X0 h_UU03b1_s
                                                      h_UU03b1_vs h2) y1) x4)
                                                sigma1 __ __ x5;
                                             Alpha_lam _ _ _ _ _ _ sigma1
                                              x4 ->
                                              eq_rec_r r (\_ -> false_rec)
                                                sigma1 __ __ x4;
                                             Alpha_app _ _ _ _ _ sigma1 x4
                                              x5 ->
                                              eq_rec_r r (\_ -> false_rec)
                                                sigma1 __ __ x4 x5;
                                             Alpha_builtin r0 _ ->
                                              eq_rec_r r (\_ -> false_rec) r0
                                                __ __}) x ha_X;
                                         False ->
                                          case ha_X of {
                                           Alpha_var x4 y1 sigma1 x5 ->
                                            eq_rec_r r (\_ ->
                                              eq_rec_r x (\_ ->
                                                eq_rec_r x (\_ ->
                                                  let {
                                                   _evar_0_ = Alpha_var x0 y0
                                                    r h_UU03b1_v}
                                                  in
                                                  eq_rec_r False _evar_0_
                                                    (eqb1 x y0)) y1) x4)
                                              sigma1 __ __ x5;
                                           Alpha_lam _ _ _ _ _ _ sigma1 x4 ->
                                            eq_rec_r r (\_ -> false_rec)
                                              sigma1 __ __ x4;
                                           Alpha_app _ _ _ _ _ sigma1 x4
                                            x5 ->
                                            eq_rec_r r (\_ -> false_rec)
                                              sigma1 __ __ x4 x5;
                                           Alpha_builtin r0 _ ->
                                            eq_rec_r r (\_ -> false_rec) r0
                                              __ __}}}
                            in
                            eq_rec_r
                              (case eqb1 x y0 of {
                                True -> t;
                                False -> Tmvar y0}) _evar_0_
                              (substituteTCA x t (Tmvar y0))}
                in
                eq_rec_r (case eqb1 x x0 of {
                           True -> t;
                           False -> Tmvar x0}) _evar_0_
                  (substituteTCA x t (Tmvar x0))) x2) sigma0 __ __ x3;
           Alpha_lam _ _ _ _ _ _ sigma0 x2 ->
            eq_rec_r r2 (\_ -> false_rec) sigma0 __ __ x2;
           Alpha_app _ _ _ _ _ sigma0 x2 x3 ->
            eq_rec_r r2 (\_ -> false_rec) sigma0 __ __ x2 x3;
           Alpha_builtin r0 _ -> eq_rec_r r2 (\_ -> false_rec) r0 __ __}) y)
        sigma __ __ x1;
     Alpha_lam _ _ _ _ _ _ sigma x0 ->
      eq_rec_r r1 (\_ _ -> false_rec) sigma __ __ x0;
     Alpha_app _ _ _ _ _ sigma x0 x1 ->
      eq_rec_r r1 (\_ _ -> false_rec) sigma __ __ x0 x1;
     Alpha_builtin r0 _ -> eq_rec_r r1 (\_ _ -> false_rec) r0 __ __})
    (\b xi k bi iHbi _ _ r1 r2 r ha_X ha_T htrans h_UU03b1_s h_UU03b1_s' ->
    case h_UU03b1_s of {
     Alpha_var _ _ sigma x0 -> eq_rec_r r1 (\_ _ -> false_rec) sigma __ __ x0;
     Alpha_lam b0 x0 y a s1 s2 sigma x1 ->
      eq_rec_r r1 (\_ _ ->
        eq_rec_r b (\_ ->
          eq_rec_r xi (\_ ->
            eq_rec_r k (\_ ->
              eq_rec_r bi (\h ->
                eq_rec_r b (\h_UU03b1_s0 ->
                  eq_rec_r k (\h_UU03b1_s1 ->
                    case h_UU03b1_s' of {
                     Alpha_var _ _ sigma0 x2 ->
                      eq_rec_r r2 (\_ -> false_rec) sigma0 __ __ x2;
                     Alpha_lam b1 x2 y0 a0 s3 s4 sigma0 x3 ->
                      eq_rec_r r2 (\_ ->
                        eq_rec_r b (\_ ->
                          eq_rec_r xi (\_ ->
                            eq_rec_r k (\_ ->
                              eq_rec_r bi (\_ h0 ->
                                let {b2 = eqb1 x0 x} in
                                case b2 of {
                                 True ->
                                  eq_rec_r x (\h_UU03b1_s2 _ ->
                                    let {
                                     _evar_0_ = let {
                                                 _evar_0_ = \_ ->
                                                  let {
                                                   _evar_0_ = alpha_sym
                                                                (substituteTCA
                                                                  x t (Tmlam
                                                                  b y0 k s4))
                                                                (Tmlam b x k
                                                                s1)
                                                                (sym_alpha_ctx
                                                                  r) r
                                                                (sym_alpha_ctx_left_is_sym
                                                                  r)
                                                                (substituteTCA_vacuous
                                                                  (sym_alpha_ctx
                                                                    r) x t
                                                                  (Tmlam b y0
                                                                  k s4)
                                                                  (Tmlam b x
                                                                  k s1)
                                                                  (alpha_sym
                                                                    (Tmlam b
                                                                    x k s1)
                                                                    (Tmlam b
                                                                    y0 k s4)
                                                                    (sym_alpha_ctx
                                                                    (sym_alpha_ctx
                                                                    r))
                                                                    (sym_alpha_ctx
                                                                    r)
                                                                    (sym_alpha_ctx_left_is_sym
                                                                    (sym_alpha_ctx
                                                                    r))
                                                                    (alpha_sym
                                                                    (Tmlam b
                                                                    y0 k s4)
                                                                    (Tmlam b
                                                                    x k s1)
                                                                    (sym_alpha_ctx
                                                                    r)
                                                                    (sym_alpha_ctx
                                                                    (sym_alpha_ctx
                                                                    r))
                                                                    (sym_alpha_ctx_is_sym
                                                                    (sym_alpha_ctx
                                                                    r))
                                                                    (alpha_sym
                                                                    (Tmlam b
                                                                    x k s1)
                                                                    (Tmlam b
                                                                    y0 k s4)
                                                                    r
                                                                    (sym_alpha_ctx
                                                                    r)
                                                                    (sym_alpha_ctx_is_sym
                                                                    r)
                                                                    (alpha_trans
                                                                    (Tmlam b
                                                                    x k s1)
                                                                    (Tmlam b
                                                                    xi k bi)
                                                                    (Tmlam b
                                                                    y0 k s4)
                                                                    r1 r2 r
                                                                    htrans
                                                                    h_UU03b1_s2
                                                                    h_UU03b1_s')))))}
                                                  in
                                                  eq_rec_r True _evar_0_
                                                    (eqb1 x x)}
                                                in
                                                eq_rec_r
                                                  (app (Cons (Pair x t) Nil)
                                                    Nil) _evar_0_ (Cons (Pair
                                                  x t) Nil) __}
                                    in
                                    eq_rec_r
                                      (case eqb1 x x of {
                                        True -> Tmlam b x k s1;
                                        False ->
                                         case existsb (eqb1 x) (ftv t) of {
                                          True ->
                                           let {
                                            y' = fresh2 (Cons (Pair x t) Nil)
                                                   s1}
                                           in
                                           let {t' = rename x y' s1} in
                                           Tmlam b y' k
                                           (substituteTCA x t t');
                                          False -> Tmlam b x k
                                           (substituteTCA x t s1)}}) _evar_0_
                                      (substituteTCA x t (Tmlam b x k s1)))
                                    x0 h_UU03b1_s1 h;
                                 False ->
                                  let {b3 = eqb1 y0 x} in
                                  case b3 of {
                                   True ->
                                    eq_rec_r x (\_ h1 ->
                                      let {
                                       _evar_0_ = substituteTCA_vacuous r x t
                                                    (Tmlam b x0 k s1) (Tmlam
                                                    b x k s4) (Alpha_lam b x0
                                                    x k s1 s4 r
                                                    (alpha_trans s1 bi s4
                                                      (Cons (Pair x0 xi) r1)
                                                      (Cons (Pair xi x) r2)
                                                      (Cons (Pair x0 x) r)
                                                      (Alpha_trans_cons x0 xi
                                                      x r1 r2 r htrans) h h1))}
                                      in
                                      eq_rec_r (Tmlam b x k s4) _evar_0_
                                        (substituteTCA x t (Tmlam b x k s4)))
                                      y0 h_UU03b1_s' h0;
                                   False ->
                                    eq_rec_r
                                      (case eqb1 x x0 of {
                                        True -> Tmlam b x0 k s1;
                                        False ->
                                         case existsb (eqb1 x0) (ftv t) of {
                                          True ->
                                           let {
                                            y' = fresh2 (Cons (Pair x t) Nil)
                                                   s1}
                                           in
                                           let {t' = rename x0 y' s1} in
                                           Tmlam b y' k
                                           (substituteTCA x t t');
                                          False -> Tmlam b x0 k
                                           (substituteTCA x t s1)}})
                                      (eq_rec_r
                                        (case eqb1 x y0 of {
                                          True -> Tmlam b y0 k s4;
                                          False ->
                                           case existsb (eqb1 y0) (ftv t) of {
                                            True ->
                                             let {
                                              y' = fresh2 (Cons (Pair x t)
                                                     Nil) s4}
                                             in
                                             let {t' = rename y0 y' s4} in
                                             Tmlam b y' k
                                             (substituteTCA x t t');
                                            False -> Tmlam b y0 k
                                             (substituteTCA x t s4)}})
                                        (let {
                                          _evar_0_ = \_ ->
                                           let {
                                            _evar_0_ = let {
                                                        _evar_0_ = \_ ->
                                                         let {
                                                          _evar_0_ = 
                                                           let {
                                                            b4 = existsb
                                                                   (eqb1 x0)
                                                                   (ftv t)}
                                                           in
                                                           case b4 of {
                                                            True ->
                                                             let {
                                                              b5 = existsb
                                                                    (eqb1 y0)
                                                                    (ftv t)}
                                                             in
                                                             case b5 of {
                                                              True ->
                                                               let {
                                                                y' = 
                                                                 fresh2 (Cons
                                                                   (Pair x t)
                                                                   Nil) s1}
                                                               in
                                                               let {
                                                                y'' = 
                                                                 fresh2 (Cons
                                                                   (Pair x t)
                                                                   Nil) s4}
                                                               in
                                                               Alpha_lam b y'
                                                               y'' k
                                                               (substituteTCA
                                                                 x t
                                                                 (rename x0
                                                                   y' s1))
                                                               (substituteTCA
                                                                 x t
                                                                 (rename y0
                                                                   y'' s4)) r
                                                               (iHbi
                                                                 (rename x0
                                                                   y' s1)
                                                                 (rename y0
                                                                   y'' s4)
                                                                 (Cons (Pair
                                                                 y' xi) r1)
                                                                 (Cons (Pair
                                                                 xi y'') r2)
                                                                 (Cons (Pair
                                                                 y' y'') r)
                                                                 (alpha_extend_fresh
                                                                   y' y'' r
                                                                   (Tmvar x)
                                                                   (Tmvar x)
                                                                   ha_X)
                                                                 (alpha_extend_fresh
                                                                   y' y'' r t
                                                                   t ha_T)
                                                                 (Alpha_trans_cons
                                                                 y' xi y'' r1
                                                                 r2 r htrans)
                                                                 (alpha_trans_rename_left
                                                                   s1 bi y'
                                                                   x0 xi r1
                                                                   (Cons
                                                                   (Pair x t)
                                                                   Nil) h)
                                                                 (alpha_trans_rename_right
                                                                   bi s4 y''
                                                                   y0 xi r2
                                                                   (Cons
                                                                   (Pair x t)
                                                                   Nil) h0));
                                                              False ->
                                                               let {
                                                                y' = 
                                                                 fresh2 (Cons
                                                                   (Pair x t)
                                                                   Nil) s1}
                                                               in
                                                               Alpha_lam b y'
                                                               y0 k
                                                               (substituteTCA
                                                                 x t
                                                                 (rename x0
                                                                   y' s1))
                                                               (substituteTCA
                                                                 x t s4) r
                                                               (iHbi
                                                                 (rename x0
                                                                   y' s1) s4
                                                                 (Cons (Pair
                                                                 y' xi) r1)
                                                                 (Cons (Pair
                                                                 xi y0) r2)
                                                                 (Cons (Pair
                                                                 y' y0) r)
                                                                 (alpha_extend_fresh
                                                                   y' y0 r
                                                                   (Tmvar x)
                                                                   (Tmvar x)
                                                                   ha_X)
                                                                 (alpha_extend_fresh
                                                                   y' y0 r t
                                                                   t ha_T)
                                                                 (Alpha_trans_cons
                                                                 y' xi y0 r1
                                                                 r2 r htrans)
                                                                 (alpha_trans_rename_left
                                                                   s1 bi y'
                                                                   x0 xi r1
                                                                   (Cons
                                                                   (Pair x t)
                                                                   Nil) h)
                                                                 h0)};
                                                            False ->
                                                             let {
                                                              b5 = existsb
                                                                    (eqb1 y0)
                                                                    (ftv t)}
                                                             in
                                                             case b5 of {
                                                              True ->
                                                               let {
                                                                y' = 
                                                                 fresh2 (Cons
                                                                   (Pair x t)
                                                                   Nil) s4}
                                                               in
                                                               Alpha_lam b x0
                                                               y' k
                                                               (substituteTCA
                                                                 x t s1)
                                                               (substituteTCA
                                                                 x t
                                                                 (rename y0
                                                                   y' s4)) r
                                                               (iHbi s1
                                                                 (rename y0
                                                                   y' s4)
                                                                 (Cons (Pair
                                                                 x0 xi) r1)
                                                                 (Cons (Pair
                                                                 xi y') r2)
                                                                 (Cons (Pair
                                                                 x0 y') r)
                                                                 (alpha_extend_fresh
                                                                   x0 y' r
                                                                   (Tmvar x)
                                                                   (Tmvar x)
                                                                   ha_X)
                                                                 (alpha_extend_fresh
                                                                   x0 y' r t
                                                                   t ha_T)
                                                                 (Alpha_trans_cons
                                                                 x0 xi y' r1
                                                                 r2 r htrans)
                                                                 h
                                                                 (alpha_trans_rename_right
                                                                   bi s4 y'
                                                                   y0 xi r2
                                                                   (Cons
                                                                   (Pair x t)
                                                                   Nil) h0));
                                                              False ->
                                                               Alpha_lam b x0
                                                               y0 k
                                                               (substituteTCA
                                                                 x t s1)
                                                               (substituteTCA
                                                                 x t s4) r
                                                               (iHbi s1 s4
                                                                 (Cons (Pair
                                                                 x0 xi) r1)
                                                                 (Cons (Pair
                                                                 xi y0) r2)
                                                                 (Cons (Pair
                                                                 x0 y0) r)
                                                                 (alpha_extend_fresh
                                                                   x0 y0 r
                                                                   (Tmvar x)
                                                                   (Tmvar x)
                                                                   ha_X)
                                                                 (alpha_extend_fresh
                                                                   x0 y0 r t
                                                                   t ha_T)
                                                                 (Alpha_trans_cons
                                                                 x0 xi y0 r1
                                                                 r2 r htrans)
                                                                 h h0)}}}
                                                         in
                                                         eq_rec_r False
                                                           _evar_0_
                                                           (eqb1 x y0)}
                                                       in
                                                       eq_rec_r (eqb1 x y0)
                                                         _evar_0_ (eqb1 y0 x)
                                                         __}
                                           in
                                           eq_rec_r False _evar_0_
                                             (eqb1 x x0)}
                                         in
                                         eq_rec_r (eqb1 x x0) _evar_0_
                                           (eqb1 x0 x) __)
                                        (substituteTCA x t (Tmlam b y0 k s4)))
                                      (substituteTCA x t (Tmlam b x0 k s1))}})
                                s3) a0) x2) b1 __ __ __) sigma0 __ __ x3;
                     Alpha_app _ _ _ _ _ sigma0 x2 x3 ->
                      eq_rec_r r2 (\_ -> false_rec) sigma0 __ __ x2 x3;
                     Alpha_builtin r0 _ ->
                      eq_rec_r r2 (\_ -> false_rec) r0 __ __}) a h_UU03b1_s0)
                  b0 h_UU03b1_s) s2) a) y) b0 __ __ __) sigma __ __ x1;
     Alpha_app _ _ _ _ _ sigma x0 x1 ->
      eq_rec_r r1 (\_ _ -> false_rec) sigma __ __ x0 x1;
     Alpha_builtin r0 _ -> eq_rec_r r1 (\_ _ -> false_rec) r0 __ __})
    (\b i1 iHi1 i2 iHi2 _ _ r1 r2 r ha_X ha_T htrans h_UU03b1_s h_UU03b1_s' ->
    case h_UU03b1_s of {
     Alpha_var _ _ sigma x0 -> eq_rec_r r1 (\_ _ -> false_rec) sigma __ __ x0;
     Alpha_lam _ _ _ _ _ _ sigma x0 ->
      eq_rec_r r1 (\_ _ -> false_rec) sigma __ __ x0;
     Alpha_app b0 s1 s2 t1 t2 sigma x0 x1 ->
      eq_rec_r r1 (\_ _ ->
        eq_rec_r b (\_ ->
          eq_rec_r i1 (\_ ->
            eq_rec_r i2 (\h_UU03b1_s2 h ->
              eq_rec_r b (\_ ->
                case h_UU03b1_s' of {
                 Alpha_var _ _ sigma0 x2 ->
                  eq_rec_r r2 (\_ -> false_rec) sigma0 __ __ x2;
                 Alpha_lam _ _ _ _ _ _ sigma0 x2 ->
                  eq_rec_r r2 (\_ -> false_rec) sigma0 __ __ x2;
                 Alpha_app b1 s3 s4 t3 t4 sigma0 x2 x3 ->
                  eq_rec_r r2 (\_ ->
                    eq_rec_r b (\_ ->
                      eq_rec_r i1 (\_ ->
                        eq_rec_r i2 (\_ h_UU03b1_s2' h0 ->
                          eq_rec_r (Tmapp b (substituteTCA x t s1)
                            (substituteTCA x t t1))
                            (eq_rec_r (Tmapp b (substituteTCA x t s4)
                              (substituteTCA x t t4)) (Alpha_app b
                              (substituteTCA x t s1) (substituteTCA x t s4)
                              (substituteTCA x t t1) (substituteTCA x t t4) r
                              (iHi1 s1 s4 r1 r2 r ha_X ha_T htrans
                                h_UU03b1_s2 h_UU03b1_s2')
                              (iHi2 t1 t4 r1 r2 r ha_X ha_T htrans h h0))
                              (substituteTCA x t (Tmapp b s4 t4)))
                            (substituteTCA x t (Tmapp b s1 t1))) t3) s3) b1
                      __ __) sigma0 __ __ x2 x3;
                 Alpha_builtin r0 _ -> eq_rec_r r2 (\_ -> false_rec) r0 __ __})
                b0 h_UU03b1_s) t2) s2) b0 __ __) sigma __ __ x0 x1;
     Alpha_builtin r0 _ -> eq_rec_r r1 (\_ _ -> false_rec) r0 __ __})
    (\d _ _ r1 r2 r _ _ _ h_UU03b1_s h_UU03b1_s' ->
    case h_UU03b1_s of {
     Alpha_var _ _ sigma x0 -> eq_rec_r r1 (\_ _ -> false_rec) sigma __ __ x0;
     Alpha_lam _ _ _ _ _ _ sigma x0 ->
      eq_rec_r r1 (\_ _ -> false_rec) sigma __ __ x0;
     Alpha_app _ _ _ _ _ sigma x0 x1 ->
      eq_rec_r r1 (\_ _ -> false_rec) sigma __ __ x0 x1;
     Alpha_builtin r0 d0 ->
      eq_rec_r r1 (\_ _ ->
        eq_rec_r d
          (eq_rec_r d (\_ ->
            case h_UU03b1_s' of {
             Alpha_var _ _ sigma x0 ->
              eq_rec_r r2 (\_ -> false_rec) sigma __ __ x0;
             Alpha_lam _ _ _ _ _ _ sigma x0 ->
              eq_rec_r r2 (\_ -> false_rec) sigma __ __ x0;
             Alpha_app _ _ _ _ _ sigma x0 x1 ->
              eq_rec_r r2 (\_ -> false_rec) sigma __ __ x0 x1;
             Alpha_builtin r3 d1 ->
              eq_rec_r r2 (\_ ->
                eq_rec_r d (\_ ->
                  eq_rec_r (Tmbuiltin d) (Alpha_builtin r d)
                    (substituteTCA x t (Tmbuiltin d))) d1) r3 __ __}) d0
            h_UU03b1_s) d0) r0 __ __}) i

substituteTCA_preserves_alpha :: Term0 -> Term0 -> (List
                                 (Prod String String)) -> String -> Term0 ->
                                 Alpha -> Alpha -> Alpha -> Alpha
substituteTCA_preserves_alpha s s' ren x u x0 x1 x2 =
  subs_preserves_alpha' x u s s s' (app Nil (ctx_id_left ren)) ren ren x0 x1
    (id_left_trans ren)
    (alpha_extend_ids_right s s Nil (ctx_id_left ren) (ctx_id_left_is_id ren)
      (alpha_refl s Nil Alpha_refl_nil)) x2

alpha_capms_to_naive :: String -> Term0 -> Term0 -> SigT Term0
                        (Prod (Prod Alpha Alpha) NC)
alpha_capms_to_naive x u t =
  ExistT (to_GU' x u t) (Pair (Pair (to_GU'__alpha x u t)
    (alpha_trans (substituteTCA x u t) (substituteTCA x u (to_GU' x u t))
      (sub x u (to_GU' x u t)) Nil Nil Nil Alpha_trans_nil
      (substituteTCA_preserves_alpha t (to_GU' x u t) Nil x u
        (alpha_refl (Tmvar x) Nil Alpha_refl_nil)
        (alpha_refl u Nil Alpha_refl_nil) (to_GU'__alpha x u t))
      (eq_rec_r (sub x u (to_GU' x u t))
        (alpha_refl (sub x u (to_GU' x u t)) Nil Alpha_refl_nil)
        (substituteTCA x u (to_GU' x u t))))) (to_GU'__NC x u t))

step_nd_preserves_alpha :: (List (Prod String String)) -> Term0 -> Term0 ->
                           Term0 -> Alpha -> Step_nd -> SigT Term0
                           (Prod Step_nd Alpha)
step_nd_preserves_alpha ren s t s' halpha hstep =
  step_nd_rec (\x a s0 t0 ren0 _ halpha0 ->
    case halpha0 of {
     Alpha_var _ _ sigma x0 -> eq_rec_r ren0 (\_ -> false_rec) sigma __ __ x0;
     Alpha_lam _ _ _ _ _ _ sigma x0 ->
      eq_rec_r ren0 (\_ -> false_rec) sigma __ __ x0;
     Alpha_app b s1 _ t1 t2 sigma x0 x1 ->
      eq_rec_r ren0 (\_ ->
        eq_rec_r App (\_ ->
          eq_rec_r (Tmlam Lam x a s0) (\_ ->
            eq_rec_r t0 (\_ h4 h5 ->
              case h4 of {
               Alpha_var _ _ sigma0 x2 ->
                eq_rec_r ren0 (\_ -> false_rec) sigma0 __ __ x2;
               Alpha_lam b0 x2 y a0 s2 s3 sigma0 x3 ->
                eq_rec_r ren0 (\_ ->
                  eq_rec_r Lam (\_ ->
                    eq_rec_r x (\_ ->
                      eq_rec_r a (\_ ->
                        eq_rec_r s0 (\_ h7 ->
                          let {s4 = alpha_capms_to_naive x t0 s0} in
                          case s4 of {
                           ExistT x4 p ->
                            case p of {
                             Pair p0 n ->
                              case p0 of {
                               Pair a1 a2 -> ExistT (substituteTCA y t2 s3)
                                (Pair (Step_beta_nd y a s3 t2)
                                (alpha_trans (substituteTCA x t0 s0)
                                  (sub x t0 x4) (substituteTCA y t2 s3)
                                  (ctx_id_left ren0) ren0 ren0
                                  (id_left_trans ren0)
                                  (alpha_extend_ids_right
                                    (substituteTCA x t0 s0) (sub x t0 x4) Nil
                                    (ctx_id_left ren0)
                                    (ctx_id_left_is_id ren0) a2)
                                  (let {s5 = alpha_capms_to_naive y t2 s3} in
                                   case s5 of {
                                    ExistT x5 p1 ->
                                     case p1 of {
                                      Pair p2 n0 ->
                                       case p2 of {
                                        Pair a3 a4 ->
                                         alpha_trans (sub x t0 x4)
                                           (sub y t2 x5)
                                           (substituteTCA y t2 s3) ren0
                                           (ctx_id_right ren0) ren0
                                           (id_right_trans ren0)
                                           (alpha_rename_binder_stronger x y
                                             x4 t0 t2 ren0 x5 (Cons (Pair x
                                             y) ren0)
                                             (alpha_trans x4 s0 x5
                                               (ctx_id_left (Cons (Pair x y)
                                                 ren0)) (Cons (Pair x y)
                                               ren0) (Cons (Pair x y) ren0)
                                               (id_left_trans (Cons (Pair x
                                                 y) ren0))
                                               (alpha_extend_ids
                                                 (ctx_id_left (Cons (Pair x
                                                   y) ren0)) x4 s0
                                                 (ctx_id_left_is_id (Cons
                                                   (Pair x y) ren0))
                                                 (alpha_sym s0 x4 Nil Nil
                                                   Alpha_sym_nil a1))
                                               (alpha_trans s0 s3 x5 (Cons
                                                 (Pair x y) ren0)
                                                 (ctx_id_right (Cons (Pair x
                                                   y) ren0)) (Cons (Pair x y)
                                                 ren0)
                                                 (id_right_trans (Cons (Pair
                                                   x y) ren0)) h7
                                                 (alpha_extend_ids
                                                   (ctx_id_right (Cons (Pair
                                                     x y) ren0)) s3 x5
                                                   (ctx_id_right_is_id (Cons
                                                     (Pair x y) ren0))
                                                   (alpha_sym x5 s3 Nil Nil
                                                     Alpha_sym_nil
                                                     (alpha_extend_ids Nil x5
                                                       s3 Id_ctx_nil
                                                       (alpha_extend_ids Nil
                                                         x5 s3 Id_ctx_nil
                                                         (alpha_extend_ids
                                                           Nil x5 s3
                                                           Id_ctx_nil
                                                           (alpha_sym s3 x5
                                                             (sym_alpha_ctx
                                                               Nil) Nil
                                                             (sym_alpha_ctx_left_is_sym
                                                               Nil) a3))))))))
                                             h5 (Lrs_cons x y ren0 ren0
                                             (legalRenSwap_id ren0)) n n0)
                                           (alpha_extend_ids_right
                                             (sub y t2 x5)
                                             (substituteTCA y t2 s3) Nil
                                             (ctx_id_right ren0)
                                             (ctx_id_right_is_id ren0)
                                             (alpha_sym
                                               (substituteTCA y t2 s3)
                                               (sub y t2 x5) Nil Nil
                                               Alpha_sym_nil a4))}}})))}}})
                          s2) a0) x2) b0 __ __ __) sigma0 __ __ x3;
               Alpha_app _ _ _ _ _ sigma0 x2 x3 ->
                eq_rec_r ren0 (\_ -> false_rec) sigma0 __ __ x2 x3;
               Alpha_builtin r _ -> eq_rec_r ren0 (\_ -> false_rec) r __ __})
              t1) s1) b __ __) sigma __ __ x0 x1;
     Alpha_builtin r _ -> eq_rec_r ren0 (\_ -> false_rec) r __ __})
    (\b s1 s2 t0 _ iHHstep ren0 _ halpha0 ->
    case halpha0 of {
     Alpha_var _ _ sigma x -> eq_rec_r ren0 (\_ -> false_rec) sigma __ __ x;
     Alpha_lam _ _ _ _ _ _ sigma x ->
      eq_rec_r ren0 (\_ -> false_rec) sigma __ __ x;
     Alpha_app b0 s3 s4 t1 t2 sigma x x0 ->
      eq_rec_r ren0 (\_ ->
        eq_rec_r b (\_ ->
          eq_rec_r s1 (\_ ->
            eq_rec_r t0 (\_ h4 h5 ->
              let {s0 = iHHstep ren0 s4 h4} in
              case s0 of {
               ExistT x1 p ->
                case p of {
                 Pair s5 a -> ExistT (Tmapp b x1 t2) (Pair (Step_appL_nd b s4
                  x1 t2 s5) (Alpha_app b s2 x1 t0 t2 ren0 a h5))}}) t1) s3)
          b0 __ __) sigma __ __ x x0;
     Alpha_builtin r _ -> eq_rec_r ren0 (\_ -> false_rec) r __ __})
    (\b s0 t1 t2 _ iHHstep ren0 _ halpha0 ->
    case halpha0 of {
     Alpha_var _ _ sigma x -> eq_rec_r ren0 (\_ -> false_rec) sigma __ __ x;
     Alpha_lam _ _ _ _ _ _ sigma x ->
      eq_rec_r ren0 (\_ -> false_rec) sigma __ __ x;
     Alpha_app b0 s1 s2 t3 t4 sigma x x0 ->
      eq_rec_r ren0 (\_ ->
        eq_rec_r b (\_ ->
          eq_rec_r s0 (\_ ->
            eq_rec_r t1 (\_ h4 h5 ->
              let {s3 = iHHstep ren0 t4 h5} in
              case s3 of {
               ExistT x1 p ->
                case p of {
                 Pair s4 a -> ExistT (Tmapp b s2 x1) (Pair (Step_appR_nd b s2
                  t4 x1 s4) (Alpha_app b s0 s2 t2 x1 ren0 h4 a))}}) t3) s1)
          b0 __ __) sigma __ __ x x0;
     Alpha_builtin r _ -> eq_rec_r ren0 (\_ -> false_rec) r __ __})
    (\b x a s1 s2 _ iHHstep ren0 _ halpha0 ->
    case halpha0 of {
     Alpha_var _ _ sigma x0 -> eq_rec_r ren0 (\_ -> false_rec) sigma __ __ x0;
     Alpha_lam b0 x0 y a0 s3 s4 sigma x1 ->
      eq_rec_r ren0 (\_ ->
        eq_rec_r b (\_ ->
          eq_rec_r x (\_ ->
            eq_rec_r a (\_ ->
              eq_rec_r s1 (\_ h5 ->
                let {s0 = iHHstep (Cons (Pair x y) ren0) s4 h5} in
                case s0 of {
                 ExistT x2 p ->
                  case p of {
                   Pair s5 a1 -> ExistT (Tmlam b y a x2) (Pair (Step_abs_nd b
                    y a s4 x2 s5) (Alpha_lam b x y a s2 x2 ren0 a1))}}) s3)
              a0) x0) b0 __ __ __) sigma __ __ x1;
     Alpha_app _ _ _ _ _ sigma x0 x1 ->
      eq_rec_r ren0 (\_ -> false_rec) sigma __ __ x0 x1;
     Alpha_builtin r _ -> eq_rec_r ren0 (\_ -> false_rec) r __ __}) s s'
    hstep ren t halpha

step_nd_implies_step_gu_na :: Term0 -> Term0 -> Step_nd -> SigT Term0
                              (Prod Step_gu_naive Alpha)
step_nd_implies_step_gu_na t t' =
  let {t_GU = to_GU t} in
  let {h_alpha = eq_rec_r (to_GU t) (to_GU__alpha t) t_GU} in
  let {h_GU = eq_rec_r (to_GU t) (\_ -> to_GU__GU t) t_GU h_alpha} in
  (\x ->
  let {hstep_GU = step_nd_preserves_alpha Nil t t_GU t' h_alpha x} in
  case hstep_GU of {
   ExistT x0 p ->
    case p of {
     Pair s a -> ExistT x0 (Pair
      (let {
        hstep_GU0 = gU_step_d_implies_step_na t_GU x0
                      (eq_rec_r (to_GU t) (\_ h_GU0 _ -> h_GU0) t_GU h_alpha
                        h_GU s) s}
       in
       Step_gu_naive_intro t t_GU x0 h_alpha h_GU hstep_GU0) a)}})

_UU03b1__preserves_sn_nd :: Term0 -> Term0 -> Alpha -> (Sn Term0 Step_nd) ->
                            Sn Term0 Step_nd
_UU03b1__preserves_sn_nd s s' h_UU03b1_ hsn =
  sn_rect (\x _ x0 s'0 h_UU03b1_0 -> SNI (\y1 hstep ->
    let {
     h = step_nd_preserves_alpha Nil s'0 x y1
           (alpha_sym x s'0 Nil Nil Alpha_sym_nil h_UU03b1_0) hstep}
    in
    case h of {
     ExistT x1 p ->
      case p of {
       Pair s0 a -> x0 x1 s0 y1 (alpha_sym y1 x1 Nil Nil Alpha_sym_nil a)}}))
    s hsn s' h_UU03b1_

sN_na_to_SN_nd :: Term0 -> (Sn Term0 Step_gu_naive) -> Sn Term0 Step_nd
sN_na_to_SN_nd t hsn_nd =
  SNI (\t' hstep ->
    sn_rect (\x _ x0 t0 hstep_d ->
      let {hstep_alpha = step_nd_implies_step_gu_na x t0 hstep_d} in
      case hstep_alpha of {
       ExistT x1 p ->
        case p of {
         Pair s a ->
          let {x2 = x0 x1 s} in
          _UU03b1__preserves_sn_nd x1 t0
            (alpha_sym t0 x1 Nil Nil Alpha_sym_nil a) (SNI x2)}}) t hsn_nd t'
      hstep)

strong_normalization :: (List (Prod BinderTyname Kind)) -> Term0 -> Kind ->
                        Has_kind0 -> Sn Term0 Step_nd
strong_normalization e s t x =
  let {h = sN_naive e s t x} in sN_na_to_SN_nd s h

f :: Ty -> Term0
f t =
  case t of {
   Ty_Var x -> Tmvar x;
   Ty_Fun t1 t2 -> Tmapp Fun (f t1) (f t2);
   Ty_IFix f1 t1 -> Tmapp IFix (f f1) (f t1);
   Ty_Forall x a t0 -> Tmlam ForAll x a (f t0);
   Ty_Builtin d -> Tmbuiltin d;
   Ty_Lam x a t0 -> Tmlam Lam x a (f t0);
   Ty_App t1 t2 -> Tmapp App (f t1) (f t2);
   Ty_SOP tss ->
    fold_right (\ts acc ->
      fold_right (\t0 acc2 -> Tmapp Fun (f t0) acc2) acc ts) (Tmbuiltin
      DefaultUniInteger) tss}

f_preserves_step :: Ty -> Ty -> Step -> Step_nd
f_preserves_step s s' h =
  step_rec (\x k s0 t _ _ ->
    eq_rec_r (substituteTCA x (f t) (f s0)) (Step_beta_nd x k (f s0) 
      (f t)) (f (substituteTCA0 x t s0))) (\s1 s2 t _ iHstep -> Step_appL_nd
    App (f s1) (f s2) (f t) iHstep) (\s0 t1 t2 _ _ iHstep -> Step_appR_nd App
    (f s0) (f t1) (f t2) iHstep) (\s1 s2 t _ iHstep -> Step_appL_nd Fun
    (f s1) (f s2) (f t) iHstep) (\s0 t1 t2 _ _ iHstep -> Step_appR_nd Fun
    (f s0) (f t1) (f t2) iHstep) (\bX k s1 s2 _ iHstep -> Step_abs_nd ForAll
    bX k (f s1) (f s2) iHstep) (\bX k t1 t2 _ iHstep -> Step_abs_nd Lam bX k
    (f t1) (f t2) iHstep) (\f1 f2 t _ iHstep -> Step_appL_nd IFix (f f1)
    (f f2) (f t) iHstep) (\f0 t1 t2 _ _ iHstep -> Step_appR_nd IFix (f f0)
    (f t1) (f t2) iHstep)
    (\tss_normal tss_sub_normal tss_sub1 tss_sub2 tss_sub_remainder tss_remainder f0 f1 _ iHstep ->
    forallSet2_rec
      (forallSet_rec (Step_appL_nd Fun (f tss_sub1) (f tss_sub2)
        (fold_right (\t acc2 -> Tmapp Fun (f t) acc2)
          (fold_right (\ts acc ->
            fold_right (\t acc2 -> Tmapp Fun (f t) acc2) acc ts) (Tmbuiltin
            DefaultUniInteger) tss_remainder) tss_sub_remainder) iHstep)
        (\x xs _ _ iHf1 -> Step_appR_nd Fun (f x)
        (fold_right (\t acc2 -> Tmapp Fun (f t) acc2)
          (fold_right (\ts acc ->
            fold_right (\t acc2 -> Tmapp Fun (f t) acc2) acc ts) (Tmbuiltin
            DefaultUniInteger) tss_remainder)
          (app xs (Cons tss_sub1 tss_sub_remainder)))
        (fold_right (\t acc2 -> Tmapp Fun (f t) acc2)
          (fold_right (\ts acc ->
            fold_right (\t acc2 -> Tmapp Fun (f t) acc2) acc ts) (Tmbuiltin
            DefaultUniInteger) tss_remainder)
          (app xs (Cons tss_sub2 tss_sub_remainder))) iHf1) tss_sub_normal
        f1) (\x xs f2 _ iHf0 ->
      list_rec (\_ -> iHf0) (\a x0 iHx f3 -> Step_appR_nd Fun (f a)
        (fold_right (\t acc2 -> Tmapp Fun (f t) acc2)
          (fold_right (\ts acc ->
            fold_right (\t acc2 -> Tmapp Fun (f t) acc2) acc ts) (Tmbuiltin
            DefaultUniInteger)
            (app xs (Cons
              (app tss_sub_normal (Cons tss_sub1 tss_sub_remainder))
              tss_remainder))) x0)
        (fold_right (\t acc2 -> Tmapp Fun (f t) acc2)
          (fold_right (\ts acc ->
            fold_right (\t acc2 -> Tmapp Fun (f t) acc2) acc ts) (Tmbuiltin
            DefaultUniInteger)
            (app xs (Cons
              (app tss_sub_normal (Cons tss_sub2 tss_sub_remainder))
              tss_remainder))) x0)
        (iHx
          (case f3 of {
            ForallS_nil -> false_rec;
            ForallS_cons x1 xs0 _ x2 ->
             eq_rec_r a (\_ -> eq_rec_r x0 (\_ h3 -> h3) xs0) x1 __ __ x2})))
        x f2) tss_normal f0) s s' h

f_preserves_kind :: (List (Prod BinderName Kind)) -> Ty -> Kind -> Has_kind
                    -> Has_kind0
f_preserves_kind _UU0394_ s k x =
  has_kind__ind (\_UU0394_0 x0 k0 _ -> K_Var0 _UU0394_0 x0 k0)
    (\_UU0394_0 t1 t2 _ iHhas_kind1 _ iHhas_kind2 -> K_Fun0 _UU0394_0
    (let {
      f0 t =
        case t of {
         Ty_Var x0 -> Tmvar x0;
         Ty_Fun t3 t4 -> Tmapp Fun (f0 t3) (f0 t4);
         Ty_IFix f1 t3 -> Tmapp IFix (f0 f1) (f0 t3);
         Ty_Forall x0 a t0 -> Tmlam ForAll x0 a (f0 t0);
         Ty_Builtin d -> Tmbuiltin d;
         Ty_Lam x0 a t0 -> Tmlam Lam x0 a (f0 t0);
         Ty_App t3 t4 -> Tmapp App (f0 t3) (f0 t4);
         Ty_SOP tss ->
          fold_right (\ts acc ->
            fold_right (\t0 acc2 -> Tmapp Fun (f0 t0) acc2) acc ts)
            (Tmbuiltin DefaultUniInteger) tss}}
     in f0 t1)
    (let {
      f0 t =
        case t of {
         Ty_Var x0 -> Tmvar x0;
         Ty_Fun t3 t4 -> Tmapp Fun (f0 t3) (f0 t4);
         Ty_IFix f1 t3 -> Tmapp IFix (f0 f1) (f0 t3);
         Ty_Forall x0 a t0 -> Tmlam ForAll x0 a (f0 t0);
         Ty_Builtin d -> Tmbuiltin d;
         Ty_Lam x0 a t0 -> Tmlam Lam x0 a (f0 t0);
         Ty_App t3 t4 -> Tmapp App (f0 t3) (f0 t4);
         Ty_SOP tss ->
          fold_right (\ts acc ->
            fold_right (\t0 acc2 -> Tmapp Fun (f0 t0) acc2) acc ts)
            (Tmbuiltin DefaultUniInteger) tss}}
     in f0 t2) iHhas_kind1 iHhas_kind2)
    (\_UU0394_0 f0 t k0 _ iHhas_kind1 _ iHhas_kind2 -> K_IFix0 _UU0394_0
    (let {
      f1 t0 =
        case t0 of {
         Ty_Var x0 -> Tmvar x0;
         Ty_Fun t1 t2 -> Tmapp Fun (f1 t1) (f1 t2);
         Ty_IFix f2 t1 -> Tmapp IFix (f1 f2) (f1 t1);
         Ty_Forall x0 a t1 -> Tmlam ForAll x0 a (f1 t1);
         Ty_Builtin d -> Tmbuiltin d;
         Ty_Lam x0 a t1 -> Tmlam Lam x0 a (f1 t1);
         Ty_App t1 t2 -> Tmapp App (f1 t1) (f1 t2);
         Ty_SOP tss ->
          fold_right (\ts acc ->
            fold_right (\t1 acc2 -> Tmapp Fun (f1 t1) acc2) acc ts)
            (Tmbuiltin DefaultUniInteger) tss}}
     in f1 f0)
    (let {
      f1 t0 =
        case t0 of {
         Ty_Var x0 -> Tmvar x0;
         Ty_Fun t1 t2 -> Tmapp Fun (f1 t1) (f1 t2);
         Ty_IFix f2 t1 -> Tmapp IFix (f1 f2) (f1 t1);
         Ty_Forall x0 a t1 -> Tmlam ForAll x0 a (f1 t1);
         Ty_Builtin d -> Tmbuiltin d;
         Ty_Lam x0 a t1 -> Tmlam Lam x0 a (f1 t1);
         Ty_App t1 t2 -> Tmapp App (f1 t1) (f1 t2);
         Ty_SOP tss ->
          fold_right (\ts acc ->
            fold_right (\t1 acc2 -> Tmapp Fun (f1 t1) acc2) acc ts)
            (Tmbuiltin DefaultUniInteger) tss}}
     in f1 t) k0 iHhas_kind1 iHhas_kind2) (\_UU0394_0 x0 k0 t _ iHhas_kind ->
    K_Forall0 _UU0394_0 x0 k0
    (let {
      f0 t0 =
        case t0 of {
         Ty_Var x1 -> Tmvar x1;
         Ty_Fun t1 t2 -> Tmapp Fun (f0 t1) (f0 t2);
         Ty_IFix f1 t1 -> Tmapp IFix (f0 f1) (f0 t1);
         Ty_Forall x1 a t1 -> Tmlam ForAll x1 a (f0 t1);
         Ty_Builtin d -> Tmbuiltin d;
         Ty_Lam x1 a t1 -> Tmlam Lam x1 a (f0 t1);
         Ty_App t1 t2 -> Tmapp App (f0 t1) (f0 t2);
         Ty_SOP tss ->
          fold_right (\ts acc ->
            fold_right (\t1 acc2 -> Tmapp Fun (f0 t1) acc2) acc ts)
            (Tmbuiltin DefaultUniInteger) tss}}
     in f0 t) iHhas_kind) (\_UU0394_0 t h -> K_Builtin0 _UU0394_0 t h)
    (\_UU0394_0 x0 k1 t k2 _ iHhas_kind -> K_Lam0 _UU0394_0 x0 k1
    (let {
      f0 t0 =
        case t0 of {
         Ty_Var x1 -> Tmvar x1;
         Ty_Fun t1 t2 -> Tmapp Fun (f0 t1) (f0 t2);
         Ty_IFix f1 t1 -> Tmapp IFix (f0 f1) (f0 t1);
         Ty_Forall x1 a t1 -> Tmlam ForAll x1 a (f0 t1);
         Ty_Builtin d -> Tmbuiltin d;
         Ty_Lam x1 a t1 -> Tmlam Lam x1 a (f0 t1);
         Ty_App t1 t2 -> Tmapp App (f0 t1) (f0 t2);
         Ty_SOP tss ->
          fold_right (\ts acc ->
            fold_right (\t1 acc2 -> Tmapp Fun (f0 t1) acc2) acc ts)
            (Tmbuiltin DefaultUniInteger) tss}}
     in f0 t) k2 iHhas_kind)
    (\_UU0394_0 t1 t2 k1 k2 _ iHhas_kind1 _ iHhas_kind2 -> K_App0 _UU0394_0
    (let {
      f0 t =
        case t of {
         Ty_Var x0 -> Tmvar x0;
         Ty_Fun t3 t4 -> Tmapp Fun (f0 t3) (f0 t4);
         Ty_IFix f1 t3 -> Tmapp IFix (f0 f1) (f0 t3);
         Ty_Forall x0 a t0 -> Tmlam ForAll x0 a (f0 t0);
         Ty_Builtin d -> Tmbuiltin d;
         Ty_Lam x0 a t0 -> Tmlam Lam x0 a (f0 t0);
         Ty_App t3 t4 -> Tmapp App (f0 t3) (f0 t4);
         Ty_SOP tss ->
          fold_right (\ts acc ->
            fold_right (\t0 acc2 -> Tmapp Fun (f0 t0) acc2) acc ts)
            (Tmbuiltin DefaultUniInteger) tss}}
     in f0 t1)
    (let {
      f0 t =
        case t of {
         Ty_Var x0 -> Tmvar x0;
         Ty_Fun t3 t4 -> Tmapp Fun (f0 t3) (f0 t4);
         Ty_IFix f1 t3 -> Tmapp IFix (f0 f1) (f0 t3);
         Ty_Forall x0 a t0 -> Tmlam ForAll x0 a (f0 t0);
         Ty_Builtin d -> Tmbuiltin d;
         Ty_Lam x0 a t0 -> Tmlam Lam x0 a (f0 t0);
         Ty_App t3 t4 -> Tmapp App (f0 t3) (f0 t4);
         Ty_SOP tss ->
          fold_right (\ts acc ->
            fold_right (\t0 acc2 -> Tmapp Fun (f0 t0) acc2) acc ts)
            (Tmbuiltin DefaultUniInteger) tss}}
     in f0 t2) k1 k2 iHhas_kind1 iHhas_kind2) (\_UU0394_0 tss h iHhas_kind ->
    list_rec (\_ _ -> K_Builtin0 _UU0394_0 DefaultUniInteger
      K_DefaultUniInteger) (\a tss0 _ h0 iHhas_kind0 ->
      let {l = Cons a tss0} in
      forallSet2_rec (\_ -> K_Builtin0 _UU0394_0 DefaultUniInteger
        K_DefaultUniInteger) (\x0 xs f0 _ iHIHhas_kind h1 ->
        forallSet_rec (\h2 ->
          iHIHhas_kind
            (case h2 of {
              ForallSet2_nil _UU0394_1 ->
               eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __;
              ForallSet2_cons _UU0394_1 ts tss1 x1 x2 ->
               eq_rec_r _UU0394_0 (\_ ->
                 eq_rec_r Nil (\_ -> eq_rec_r xs (\_ h4 -> h4) tss1) ts __)
                 _UU0394_1 __ x1 x2})) (\x1 xs0 p _ iHf0 h2 -> K_Fun0
          _UU0394_0 (f x1)
          (fold_right (\t acc2 -> Tmapp Fun (f t) acc2)
            (fold_right (\ts acc ->
              fold_right (\t acc2 -> Tmapp Fun (f t) acc2) acc ts) (Tmbuiltin
              DefaultUniInteger) xs) xs0) p
          (iHf0
            (case h2 of {
              ForallSet2_nil _UU0394_1 ->
               eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __;
              ForallSet2_cons _UU0394_1 ts tss1 x2 x3 ->
               eq_rec_r _UU0394_0 (\_ ->
                 eq_rec_r (Cons x1 xs0) (\_ ->
                   eq_rec_r xs (\h3 h4 ->
                     case h3 of {
                      ForallSet_nil _UU0394_2 ->
                       eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_2 __;
                      ForallSet_cons _UU0394_2 t ts0 x4 x5 ->
                       eq_rec_r _UU0394_0 (\_ ->
                         eq_rec_r x1 (\_ ->
                           eq_rec_r xs0 (\_ h6 -> ForallSet2_cons _UU0394_0
                             xs0 xs h6 h4) ts0) t __) _UU0394_2 __ x4 x5})
                     tss1) ts __) _UU0394_1 __ x2 x3}))) x0 f0 h1) l
        iHhas_kind0 h0) tss h iHhas_kind) (\_ -> ForallS2_nil)
    (\_ ts tss _ iHhas_kind _ iHhas_kind0 -> ForallS2_cons ts tss iHhas_kind
    iHhas_kind0) (\_ -> ForallS_nil) (\_ t ts _ iHhas_kind _ iHhas_kind0 ->
    ForallS_cons t ts iHhas_kind iHhas_kind0) _UU0394_ s k x

sn_preimage2 :: (Ty -> Term0) -> Ty -> (Ty -> Ty -> a1 -> a2) -> (Sn 
                Term0 a2) -> Sn Ty a1
sn_preimage2 h x a b =
  let {v = h x} in
  sn_rect (\_ _ x0 x1 h0 a0 _ -> SNI (\y c ->
    let {c0 = a0 x1 y c} in x0 (h0 y) c0 y h0 a0 __)) v b x h a __

sn_step_plut :: Ty -> (Sn Term0 Step_nd) -> Sn Ty Step
sn_step_plut s =
  sn_preimage2 f s f_preserves_step

plutus_ty_strong_normalization :: Ty -> (List (Prod BinderName Kind)) -> Kind
                                  -> Has_kind -> Sn Ty Step
plutus_ty_strong_normalization s _UU0394_ k hwk =
  let {hwk0 = f_preserves_kind _UU0394_ s k hwk} in
  let {hwk1 = strong_normalization _UU0394_ (f s) k hwk0} in
  sn_step_plut s hwk1

step_dec :: Ty -> (List (Prod BinderName Kind)) -> Kind -> Has_kind -> Sum
            (SigT Ty Step) ()
step_dec t =
  ty_rec (\_ _ _ _ -> Inr __) (\t1 iHT1 t2 iHT2 _UU0394_ _ _ ->
    let {o = kind_check _UU0394_ t1} in
    case o of {
     Some k ->
      case k of {
       Kind_Base ->
        let {o0 = kind_check _UU0394_ t2} in
        case o0 of {
         Some k0 ->
          case k0 of {
           Kind_Base ->
            let {heqo = kind_checking_sound _UU0394_ t1 Kind_Base} in
            let {heqo0 = kind_checking_sound _UU0394_ t2 Kind_Base} in
            let {s = iHT1 _UU0394_ Kind_Base heqo} in
            case s of {
             Inl s0 -> Inl
              (case s0 of {
                ExistT x s1 -> ExistT (Ty_Fun x t2) (Step_funL t1 x t2 s1)});
             Inr _ ->
              let {s0 = iHT2 _UU0394_ Kind_Base heqo0} in
              case s0 of {
               Inl s1 -> Inl
                (case s1 of {
                  ExistT x s2 -> ExistT (Ty_Fun t1 x) (Step_funR t1 t2 x s2)});
               Inr _ -> Inr __}};
           Kind_Arrow _ _ -> false_rec};
         None -> false_rec};
       Kind_Arrow _ _ -> false_rec};
     None -> false_rec}) (\t1 iHT1 t2 iHT2 _UU0394_ _ _ ->
    let {o = kind_check _UU0394_ t2} in
    case o of {
     Some k ->
      let {o0 = kind_check _UU0394_ t1} in
      case o0 of {
       Some k0 ->
        case k0 of {
         Kind_Base -> false_rec;
         Kind_Arrow k1 k2 ->
          case k1 of {
           Kind_Base -> false_rec;
           Kind_Arrow k3 k4 ->
            case k4 of {
             Kind_Base ->
              case k2 of {
               Kind_Base -> false_rec;
               Kind_Arrow k5 k6 ->
                case k6 of {
                 Kind_Base ->
                  let {b = andb (kind_eqb k k3) (kind_eqb k k5)} in
                  case b of {
                   True ->
                    let {heqo = kind_checking_sound _UU0394_ t2 k} in
                    let {
                     heqo0 = kind_checking_sound _UU0394_ t1 (Kind_Arrow
                               (Kind_Arrow k3 Kind_Base) (Kind_Arrow k5
                               Kind_Base))}
                    in
                    let {
                     s = iHT1 _UU0394_ (Kind_Arrow (Kind_Arrow k3 Kind_Base)
                           (Kind_Arrow k5 Kind_Base)) heqo0}
                    in
                    case s of {
                     Inl s0 -> Inl
                      (case s0 of {
                        ExistT x s1 -> ExistT (Ty_IFix x t2) (Step_ifixL t1 x
                         t2 s1)});
                     Inr _ ->
                      let {s0 = iHT2 _UU0394_ k heqo} in
                      case s0 of {
                       Inl s1 -> Inl
                        (case s1 of {
                          ExistT x s2 -> ExistT (Ty_IFix t1 x) (Step_ifixR t1
                           t2 x s2)});
                       Inr _ -> Inr __}};
                   False -> false_rec};
                 Kind_Arrow _ _ -> false_rec}};
             Kind_Arrow _ _ -> false_rec}}};
       None -> false_rec};
     None -> false_rec}) (\b k t0 iHT _UU0394_ _ _ ->
    let {o = kind_check (Cons (Pair b k) _UU0394_) t0} in
    case o of {
     Some k0 ->
      case k0 of {
       Kind_Base ->
        let {
         heqo = kind_checking_sound (Cons (Pair b k) _UU0394_) t0 Kind_Base}
        in
        let {s = iHT (Cons (Pair b k) _UU0394_) Kind_Base heqo} in
        case s of {
         Inl s0 -> Inl
          (case s0 of {
            ExistT x s1 -> ExistT (Ty_Forall b k x) (Step_forall b k t0 x s1)});
         Inr _ -> Inr __};
       Kind_Arrow _ _ -> false_rec};
     None -> false_rec}) (\_ _ _ _ -> Inr __) (\b k t0 iHT _UU0394_ _ _ ->
    let {o = kind_check (Cons (Pair b k) _UU0394_) t0} in
    case o of {
     Some k0 ->
      let {heqo = kind_checking_sound (Cons (Pair b k) _UU0394_) t0 k0} in
      let {s = iHT (Cons (Pair b k) _UU0394_) k0 heqo} in
      case s of {
       Inl s0 -> Inl
        (case s0 of {
          ExistT x s1 -> ExistT (Ty_Lam b k x) (Step_abs b k t0 x s1)});
       Inr _ -> Inr __};
     None -> false_rec}) (\t1 iHT1 t2 iHT2 _UU0394_ _ _ ->
    let {o = kind_check _UU0394_ t1} in
    case o of {
     Some k ->
      case k of {
       Kind_Base -> false_rec;
       Kind_Arrow k0 k1 ->
        let {o0 = kind_check _UU0394_ t2} in
        case o0 of {
         Some k2 ->
          let {b = kind_eqb k0 k2} in
          case b of {
           True ->
            let {heqo = kind_checking_sound _UU0394_ t1 (Kind_Arrow k0 k1)}
            in
            let {s = iHT1 _UU0394_ (Kind_Arrow k0 k1) heqo} in
            case s of {
             Inl s0 -> Inl
              (case s0 of {
                ExistT x s1 -> ExistT (Ty_App x t2) (Step_appL t1 x t2 s1)});
             Inr _ ->
              let {o1 = kind_check _UU0394_ t1} in
              case o1 of {
               Some k3 ->
                case k3 of {
                 Kind_Base -> false_rec;
                 Kind_Arrow k4 _ ->
                  let {o2 = kind_check _UU0394_ t2} in
                  case o2 of {
                   Some k5 ->
                    let {b0 = kind_eqb k4 k5} in
                    case b0 of {
                     True ->
                      let {heqo2 = kind_checking_sound _UU0394_ t2 k5} in
                      let {s0 = iHT2 _UU0394_ k5 heqo2} in
                      case s0 of {
                       Inl s1 -> Inl
                        (case s1 of {
                          ExistT x s2 -> ExistT (Ty_App t1 x) (Step_appR t1
                           t2 x s2)});
                       Inr _ ->
                        ty_rec (\_ _ _ _ _ _ _ -> Inr __)
                          (\_ _ _ _ _ _ _ _ _ _ -> false_rec)
                          (\_ _ _ _ _ _ _ _ _ _ -> false_rec)
                          (\_ _ _ _ _ _ _ _ _ _ -> false_rec)
                          (\_ _ _ _ _ _ _ -> false_rec)
                          (\b1 k6 t3 _ _ _ _ _ _ _ -> Inl (ExistT
                          (substituteTCA0 b1 t2 t3) (Step_beta b1 k6 t3 t2)))
                          (\_ _ _ _ _ _ _ _ _ _ -> Inr __)
                          (\l _ _ _ heqo0 _ _ ->
                          case heqo0 of {
                           K_Var _UU0394_0 _ _ ->
                            eq_rec_r _UU0394_ (\_ -> false_rec) _UU0394_0 __
                              __ __;
                           K_Fun _UU0394_0 _ _ x x0 ->
                            eq_rec_r _UU0394_ (\_ -> false_rec) _UU0394_0 __
                              __ x x0;
                           K_IFix _UU0394_0 _ _ _ x x0 ->
                            eq_rec_r _UU0394_ (\_ -> false_rec) _UU0394_0 __
                              __ x x0;
                           K_Forall _UU0394_0 _ _ _ x ->
                            eq_rec_r _UU0394_ (\_ -> false_rec) _UU0394_0 __
                              __ x;
                           K_Builtin _UU0394_0 _ x ->
                            eq_rec_r _UU0394_ (\_ -> false_rec) _UU0394_0 __
                              __ x;
                           K_Lam _UU0394_0 _ _ _ _ x ->
                            eq_rec_r _UU0394_ (\_ -> false_rec) _UU0394_0 __
                              __ x;
                           K_App _UU0394_0 _ _ _ _ x x0 ->
                            eq_rec_r _UU0394_ (\_ -> false_rec) _UU0394_0 __
                              __ x x0;
                           K_SOP _UU0394_0 tss x ->
                            eq_rec_r _UU0394_ (\_ ->
                              eq_rec_r l (\_ -> false_rec) tss) _UU0394_0 __
                              __ x}) t1 iHT1 __ __ heqo __ __};
                     False -> false_rec};
                   None -> false_rec}};
               None -> false_rec}};
           False -> false_rec};
         None -> false_rec}};
     None -> false_rec}) (\_ _ _ _ -> Inr __) t

step_preserves_kinding_SOP_axiom :: (List (List Ty)) -> (List
                                    (Prod BinderName Kind)) -> Has_kind
step_preserves_kinding_SOP_axiom =
  Prelude.error "AXIOM TO BE REALIZED"

step_preserves_kinding :: Ty -> Ty -> (List (Prod BinderName Kind)) -> Kind
                          -> Has_kind -> Step -> Has_kind
step_preserves_kinding t t' _UU0394_ k x x0 =
  step_rec (\x1 k0 s t0 _ _ _UU0394_0 k1 hkind_T ->
    case hkind_T of {
     K_Var _UU0394_1 _ _ ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ __;
     K_Fun _UU0394_1 _ _ x2 x3 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x2 x3;
     K_IFix _UU0394_1 _ _ _ x2 x3 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x2 x3;
     K_Forall _UU0394_1 _ _ _ x2 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x2;
     K_Builtin _UU0394_1 _ x2 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x2;
     K_Lam _UU0394_1 _ _ _ _ x2 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x2;
     K_App _UU0394_1 t1 t2 k2 k3 x2 x3 ->
      eq_rec_r _UU0394_0 (\_ ->
        eq_rec_r (Ty_Lam x1 k0 s) (\_ ->
          eq_rec_r t0 (\_ ->
            eq_rec_r k1 (\h2 h4 ->
              case h2 of {
               K_Var _UU0394_2 _ _ ->
                eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_2 __ __ __;
               K_Fun _UU0394_2 _ _ x4 x5 ->
                eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_2 __ __ x4 x5;
               K_IFix _UU0394_2 _ _ _ x4 x5 ->
                eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_2 __ __ x4 x5;
               K_Forall _UU0394_2 _ _ _ x4 ->
                eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_2 __ __ x4;
               K_Builtin _UU0394_2 _ x4 ->
                eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_2 __ __ x4;
               K_Lam _UU0394_2 x4 k4 t3 k5 x5 ->
                eq_rec_r _UU0394_0 (\_ ->
                  eq_rec_r x1 (\_ ->
                    eq_rec_r k0 (\_ ->
                      eq_rec_r s (\_ ->
                        eq_rec_r k2 (\_ ->
                          eq_rec_r k1 (\h1 ->
                            eq_rec_r k2 (\_ _ ->
                              substituteTCA_preserves_kinding s _UU0394_0 x1
                                k1 t0 k2 h1 h4) k0 hkind_T h2) k5) k0 __) t3)
                      k4) x4 __ __) _UU0394_2 __ __ x5;
               K_App _UU0394_2 _ _ _ _ x4 x5 ->
                eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_2 __ __ x4 x5;
               K_SOP _UU0394_2 _ x4 ->
                eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_2 __ __ x4}) k3)
            t2) t1 __) _UU0394_1 __ __ x2 x3;
     K_SOP _UU0394_1 _ x2 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x2})
    (\s1 s2 t0 _ iHstep _UU0394_0 k0 hkind_T ->
    case hkind_T of {
     K_Var _UU0394_1 _ _ ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ __;
     K_Fun _UU0394_1 _ _ x1 x2 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1 x2;
     K_IFix _UU0394_1 _ _ _ x1 x2 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1 x2;
     K_Forall _UU0394_1 _ _ _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1;
     K_Builtin _UU0394_1 _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1;
     K_Lam _UU0394_1 _ _ _ _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1;
     K_App _UU0394_1 t1 t2 k1 k2 x1 x2 ->
      eq_rec_r _UU0394_0 (\_ ->
        eq_rec_r s1 (\_ ->
          eq_rec_r t0 (\_ ->
            eq_rec_r k0 (\h3 h5 -> K_App _UU0394_0 s2 t0 k1 k0
              (iHstep _UU0394_0 (Kind_Arrow k1 k0) h3) h5) k2) t2) t1 __)
        _UU0394_1 __ __ x1 x2;
     K_SOP _UU0394_1 _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1})
    (\s t1 t2 _ _ iHstep _UU0394_0 k0 hkind_T ->
    case hkind_T of {
     K_Var _UU0394_1 _ _ ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ __;
     K_Fun _UU0394_1 _ _ x1 x2 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1 x2;
     K_IFix _UU0394_1 _ _ _ x1 x2 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1 x2;
     K_Forall _UU0394_1 _ _ _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1;
     K_Builtin _UU0394_1 _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1;
     K_Lam _UU0394_1 _ _ _ _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1;
     K_App _UU0394_1 t3 t4 k1 k2 x1 x2 ->
      eq_rec_r _UU0394_0 (\_ ->
        eq_rec_r s (\_ ->
          eq_rec_r t1 (\_ ->
            eq_rec_r k0 (\h3 h5 -> K_App _UU0394_0 s t2 k1 k0 h3
              (iHstep _UU0394_0 k1 h5)) k2) t4) t3 __) _UU0394_1 __ __ x1 x2;
     K_SOP _UU0394_1 _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1})
    (\s1 s2 t0 _ iHstep _UU0394_0 _ hkind_T ->
    case hkind_T of {
     K_Var _UU0394_1 _ _ ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ __;
     K_Fun _UU0394_1 t1 t2 x1 x2 ->
      eq_rec_r _UU0394_0 (\_ ->
        eq_rec_r s1 (\_ ->
          eq_rec_r t0 (\_ h3 h5 -> K_Fun _UU0394_0 s2 t0
            (iHstep _UU0394_0 Kind_Base h3) h5) t2) t1 __) _UU0394_1 __ __ x1
        x2;
     K_IFix _UU0394_1 _ _ _ x1 x2 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1 x2;
     K_Forall _UU0394_1 _ _ _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1;
     K_Builtin _UU0394_1 _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1;
     K_Lam _UU0394_1 _ _ _ _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1;
     K_App _UU0394_1 _ _ _ _ x1 x2 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1 x2;
     K_SOP _UU0394_1 _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1})
    (\s t1 t2 _ _ iHstep _UU0394_0 _ hkind_T ->
    case hkind_T of {
     K_Var _UU0394_1 _ _ ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ __;
     K_Fun _UU0394_1 t3 t4 x1 x2 ->
      eq_rec_r _UU0394_0 (\_ ->
        eq_rec_r s (\_ ->
          eq_rec_r t1 (\_ h3 h5 -> K_Fun _UU0394_0 s t2 h3
            (iHstep _UU0394_0 Kind_Base h5)) t4) t3 __) _UU0394_1 __ __ x1 x2;
     K_IFix _UU0394_1 _ _ _ x1 x2 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1 x2;
     K_Forall _UU0394_1 _ _ _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1;
     K_Builtin _UU0394_1 _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1;
     K_Lam _UU0394_1 _ _ _ _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1;
     K_App _UU0394_1 _ _ _ _ x1 x2 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1 x2;
     K_SOP _UU0394_1 _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1})
    (\bX k0 s1 s2 _ iHstep _UU0394_0 _ hkind_T ->
    case hkind_T of {
     K_Var _UU0394_1 _ _ ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ __;
     K_Fun _UU0394_1 _ _ x1 x2 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1 x2;
     K_IFix _UU0394_1 _ _ _ x1 x2 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1 x2;
     K_Forall _UU0394_1 x1 k1 t0 x2 ->
      eq_rec_r _UU0394_0 (\_ ->
        eq_rec_r bX (\_ ->
          eq_rec_r k0 (\_ ->
            eq_rec_r s1 (\_ h5 -> K_Forall _UU0394_0 bX k0 s2
              (iHstep (Cons (Pair bX k0) _UU0394_0) Kind_Base h5)) t0) k1) x1
          __ __) _UU0394_1 __ __ x2;
     K_Builtin _UU0394_1 _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1;
     K_Lam _UU0394_1 _ _ _ _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1;
     K_App _UU0394_1 _ _ _ _ x1 x2 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1 x2;
     K_SOP _UU0394_1 _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1})
    (\bX k0 t1 t2 _ iHstep _UU0394_0 _ hkind_T ->
    case hkind_T of {
     K_Var _UU0394_1 _ _ ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ __;
     K_Fun _UU0394_1 _ _ x1 x2 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1 x2;
     K_IFix _UU0394_1 _ _ _ x1 x2 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1 x2;
     K_Forall _UU0394_1 _ _ _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1;
     K_Builtin _UU0394_1 _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1;
     K_Lam _UU0394_1 x1 k1 t0 k2 x2 ->
      eq_rec_r _UU0394_0 (\_ ->
        eq_rec_r bX (\_ ->
          eq_rec_r k0 (\_ ->
            eq_rec_r t1 (\_ h5 -> K_Lam _UU0394_0 bX k0 t2 k2
              (iHstep (Cons (Pair bX k0) _UU0394_0) k2 h5)) t0) k1) x1 __ __)
        _UU0394_1 __ __ x2;
     K_App _UU0394_1 _ _ _ _ x1 x2 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1 x2;
     K_SOP _UU0394_1 _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1})
    (\f1 f2 t0 _ iHstep _UU0394_0 _ hkind_T ->
    case hkind_T of {
     K_Var _UU0394_1 _ _ ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ __;
     K_Fun _UU0394_1 _ _ x1 x2 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1 x2;
     K_IFix _UU0394_1 f0 t1 k0 x1 x2 ->
      eq_rec_r _UU0394_0 (\_ ->
        eq_rec_r f1 (\_ ->
          eq_rec_r t0 (\_ h3 h5 -> K_IFix _UU0394_0 f2 t0 k0 h3
            (iHstep _UU0394_0 (Kind_Arrow (Kind_Arrow k0 Kind_Base)
              (Kind_Arrow k0 Kind_Base)) h5)) t1) f0 __) _UU0394_1 __ __ x1
        x2;
     K_Forall _UU0394_1 _ _ _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1;
     K_Builtin _UU0394_1 _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1;
     K_Lam _UU0394_1 _ _ _ _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1;
     K_App _UU0394_1 _ _ _ _ x1 x2 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1 x2;
     K_SOP _UU0394_1 _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1})
    (\f0 t1 t2 _ _ iHstep _UU0394_0 _ hkind_T ->
    case hkind_T of {
     K_Var _UU0394_1 _ _ ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ __;
     K_Fun _UU0394_1 _ _ x1 x2 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1 x2;
     K_IFix _UU0394_1 f1 t0 k0 x1 x2 ->
      eq_rec_r _UU0394_0 (\_ ->
        eq_rec_r f0 (\_ ->
          eq_rec_r t1 (\_ h3 h5 -> K_IFix _UU0394_0 f0 t2 k0
            (iHstep _UU0394_0 k0 h3) h5) t0) f1 __) _UU0394_1 __ __ x1 x2;
     K_Forall _UU0394_1 _ _ _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1;
     K_Builtin _UU0394_1 _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1;
     K_Lam _UU0394_1 _ _ _ _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1;
     K_App _UU0394_1 _ _ _ _ x1 x2 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1 x2;
     K_SOP _UU0394_1 _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1})
    (\tss_normal tss_sub_normal tss_sub1 tss_sub2 tss_sub_remainder tss_remainder _ _ _ _ _UU0394_0 _ hkind_T ->
    case hkind_T of {
     K_Var _UU0394_1 _ _ ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ __;
     K_Fun _UU0394_1 _ _ x1 x2 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1 x2;
     K_IFix _UU0394_1 _ _ _ x1 x2 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1 x2;
     K_Forall _UU0394_1 _ _ _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1;
     K_Builtin _UU0394_1 _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1;
     K_Lam _UU0394_1 _ _ _ _ x1 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1;
     K_App _UU0394_1 _ _ _ _ x1 x2 ->
      eq_rec_r _UU0394_0 (\_ -> false_rec) _UU0394_1 __ __ x1 x2;
     K_SOP _UU0394_1 tss x1 ->
      eq_rec_r _UU0394_0 (\_ ->
        eq_rec_r
          (app tss_normal (Cons
            (app tss_sub_normal (Cons tss_sub1 tss_sub_remainder))
            tss_remainder)) (\_ _ ->
          step_preserves_kinding_SOP_axiom
            (app tss_normal (Cons
              (app tss_sub_normal (Cons tss_sub2 tss_sub_remainder))
              tss_remainder)) _UU0394_0) tss) _UU0394_1 __ __ x1}) t t' x0
    _UU0394_ k x

type SN = Sn Ty Step

sN_normalise :: Ty -> (List (Prod BinderName Kind)) -> Kind -> Has_kind -> SN
                -> SigT Ty ()
sN_normalise t _UU0394_ k hWK hSN =
  sn_rec (\t0 _ h hWK0 ->
    let {s0 = step_dec t0 _UU0394_ k hWK0} in
    case s0 of {
     Inl s ->
      case s of {
       ExistT x s1 ->
        let {ht'_kind = step_preserves_kinding t0 x _UU0394_ k hWK0 s1} in
        let {h0 = h x s1 ht'_kind} in
        case h0 of {
         ExistT x0 _ -> ExistT x0 __}};
     Inr _ -> ExistT t0 __}) t hSN hWK

normaliser :: Ty -> (List (Prod BinderName Kind)) -> Kind -> Has_kind -> Ty
normaliser t _UU0394_ k hwk =
  let {hSN = plutus_ty_strong_normalization t _UU0394_ k hwk} in
  projT1 (sN_normalise t _UU0394_ k hwk hSN)

normaliser_Jacco :: (List (Prod BinderTyname Kind)) -> Ty -> Option Ty
normaliser_Jacco _UU0394_ t =
  case kind_check _UU0394_ t of {
   Some k -> Some
    (normaliser t _UU0394_ k (kind_checking_sound _UU0394_ t k));
   None -> None}

map_normaliser :: (List (Prod (Prod String Ty) (List (Prod String Kind)))) ->
                  Option (List (Prod String Ty))
map_normaliser xs =
  case xs of {
   Nil -> Some Nil;
   Cons p xs' ->
    case p of {
     Pair p0 _UU0394_ ->
      case p0 of {
       Pair x t ->
        bind (normaliser_Jacco _UU0394_ t) (\tn ->
          bind (map_normaliser xs') (\xs'' -> Some (Cons (Pair x tn) xs'')))}}}

bvc :: Vdecl -> Name
bvc c =
  case c of {
   VarDecl x _ -> x}

bvb :: Binding -> List BinderName
bvb b =
  case b of {
   TermBind _ v _ -> case v of {
                      VarDecl x _ -> Cons x Nil};
   TypeBind _ _ -> Nil;
   DatatypeBind d ->
    case d of {
     Datatype _ _ matchFunc cs -> Cons matchFunc (rev (map bvc cs))}}

bvbs :: (List Binding) -> List Name
bvbs bs =
  concat (map bvb bs)

btvb :: Binding -> List Tyname
btvb b =
  case b of {
   TermBind _ _ _ -> Nil;
   TypeBind t _ -> case t of {
                    TyVarDecl x _ -> Cons x Nil};
   DatatypeBind d ->
    case d of {
     Datatype t _ _ _ -> case t of {
                          TyVarDecl x _ -> Cons x Nil}}}

btvbs :: (List Binding) -> List Tyname
btvbs bs =
  concat (map btvb bs)

ftv1 :: Ty -> List String
ftv1 t =
  case t of {
   Ty_Var x -> Cons x Nil;
   Ty_Fun t1 t2 -> app (ftv1 t1) (ftv1 t2);
   Ty_IFix f0 t0 -> app (ftv1 f0) (ftv1 t0);
   Ty_Forall x _ t' -> remove string_dec x (ftv1 t');
   Ty_Builtin _ -> Nil;
   Ty_Lam x _ t' -> remove string_dec x (ftv1 t');
   Ty_App t1 t2 -> app (ftv1 t1) (ftv1 t2);
   Ty_SOP tss -> flatmap2 ftv1 tss}

getTyname :: Tvdecl -> BinderTyname
getTyname tvd =
  case tvd of {
   TyVarDecl x _ -> x}

getKind :: Tvdecl -> Kind
getKind tvd =
  case tvd of {
   TyVarDecl _ k -> k}

ty_Apps :: Ty -> (List Ty) -> Ty
ty_Apps f0 xs =
  fold_left (\x x0 -> Ty_App x x0) xs f0

ty_Foralls :: (List Tvdecl) -> Ty -> Ty
ty_Foralls xs t =
  fold_right (\yK t' -> Ty_Forall (getTyname yK) (getKind yK) t') t xs

replaceRetTy :: Ty -> Ty -> Ty
replaceRetTy t r =
  case t of {
   Ty_Fun s1 s2 -> Ty_Fun s1 (replaceRetTy s2 r);
   _ -> r}

dtdecl_freshR :: Dtdecl -> String
dtdecl_freshR d =
  case d of {
   Datatype _ _ _ cs ->
    concat0 EmptyString (concat (map (\c -> ftv1 (vdecl_ty c)) cs))}

constrLastTyExpected :: Dtdecl -> Ty
constrLastTyExpected dtd =
  case dtd of {
   Datatype xK yKs _ _ ->
    let {x = tvdecl_name xK} in
    let {ys = map tvdecl_name yKs} in
    ty_Apps (Ty_Var x) (map (\x0 -> Ty_Var x0) ys)}

matchTy :: Dtdecl -> Ty
matchTy d =
  let {r = dtdecl_freshR d} in
  case d of {
   Datatype _ yKs _ cs ->
    let {branchTypes = map (\c -> replaceRetTy (vdecl_ty c) (Ty_Var r)) cs}
    in
    let {
     branchTypesFolded = fold_right (\x x0 -> Ty_Fun x x0) (Ty_Var r)
                           branchTypes}
    in
    ty_Foralls yKs (Ty_Fun (constrLastTyExpected d) (Ty_Forall r Kind_Base
      branchTypesFolded))}

constrTy :: Dtdecl -> Vdecl -> Ty
constrTy d c =
  case d of {
   Datatype _ yKs _ _ -> case c of {
                          VarDecl _ t -> ty_Foralls yKs t}}

constrBind :: Dtdecl -> Vdecl -> Prod String Ty
constrBind d c =
  case c of {
   VarDecl x _ -> Pair x (constrTy d c)}

constrBinds :: Dtdecl -> List (Prod String Ty)
constrBinds d =
  case d of {
   Datatype _ _ _ cs -> rev (map (constrBind d) cs)}

matchBind :: Dtdecl -> Prod String Ty
matchBind d =
  case d of {
   Datatype _ _ matchFunc _ -> Pair matchFunc (matchTy d)}

binds_Delta :: Binding -> List (Prod String Kind)
binds_Delta b =
  case b of {
   TermBind _ _ _ -> Nil;
   TypeBind t _ -> case t of {
                    TyVarDecl x k -> Cons (Pair x k) Nil};
   DatatypeBind d ->
    case d of {
     Datatype t _ _ _ -> case t of {
                          TyVarDecl x k -> Cons (Pair x k) Nil}}}

binds_Gamma :: Binding -> List (Prod String Ty)
binds_Gamma b =
  case b of {
   TermBind _ v _ -> case v of {
                      VarDecl x t -> Cons (Pair x t) Nil};
   TypeBind _ _ -> Nil;
   DatatypeBind d ->
    let {constrBs = constrBinds d} in
    let {matchB = matchBind d} in Cons matchB constrBs}

data Builtin_sig =
   BS_Forall String Kind Builtin_sig
 | BS_Fun Ty Builtin_sig
 | BS_Result Ty

to_ty :: Builtin_sig -> Ty
to_ty s =
  case s of {
   BS_Forall x k s0 -> Ty_Forall x k (to_ty s0);
   BS_Fun t s0 -> Ty_Fun t (to_ty s0);
   BS_Result t -> t}

to_sig :: DefaultFun -> Builtin_sig
to_sig f0 =
  case f0 of {
   AddInteger -> BS_Fun (Ty_Builtin DefaultUniInteger) (BS_Fun (Ty_Builtin
    DefaultUniInteger) (BS_Result (Ty_Builtin DefaultUniInteger)));
   SubtractInteger -> BS_Fun (Ty_Builtin DefaultUniInteger) (BS_Fun
    (Ty_Builtin DefaultUniInteger) (BS_Result (Ty_Builtin
    DefaultUniInteger)));
   MultiplyInteger -> BS_Fun (Ty_Builtin DefaultUniInteger) (BS_Fun
    (Ty_Builtin DefaultUniInteger) (BS_Result (Ty_Builtin
    DefaultUniInteger)));
   DivideInteger -> BS_Fun (Ty_Builtin DefaultUniInteger) (BS_Fun (Ty_Builtin
    DefaultUniInteger) (BS_Result (Ty_Builtin DefaultUniInteger)));
   QuotientInteger -> BS_Fun (Ty_Builtin DefaultUniInteger) (BS_Fun
    (Ty_Builtin DefaultUniInteger) (BS_Result (Ty_Builtin
    DefaultUniInteger)));
   EqualsInteger -> BS_Fun (Ty_Builtin DefaultUniInteger) (BS_Fun (Ty_Builtin
    DefaultUniInteger) (BS_Result (Ty_Builtin DefaultUniBool)));
   AppendByteString -> BS_Fun (Ty_Builtin DefaultUniByteString) (BS_Fun
    (Ty_Builtin DefaultUniByteString) (BS_Result (Ty_Builtin
    DefaultUniByteString)));
   IfThenElse -> BS_Forall (String0 (Ascii True False False False False False
    True False) EmptyString) Kind_Base (BS_Fun (Ty_Builtin DefaultUniBool)
    (BS_Fun (Ty_Var (String0 (Ascii True False False False False False True
    False) EmptyString)) (BS_Fun (Ty_Var (String0 (Ascii True False False
    False False False True False) EmptyString)) (BS_Result (Ty_Var (String0
    (Ascii True False False False False False True False) EmptyString))))));
   _ -> BS_Fun (Ty_Builtin DefaultUniInteger) (BS_Result (Ty_Builtin
    DefaultUniInteger))}

lookupBuiltinTy :: DefaultFun -> Ty
lookupBuiltinTy f0 =
  to_ty (to_sig f0)

flatten :: (List (List a1)) -> List a1
flatten l =
  concat (rev l)

fromDecl :: Tvdecl -> Prod String Kind
fromDecl tvd =
  case tvd of {
   TyVarDecl v k -> Pair v k}

freshUnwrapIFix :: Ty -> String
freshUnwrapIFix f0 =
  append (String0 (Ascii True False False False False True True False)
    EmptyString) (concat0 EmptyString (ftv1 f0))

unwrapIFixFresh :: Ty -> Kind -> Ty -> Ty
unwrapIFixFresh f0 k t =
  let {b = freshUnwrapIFix f0} in
  Ty_App (Ty_App f0 (Ty_Lam b k (Ty_IFix f0 (Ty_Var b)))) t

insert_deltas_rec :: (List (Prod String Ty)) -> (List (Prod String Kind)) ->
                     List (Prod (Prod String Ty) (List (Prod String Kind)))
insert_deltas_rec xs _UU0394_ =
  case xs of {
   Nil -> Nil;
   Cons p xs' -> Cons (Pair p _UU0394_) (insert_deltas_rec xs' _UU0394_)}

insert_deltas_bind_Gamma_nr :: (List Binding) -> (List
                               (Prod BinderTyname Kind)) -> List
                               (Prod (Prod BinderName Ty)
                               (List (Prod BinderTyname Kind)))
insert_deltas_bind_Gamma_nr bs _UU0394_ =
  case bs of {
   Nil -> Nil;
   Cons b bs' ->
    app (insert_deltas_bind_Gamma_nr bs' (app (binds_Delta b) _UU0394_))
      (insert_deltas_rec (binds_Gamma b) (app (binds_Delta b) _UU0394_))}

allbmap :: (a1 -> Bool) -> (List a1) -> Bool
allbmap f0 bs =
  case bs of {
   Nil -> True;
   Cons b bs0 -> andb (f0 b) (allbmap f0 bs0)}

no_dup_fun :: (List String) -> Bool
no_dup_fun xs =
  case xs of {
   Nil -> True;
   Cons x xs0 ->
    case in_dec string_dec x xs0 of {
     Left -> False;
     Right -> no_dup_fun xs0}}

is_KindBase :: (Option Kind) -> Bool
is_KindBase k =
  case k of {
   Some k0 -> case k0 of {
               Kind_Base -> True;
               Kind_Arrow _ _ -> False};
   None -> False}

constructor_well_formed_check :: (List (Prod BinderTyname Kind)) -> Vdecl ->
                                 Ty -> Bool
constructor_well_formed_check _UU0394_ v tr =
  case v of {
   VarDecl _ t ->
    case splitTy t of {
     Pair targs tr' ->
      andb (ty_eqb tr tr')
        (allbmap (\u -> is_KindBase (kind_check _UU0394_ u)) targs)}}

binding_well_formed_check :: ((List (Prod BinderTyname Kind)) -> (List
                             (Prod BinderName Ty)) -> Term -> Option 
                             Ty) -> (List (Prod BinderTyname Kind)) -> (List
                             (Prod BinderName Ty)) -> Recursivity -> Binding
                             -> Bool
binding_well_formed_check type_check' _UU0394_ _UU0393_ rec0 binding =
  case binding of {
   TermBind _ v t ->
    case v of {
     VarDecl _ t0 ->
      case kind_check _UU0394_ t0 of {
       Some k ->
        case k of {
         Kind_Base ->
          case type_check' _UU0394_ _UU0393_ t of {
           Some tn ->
            case normaliser_Jacco _UU0394_ t0 of {
             Some tn' -> ty_eqb tn tn';
             None -> False};
           None -> False};
         Kind_Arrow _ _ -> False};
       None -> False}};
   TypeBind t t0 ->
    case t of {
     TyVarDecl _ k ->
      case kind_check _UU0394_ t0 of {
       Some k' -> kind_eqb k k';
       None -> False}};
   DatatypeBind d ->
    case d of {
     Datatype xK yKs matchFunc cs ->
      let {dtd = Datatype xK yKs matchFunc cs} in
      let {x = tvdecl_name xK} in
      let {ys = map tvdecl_name yKs} in
      case andb (no_dup_fun (Cons x ys)) (no_dup_fun (map vdecl_name cs)) of {
       True ->
        let {_UU0394_' = app (rev (map fromDecl yKs)) _UU0394_} in
        let {tres = constrLastTyExpected dtd} in
        andb
          (allbmap (\c -> constructor_well_formed_check _UU0394_' c tres) cs)
          (case rec0 of {
            NonRec ->
             case kind_check (Cons (fromDecl xK) _UU0394_') tres of {
              Some k ->
               case k of {
                Kind_Base -> True;
                Kind_Arrow _ _ -> False};
              None -> False};
            Rec ->
             case kind_check _UU0394_' tres of {
              Some k ->
               case k of {
                Kind_Base -> True;
                Kind_Arrow _ _ -> False};
              None -> False}});
       False -> False}}}

bindings_well_formed_nonrec_check :: ((List (Prod BinderTyname Kind)) ->
                                     (List (Prod BinderName Ty)) ->
                                     Recursivity -> Binding -> Bool) -> (List
                                     (Prod BinderTyname Kind)) -> (List
                                     (Prod BinderName Ty)) -> (List Binding)
                                     -> Bool
bindings_well_formed_nonrec_check b_wf _UU0394_ _UU0393_ bs =
  case bs of {
   Nil -> True;
   Cons b bs' ->
    case map_normaliser
           (insert_deltas_rec (binds_Gamma b) (app (binds_Delta b) _UU0394_)) of {
     Some bsGn ->
      andb (b_wf _UU0394_ _UU0393_ NonRec b)
        (bindings_well_formed_nonrec_check b_wf
          (app (binds_Delta b) _UU0394_) (app bsGn _UU0393_) bs');
     None -> False}}

bindings_well_formed_rec_check :: (Binding -> Bool) -> (List Binding) -> Bool
bindings_well_formed_rec_check b_wf bs =
  case bs of {
   Nil -> True;
   Cons b bs' -> andb (b_wf b) (bindings_well_formed_rec_check b_wf bs')}

type_check :: (List (Prod BinderTyname Kind)) -> (List (Prod BinderName Ty))
              -> Term -> Option Ty
type_check _UU0394_ _UU0393_ term =
  case term of {
   Let r bs t ->
    case r of {
     NonRec ->
      case no_dup_fun (app (btvbs bs) (map fst _UU0394_)) of {
       True ->
        let {_UU0394_' = app (flatten (map binds_Delta bs)) _UU0394_} in
        let {xs = insert_deltas_bind_Gamma_nr bs _UU0394_} in
        bind (map_normaliser xs) (\bsgn ->
          let {_UU0393_' = app bsgn _UU0393_} in
          case bindings_well_formed_nonrec_check
                 (binding_well_formed_check type_check) _UU0394_ _UU0393_ bs of {
           True ->
            bind (type_check _UU0394_' _UU0393_' t) (\t0 ->
              case kind_check _UU0394_ t0 of {
               Some k ->
                case k of {
                 Kind_Base -> Some t0;
                 Kind_Arrow _ _ -> None};
               None -> None});
           False -> None});
       False -> None};
     Rec ->
      case no_dup_fun (app (btvbs bs) (map fst _UU0394_)) of {
       True ->
        case andb (no_dup_fun (btvbs bs)) (no_dup_fun (bvbs bs)) of {
         True ->
          let {_UU0394_' = app (flatten (map binds_Delta bs)) _UU0394_} in
          let {
           xs = insert_deltas_rec (flatten (map binds_Gamma bs)) _UU0394_'}
          in
          bind (map_normaliser xs) (\bsgn ->
            let {_UU0393_' = app bsgn _UU0393_} in
            case bindings_well_formed_rec_check
                   (binding_well_formed_check type_check _UU0394_' _UU0393_'
                     Rec) bs of {
             True ->
              bind (type_check _UU0394_' _UU0393_' t) (\t0 ->
                case kind_check _UU0394_ t0 of {
                 Some k ->
                  case k of {
                   Kind_Base -> Some t0;
                   Kind_Arrow _ _ -> None};
                 None -> None});
             False -> None});
         False -> None};
       False -> None}};
   Var x -> bind (lookup x _UU0393_) (\t -> normaliser_Jacco _UU0394_ t);
   TyAbs x k t ->
    case type_check (Cons (Pair x k) _UU0394_) _UU0393_ t of {
     Some t0 -> Some (Ty_Forall x k t0);
     None -> None};
   LamAbs x t1 t ->
    bind (normaliser_Jacco _UU0394_ t1) (\t1n ->
      case type_check _UU0394_ (Cons (Pair x t1n) _UU0393_) t of {
       Some t2 ->
        case kind_check _UU0394_ t1 of {
         Some k ->
          case k of {
           Kind_Base -> Some (Ty_Fun t1n t2);
           Kind_Arrow _ _ -> None};
         None -> None};
       None -> None});
   Apply t1 t2 ->
    case type_check _UU0394_ _UU0393_ t1 of {
     Some t ->
      case t of {
       Ty_Fun t3 t4 ->
        case type_check _UU0394_ _UU0393_ t2 of {
         Some t1' -> case ty_eqb t3 t1' of {
                      True -> Some t4;
                      False -> None};
         None -> None};
       _ -> None};
     None -> None};
   Constant0 c -> case c of {
                   ValueOf t _ -> Some (Ty_Builtin t)};
   Builtin f0 ->
    let {t = lookupBuiltinTy f0} in
    bind (normaliser_Jacco _UU0394_ t) (\tn -> Some tn);
   TyInst t1 t2 ->
    case type_check _UU0394_ _UU0393_ t1 of {
     Some t ->
      case t of {
       Ty_Forall x k2 t3 ->
        case kind_check _UU0394_ t2 of {
         Some k2' ->
          case kind_check (Cons (Pair x k2) _UU0394_) t3 of {
           Some k ->
            case k of {
             Kind_Base ->
              case kind_eqb k2 k2' of {
               True ->
                bind (normaliser_Jacco _UU0394_ t2) (\t2n ->
                  bind (normaliser_Jacco _UU0394_ (substituteTCA0 x t2n t3))
                    (\t0n -> Some t0n));
               False -> None};
             Kind_Arrow _ _ -> None};
           None -> None};
         None -> None};
       _ -> None};
     None -> None};
   Error s' ->
    bind (normaliser_Jacco _UU0394_ s') (\s'n ->
      case kind_check _UU0394_ s' of {
       Some k -> case k of {
                  Kind_Base -> Some s'n;
                  Kind_Arrow _ _ -> None};
       None -> None});
   IWrap f0 t m ->
    case kind_check _UU0394_ t of {
     Some k ->
      case kind_check _UU0394_ f0 of {
       Some k0 ->
        case k0 of {
         Kind_Base -> None;
         Kind_Arrow k1 k2 ->
          case k1 of {
           Kind_Base -> None;
           Kind_Arrow k' k3 ->
            case k3 of {
             Kind_Base ->
              case k2 of {
               Kind_Base -> None;
               Kind_Arrow k'' k4 ->
                case k4 of {
                 Kind_Base ->
                  case type_check _UU0394_ _UU0393_ m of {
                   Some t0n ->
                    case andb (kind_eqb k k') (kind_eqb k k'') of {
                     True ->
                      bind (normaliser_Jacco _UU0394_ t) (\tn ->
                        bind (normaliser_Jacco _UU0394_ f0) (\fn ->
                          bind
                            (normaliser_Jacco _UU0394_
                              (unwrapIFixFresh fn k tn)) (\t0n' ->
                            case ty_eqb t0n t0n' of {
                             True -> Some (Ty_IFix fn tn);
                             False -> None})));
                     False -> None};
                   None -> None};
                 Kind_Arrow _ _ -> None}};
             Kind_Arrow _ _ -> None}}};
       None -> None};
     None -> None};
   Unwrap m ->
    case type_check _UU0394_ _UU0393_ m of {
     Some t ->
      case t of {
       Ty_IFix f0 t0 ->
        case kind_check _UU0394_ t0 of {
         Some k ->
          case kind_check _UU0394_ f0 of {
           Some k0 ->
            case k0 of {
             Kind_Base -> None;
             Kind_Arrow k1 k2 ->
              case k1 of {
               Kind_Base -> None;
               Kind_Arrow k' k3 ->
                case k3 of {
                 Kind_Base ->
                  case k2 of {
                   Kind_Base -> None;
                   Kind_Arrow k'' k4 ->
                    case k4 of {
                     Kind_Base ->
                      case andb (kind_eqb k k') (kind_eqb k k'') of {
                       True ->
                        bind
                          (normaliser_Jacco _UU0394_
                            (unwrapIFixFresh f0 k t0)) (\t0n -> Some t0n);
                       False -> None};
                     Kind_Arrow _ _ -> None}};
                 Kind_Arrow _ _ -> None}}};
           None -> None};
         None -> None};
       _ -> None};
     None -> None};
   _ -> None}


